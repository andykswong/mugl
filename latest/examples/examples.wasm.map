{"version":3,"sources":["~lib/rt/common.ts","~lib/rt/tlsf.ts","~lib/shared/typeinfo.ts","~lib/rt/itcms.ts","~lib/mugl/assembly/gpu/primitive.ts","~lib/mugl/assembly/gpu/gl-const.ts","~lib/mugl/assembly/gpu/type.ts","~lib/mugl/assembly/gpu/resource.ts","~lib/mugl/assembly/gl2/type.ts","~lib/util/error.ts","~lib/shared/runtime.ts","~lib/util/number.ts","~lib/util/math.ts","~lib/util/string.ts","~lib/rt.ts","~lib/memory.ts","~lib/util/memory.ts","~lib/mugl/assembly/gl2/webgl.ts","~lib/mugl/assembly/webgpu/type.ts","~lib/mugl/assembly/webgpu/gpu.ts","src/common/config.ts","src/common/models.ts","~lib/util/sort.ts","~lib/array.ts","src/apps/basic.ts","~lib/arraybuffer.ts","~lib/typedarray.ts","src/apps/instancing.ts","src/common/utils.ts","~lib/math.ts","~lib/munum/assembly/types/index.ts","~lib/munum/assembly/scalar.ts","~lib/munum/assembly/mat.ts","~lib/munum/assembly/vec3.ts","~lib/staticarray.ts","~lib/munum/assembly/vec4.ts","~lib/munum/assembly/aabb.ts","~lib/munum/assembly/plane.ts","~lib/munum/assembly/frustum.ts","~lib/munum/assembly/mat2.ts","~lib/munum/assembly/mat3.ts","~lib/munum/assembly/mat4.ts","~lib/munum/assembly/quat.ts","~lib/munum/assembly/vec2.ts","~lib/munum/assembly/transform.ts","src/apps/mrt.ts","src/apps/pbr.ts","src/apps/postprocess.ts","src/apps/stencil.ts","~lib/string.ts","src/apps/texture.ts","src/apps/index.ts","src/common/app.ts","assembly/index.ts","~lib/mugl/assembly/gpu/descriptor.ts","~lib/mugl/assembly/gpu/base-gpu.ts","~lib/mugl/assembly/gpu/utils.ts","src/interop/mugl/index.ts","~lib/mugl/assembly/dom/dom.ts","~lib/mugl/assembly/dom/resource.ts","~lib/function.ts"],"names":[],"mappings":"+jEGsDE,EAAsB,EAAtB,EACA,EAAa,EAAb,EACO,KAqCqB,KAAqB,EAAxC,IAUI,KAAqB,EAAzB,MAoDT,EACS,EACE,IAAX,EACA,EAAO,EAAQ,EAAR,GACa,KACF,EAA0B,EAA1B,CAAhB,EACO,IAAP,SArDA,EAAsB,KAAqB,GAAe,GAA1D,KAVA,EAAqB,EAA0B,KAAqB,IAApE,OA2BW,IACP,GAAJ,EACoB,QAKpB,EAFW,KAEC,EAAZ,EACA,EAAY,EAAZ,OAKW,OACX,EAAqB,EAA0B,EAA1B,CAArB,EACA,EAAY,EAAZ,EACA,EAAY,EAAZ,EACA,EAAY,EAAZ,OAKI,EAAQ,EAAR,CAAJ,EAAgC,EAAP,GAAP,GAClB,QA9BW,KAEJ,EAAQ,EAAR,MAAsC,EWpG5B,IAAV,GAAL,CAAJ,EAAyC,cACS,EAAK,EAAL,CAAtB,IAArB,IXmGgD,EAAnB,IA6BlC,EAAY,EAAmC,EAAL,CAAc,EAAnC,GAArB,KA6KG,EAAD,CAAJ,IAC6B,EAAM,EAAzB,CAEN,IAAa,EAAb,CAAJ,EACE,IACE,KAAF,MAtNyB,KAAc,GAAhC,mBFyJO,EAEL,GAAY,EAAZ,CAKP,EAAO,GAAP,CAAJ,EAEa,EAAQ,EAAd,EAIA,QADiB,WAAJ,CACI,EAAX,CAAN,CAEL,EAAM,GAAN,EADY,EAAgB,EAAK,EAAL,CAAhB,CAAkC,EAAzC,IAOI,OADA,KAEP,EAAJ,EAAU,EAAY,EAAZ,GACN,EAAJ,EAAU,EAAY,EAAZ,GAGN,EAhIF,EAA6B,EAAM,EAAN,CAAiB,EAAlB,CAAgC,EAAjC,CAA3B,CADK,MAUL,EAA6B,EAAM,EAAN,CAAiB,EAAlB,CAAgC,EAAjC,CAA3B,CACA,EAFF,GA4HO,EAAD,CAAJ,EAvJA,EAA2B,EAAM,EAAN,EAA3B,EAyJkB,KAAgB,EAAP,IAhJ3B,EACA,EAFF,GAoJS,EAAD,CAAJ,EAAY,SAAqB,EAAP,EAAd,WApGA,OAGK,cACL,KAGZ,EAAY,EAAZ,GACU,EAAM,EAAlB,EACA,EAA2B,EAAY,EAAZ,CAA8B,EAAY,EAAZ,CAA9B,CAAZ,EAAf,EACiB,EAnHiC,EAA3B,CAA6C,KAAe,IAoHvE,QAKV,EAAY,EAAZ,CAAJ,EA/HmB,EAA2B,EAA3B,CAAZ,GAiIU,OAEH,EAAM,EAAlB,EAEA,EAA2B,EAAW,EAAX,CAA6B,EAAY,EAAZ,CAA7B,CAAZ,EAAf,GAIF,EAAe,EAAY,EAAZ,CAAf,EASa,EAA2B,EAA3B,CAA4C,EAAzD,GAxEE,EAmES,EAAY,EAAZ,CASP,EAAO,GAAP,GAES,EAAQ,EAAd,EAIA,QADiB,WAAJ,CACI,EAAX,CAAN,CAEL,EAAM,GAAN,EADY,EAAgB,EAAK,EAAL,CAAhB,CAAkC,EAAzC,EAnFyC,EAAjB,EAAM,EAAN,CAAD,CAAgC,EAAjC,CAA3B,CADK,KA2FP,EAAa,EAAb,EACA,EAAa,EAAb,EACI,EAAJ,EAAU,EAAY,EAAZ,GAnFR,EAA6B,EAAM,EAAN,CAAiB,EAAlB,CAAgC,EAAjC,CAA3B,CACA,EAFF,GAwFA,OAAe,EAAK,EAAL,IA1Gb,EAA2B,EAAM,EAAN,EAA3B,EATA,EADK,GAqH4B,EAAK,EAAL,CA1GjC,CAFF,SA8BE,EADK,IAyMH,IALM,KAAoC,EAArC,CAAiD,EAAlD,CAUF,EAAQ,EAAR,CAAwB,EAAxB,IAES,OADX,EAAS,QAVb,CAAO,EAsBI,MACA,OAOX,EAAiC,EAAW,EAAX,CAFlB,EAAO,EAAP,CAED,EAAW,EAAX,EAAd,EACA,EAAY,EAAZ,EACA,EAAY,EAAZ,EAGyB,EAAQ,EAAR,CAAyB,EAA3C,CACP,EAAc,EAAd,EA/NE,EACA,EAFF,IAmOY,EAAM,EAAlB,QAgDkB,EAEA,EADA,EACd,GAAyC,EAAc,EAAd,CAAZ,EAAyC,EAAzC,KAAjC,IACW,IACE,EAAb,EACQ,IAAM,EAAd,KACwB,EAAK,EAAL,GACV,KAAN,KAAU,EAAhB,GACmB,EAAd,IAAiB,EAAK,EAAL,GACN,KAAI,MAAV,KAAc,EAAtB,GADoC,KAAF,MAFE,KAAF,MAY1B,IAAM,MAAU,CAAsB,EAAtB,GAErB,IAAP,QEjTA,QAAQ,SAEI,EAAR,EACa,EAAb,EACA,EACO,EAAP,EACO,IAGU,EAAL,CAAZ,EACM,IAAN,EACA,EAAO,EAAO,EAAP,GACE,EAAP,EACI,IAAa,EAAb,CAAJ,EACE,EAAY,EAAZ,EACa,EAAb,EACgB,EAAyB,EAAzB,CAAhB,EACO,IAEH,IAAN,MAEW,EAAb,EACA,EACM,EACF,EAAO,EAAP,CAAJ,EAtCM,EAAV,EACA,EAAO,EAAM,IAAN,GACe,EAAZ,GAAR,EACA,EAAO,GAAP,MAqCU,IAAN,EACA,EAAO,EAAO,EAAP,GACD,IAAa,EAAb,CAAJ,EACE,EAAY,EAAZ,EACgB,EAAyB,EAAzB,CAAhB,GAEI,IAAN,MAES,EAAX,EACY,EAAZ,EACU,EAAV,EACQ,EAAR,EACO,IAAP,EACQ,EAAR,GAEK,IAGD,EACF,EAAO,EAAP,CAAJ,EACS,IAAP,EACkB,KAepB,EAAyB,IAAzB,CAdE,EAeJ,EAAoB,EAApB,EACA,EAAW,EAAX,GAEA,EAAS,KAAT,EAIO,EAAyB,EAAzB,CF+UL,EAAM,IAAN,CE/UF,EFgVG,EAAD,CAAJ,EAAW,GACoB,EA9BK,EAAxB,CAAZ,EAEgB,EAAM,EAAN,GAAd,QACE,KAAe,EAAf,GA2BM,IAzBH,EAXQ,KAAe,EAAf,GACH,EAAM,EAAlB,IEnUa,IAET,EAAwB,EAAxB,EACA,EAAe,EAAf,EACQ,EAAR,WFiFA,EAAO,GAAP,CAAJ,EAEa,EAAQ,EAAd,EAQA,EAFD,EAAQ,EAAM,EAAsB,EAAX,CAAX,CAAN,CAAR,CAA8C,EAA9C,CACA,EAFc,EAAO,MAAP,EAGI,EAAX,CAAN,CAEL,EAAM,GAAN,EADY,EAAgB,EAAK,EAAL,CAAhB,CAAkC,EAAzC,IAMW,EAAM,SAAO,EAAM,EAAN,EAE1B,IA1KH,EAsLkC,EAtLY,CAAjB,EAAM,EAAN,CAAD,CAAgC,EAAjC,CAA3B,CADK,IA6KO,KAAc,EAAO,EAAK,EAAL,CAAP,EACrB,EAAL,EAMiB,EAtMjB,EAmMkB,EAAX,CAnMoB,EAAM,EAAN,CAA3B,CAsMoC,GAAT,CAAJ,wBAmHrB,EAAO,MAAP,CAAJ,EAA0C,eAkClB,EAxCpB,EAOe,IANb,CAAmC,EAApC,CAAgD,EAAjD,CAFG,EAAQ,EAAR,EAyCuB,EAAlB,EACP,KAxDa,EAGI,EAFd,EA/PN,EADK,IAgQ0B,EAAsB,EAAtB,CAA4B,EAA7B,GAL9B,EAAS,EAAM,EAAsB,EAAX,CAAX,CAAN,CAAsC,EAAvC,IA6DS,EA/DR,MAAP,EAQsB,CAAO,IAAP,CAAiB,IAAlB,CAA+B,EAAtC,CACiB,OACnB,CAAZ,EAA2B,EAA3B,CAAJ,EACkB,EAAZ,EAA2B,EAA3B,CAAJ,KAGQ,EAAM,EAAsB,EAAtB,CADC,EACyB,CAAmB,EAAnB,GAkDF,EAAM,EAApC,WAIE,EAAM,EAAlB,EAhJgB,KAIC,EAAY,EAAZ,CAA0B,EAA3B,CACZ,EAAa,EAAb,CA4IJ,EA3IE,EAAe,EAAQ,EAAY,EAAZ,CAAR,CAAf,EAE8B,EAA2B,EAA3B,CAA4C,EAA9D,CACZ,EAAgB,EAAY,EAAZ,CAA8B,EAA/B,CAAf,EACY,EAAM,EAAlB,GAIA,EAAe,EAAY,EAAZ,CAAf,EACS,EAlRyC,EAA3B,CAA6C,KAAe,WAkRzD,MAoIrB,4BElPH,EAAQ,MAAR,CAAJ,EAA4C,eACxC,EAAS,EAAT,CAAJ,EAAwB,EA2IJ,GAApB,EACA,EACE,EAAU,GAAV,EACI,GAAJ,IAEsB,KAA0B,IAAlC,CAAyC,GAAzC,CAAZ,KAIK,EAAS,EAAT,IAEG,EAA4B,EAAQ,EAAR,CAAoB,GAA1B,CAAd,GAAR,CAAZ,IF8JK,EAAD,CAAJ,EAAW,GAC4B,EEpTgB,EAAlB,GFoT9B,EEnTP,EAAW,EAAX,EACA,EAAa,EAAb,EACA,EAAW,EAAW,EAAtB,EACA,EAAS,KAAT,EACU,EAAyB,EAAzB,CYvPD,IAAQ,IC+KS,EACjB,IACK,gBACR,KAAF,MbwEG,OYnPL,EAAkB,ICuHhB,EAAQ,EAAR,CAAJ,EAOI,EAAO,EAAP,CAAJ,EAgBE,EAAO,IACK,SAAiB,mBACzB,KAAF,OAeF,EAAO,IACK,EAAS,KAAF,EAAP,CAAqB,EAAM,EAAN,CAAT,GAAtB,YFhKe,EAAM,EAAZ,EAAb,EACI,EAAJ,EAAsB,EAAQ,EAAM,EAA1B,GACH,OXwQF,EAAD,CAAJ,IAE+B,EAAW,EAA9B,CACR,IAAe,EAAf,CAAJ,EACkC,EAAY,EAA/B,CACK,IACd,EAAoB,EAAL,CAAf,CAAJ,EAKI,EAGA,EANE,GAAJ,GAQuC,EAAS,EAAT,CAA9B,EAAe,EAAf,EAAJ,EAEL,oG0BwFJ,EAAK,EAAK,EAAL,CACL,CAAK,WACA,EAAK,EAAL,CAAL,EACA,CAAK,WACA,EAAK,EAAL,CAAL,EACO,IAIP,EAAK,OACmB,EAAI,EAAJ,CAAlB,EAAK,EAAK,EAAL,CAAL,CAAD,CACsB,EAAI,EAAJ,CAAjB,EAAK,EAAK,EAAL,CAAL,CAAD,CAAJ,GAAL,GACY,EAAK,EAAL,CAAL,MK1TI,EAA2B,EAAgB,EAAhB,CAA3B,CAA0D,EAAnE,eOrFK,aCIA,KR4CqB,EAA0B,EAA7C,IAAwE,EAAxE,IA4BQ,EAA2B,EAAgB,EAAhB,CAA3B,CAAR,mGXhBoC,GAAY,EAA1C,SAIb,OAAc,aACd,OAAiB,MACjB,OAAkB,OAClB,OAAe,WS3ET,ICYwB,KAAc,KAAc,KAX9C,KACE,KACA,oBGHD,KHYiB,KAAc,KAAc,KGX7C,oBCCA,KJUiB,KAAc,KAAc,KIT7C,KJSiB,KAAc,KAAc,KKP7C,aCLD,YCAA,ICCA,ICGC,IACA,mFCHC,KVUgB,KAAc,KAAc,KUT5C,oBCCD,oBACA,KXOiB,KAAc,KAAc,KWN7C,QVuFJ,EAA2B,EAAgB,EAAhB,CAA3B,CAA0D,EAAnE,GAES,EAAyB,EAA0B,EADxC,KehDM,EAA0B,EAA7C,IAAuE,EAAvE,4U9C4RL,EAAJ,EAC+B,EAAM,EAAzB,CACN,IAAa,EAAb,CAAJ,EACkB,gBAElB,IACA,EAAW,EAAU,EAArB,GAEK,KAMF,EAAD,CAAJ,IAC6B,EAAM,EAAzB,CACN,IAAa,EAAb,CAAJ,EACkB,gBAEd,EAAS,EAAT,CAAJ,EAIE,KAEA,IACA,EAAW,EAAW,EAAtB,MAQE,EAAQ,EAAR,CAAJ,EAEE,EAAO,eAIT,EAAO,aACa,KAA0B,IAAlC,CAAyC,GAAzC,CAAZ,Q8C0UiB,EAAO,EAAc,EAAd,CAAP,CAAb,EACa,EAAb,EACA,EAAO,EAAM,EAAN,GACmB,EAAf,GACL,EAAK,GAAL,GACQ,EAAQ,EAAlB,GACA,MAGS,EAAK,GAAL,GAGE,EAFF,EAAM,EAAN,CAAU,GAEU,CADpB,EAAK,EAAL,CAAU,GACA,CAAM,EAAN,EAAnB,GACA,EAAU,IASJ,EAAK,IAAL,CAAe,EAAM,EAAN,CAAU,EAAV,CAAf,CADD,EAAK,IAAL,CAAgB,IAAjB,EAAJ,EAE4B,EAAf,GACJ,EAAK,IAAL,CAAgB,IAAjB,CAAJ,EAMa,EALM,EAAK,GAAL,CAAgB,EAAjB,CAAX,KAAmC,EAAK,GAAL,CAAnC,CAII,EAAW,EAAX,CAAgB,GACN,CAAM,EAAN,CAFV,EAAM,EAAN,CAAW,EAAX,CAAgB,GAEK,CAAM,EAAN,CAAX,CAHV,EAAM,EAAN,CAAW,EAAX,CAAgB,GAGgB,CAAM,EAAN,CAAtB,CAJV,EAAM,EAAN,CAAW,GAI+B,CAAhC,CAAnB,GACA,EAAU,GAAV,EAAa,EAAO,GAAP,MAYR,EAHF,EAAM,EAAN,CAAW,GAGS,CAFpB,EAAM,EAAN,CAAW,EAAX,CAAgB,GAEN,CAAM,EAAN,EAAnB,GACU,EAFD,EAAW,EAAX,CAAgB,GAEP,CAAlB,GACA,EAAU,OAEZ,EAAO,GAAP,SxBprBsB,EAA0B,EAA7C,iGSqCE,EAA2B,EAAgB,EAAhB,CAA3B,CAA0D,EAAnE,aLsCc,EAAI,WACN,CAAa,EAAb,CAAmB,GAApB,CACA,EAAS,EAAT,CAAb,EACiC,EAAU,GAAhB,CAAsB,EAAtB,CAAd,KAGM,EAAV,GAAT,EACmB,EAAV,GAAT,EACmB,EAAV,GAAT,EAGI,KAAJ,EAGsB,EAAM,EAAN,CAAf,KAFa,EAAL,CAEF,EAAN,EAAL,EACoB,EAAM,EAAN,CAAf,EAAM,EAAN,EAAL,EACoB,EAAM,EAAN,CAHD,EAGd,GAAM,EAAN,KAOY,EAAI,SAAJ,CAA0B,SAA3B,CAAlB,WAGiB,uEAIO,EAAb,EAAM,EAAN,CAAD,CACM,gBAAN,EACgB,EAAM,GAAV,CAAN,EAHN,EAAK,EAGL,GAIA,EAAO,EAAP,CAAW,EAAO,EAAP,CAAX,CAGA,EAAY,EAAZ,CAI2C,EAR3C,EAAO,EAQ8B,IAAW,EAHhD,EAAO,EAG+C,CAAN,CArF1C,EAAJ,CAAZ,EAEK,EAAM,EAAN,CAAc,EAAO,GAAK,EAAL,CAAP,CAAd,CAuBA,EAAI,MAAJ,CAAL,EAGA,EAAM,GAMI,EAAL,OAFI,EAAJ,OAFK,EAAL,OAEU,EAAK,EAAL,CAAV,CAEU,EAAI,MAAJ,CAAV,CAAL,EAEgB,EAAJ,OAHP,EAAK,EAGU,CAAR,CAAc,EAAK,EAAL,CAAd,CAAZ,IA1BoC,CAApB,UAPhB,EAAO,GAO2D,CAApB,WAApC,EAEwB,EAmB7B,EAAI,MAMU,CAAX,EAAK,EAAL,CAAD,CAzBsB,GAAJ,CANhB,EAEC,EAAM,EAIG,EAAN,CAAb,EAHqB,EAAM,EAAN,CAAX,EAAM,EAAN,CAImB,CAAM,GAAZ,CAAV,UAAb,EA4EA,EAJc,UAtEP,EAsEiE,GAEzC,CADhB,EAAI,EAAJ,CAAW,WACe,CAAV,CAAjB,CAEA,GAAd,EACA,EAAc,GAAd,EAPW,EAAY,EAAZ,CAAkB,EAAnB,CASH,WAkwCqB,EAAjB,CACI,EAAK,GAAT,CACE,EAAM,EAAN,CAAX,EAEA,EAAM,OAGF,EAAM,MAAN,CAAJ,EACM,EAAK,MAAL,CAAJ,EACS,MAEO,8FAId,EAAM,MAAN,CAAJ,EAA6B,EAAI,EAAJ,KAjwChB,EAAK,GAAX,CAAiB,MAAjB,CAiCL,EAAK,MAAL,CAAJ,EAKW,EAAM,EAAN,CAGA,EALA,EADQ,EAAI,SAAJ,CAAR,CACI,EAAI,SAAJ,CAAJ,CAGA,EAFA,EAAI,SAAJ,CAEI,EAAJ,CACuB,EAAjB,CAAwB,GACxB,CAAM,EAAN,CAAY,GAAb,CAEV,CAAI,EAAJ,GAIG,EAAI,SAAJ,CAHG,EAEH,EADA,EAAI,SAAJ,CACI,EAAJ,CACoB,EAAJ,CAAS,EAAV,CAAf,GAGD,EAFC,EAAI,EAAJ,CACuB,EAAjB,CAAwB,GACzB,CAAM,EAAN,CAAY,GAAb,CACL,CAAI,EAAJ,GAIG,EAAI,SAAJ,CAHG,EAEH,EADA,EAAI,SAAJ,CACI,EAAJ,CACoB,EAAJ,CAAS,EAAV,CAAf,GACA,EAAI,EAAJ,SAGC,EAAI,EAAJ,CAAU,EAEP,CAAb,IACO,OAEkB,EAAnB,EACO,EAAD,CAAI,EAAG,EAAd,IAosCI,EAAT,EACS,EAAT,EAEI,EAAI,EAAJ,GAAiB,EAjqCX,EAAJ,CACA,EAAI,EAAJ,CAAR,EAGI,SADW,EAAN,UACC,EAAN,CACG,EAAO,SAAM,EAAN,CAAW,EAAZ,CAAmB,EAHxB,EAAU,EAAU,EAAI,SAAJ,CAAL,UAAL,CAAL,UAAL,CAA+B,EAAI,EAAJ,CAAc,EAAU,EAAI,SAAJ,CAAL,UAAL,CAAL,UAAT,CAGH,CAAJ,CAAQ,EAAI,EAAJ,CAAR,CAApB,CA4pCE,EAA4B,EAxrC9B,EAAJ,CAGA,EAAI,EAAJ,GAIC,EAAM,EAirC+B,EAjrC1B,UAAU,EALjB,EAAU,EAAI,SAAJ,CAAL,UAAL,CAAL,UAAyB,EADzB,EAAI,EACyB,CAAJ,CAAc,EAAI,SAAJ,CAAL,UAAT,CAKC,CAAJ,CAAV,CAAL,CAAwB,EAAxB,CAA6B,EAAI,SAAJ,CAA9B,CAirCmB,EACf,EAAD,CAAK,EAAb,EAAI,EAAJ,YArvBmB,EAAjB,CACI,EAAK,GAAT,CACE,EAAM,EAAN,CAAX,EAEA,EAAM,OAGF,EAAM,MAAN,CAAJ,EACM,EAAK,MAAL,CAAJ,EACS,WAEO,yJAId,EAAM,MAAN,CAAJ,EAA6B,EAAI,EAAJ,KAniBhB,EAAK,GAAX,CAAiB,MAAjB,CAiCL,EAAK,MAAL,CAAJ,EAKW,EAAM,EAAN,CAGA,EALA,EADQ,EAAI,SAAJ,CAAR,CACI,EAAI,SAAJ,CAAJ,CAGA,EAFA,EAAI,SAAJ,CAEI,EAAJ,CACuB,EAAjB,CAAwB,GACxB,CAAM,EAAN,CAAY,GAAb,CAEV,CAAI,EAAJ,GAIG,EAAI,SAAJ,CAHG,EAEH,EADA,EAAI,SAAJ,CACI,EAAJ,CACoB,EAAJ,CAAS,EAAV,CAAf,GAGD,EAFC,EAAI,EAAJ,CACuB,EAAjB,CAAwB,GACzB,CAAM,EAAN,CAAY,GAAb,CACL,CAAI,EAAJ,GAIG,EAAI,SAAJ,CAHG,EAEH,EADA,EAAI,SAAJ,CACI,EAAJ,CACoB,EAAJ,CAAS,EAAV,CAAf,GACA,EAAI,EAAJ,SAGC,EAAI,EAAJ,CAAU,EAEP,CAAb,IACO,OAEkB,EAAnB,EACO,EAAD,CAAI,EAAG,EAAd,IAseI,EAAT,EACS,EAAT,EAEI,EAAI,EAAJ,GA1dE,EAAI,EAAJ,CAGA,EAAI,EAAJ,GAIC,EAAM,EAmdY,EAndP,UAAU,EALjB,EAAU,EAAI,SAAJ,CAAL,UAAL,CAAL,UAAyB,EADzB,EAAI,EACyB,CAAJ,CAAc,EAAI,SAAJ,CAAL,UAAT,CAKC,CAAJ,CAAV,CAAL,CAAwB,EAAxB,CAA6B,EAAI,SAAJ,CAA9B,CAmdA,EAA+B,EAncjC,EAAJ,CACA,EAAI,EAAJ,CAAR,EAGI,SADW,EAAN,UACC,EAAN,CACG,EAAO,SAAM,EAAN,CAAW,EAAZ,CAAmB,EAHxB,EAAU,EAAU,EAAI,SAAJ,CAAL,UAAL,CAAL,UAAL,CAA+B,EAAI,EAAJ,CAAc,EAAU,EAAI,SAAJ,CAAL,UAAL,CAAL,UAAT,CAGH,CAAJ,CAAQ,EAAI,EAAJ,CAAR,CAApB,CA8bwB,EACZ,EAAD,CAAK,EAAlB,EAAI,EAAJ,CAAS,EAAV,4IqBhcP,+JS3PY,iCpDxBC,sDAwEA,sDAoOI,s7D2B2DL,EAAyB,EAA0B,EAA7C,OAChB,EAAO,EAAM,EAAN,GACiB,EAAZ,GACN,EAAJ,EAAiB,EAAR,GACT,EAAO,GAAP,+xCX5XmB,KACrB,SAA0B,MACxB,EAAU,MAAV,CAAJ,EAAgE,gBAChC,cAGV,OAAJ,CAA0B,EAA1B,CAAlB,EACI,EAAJ,QAAmC,EAAe,EAAf,YAAJ,GAAsC,OAA1C,CACI,KAAT,EpB4PiB,EAA5B,CAEA,KAAgB,EAAhB,CAAsB,EAAvB,MACV,EAAgB,EAAhB,EACO,OAIU,EAAM,KAAZ,EACD,EAAQ,EAAY,EAAM,YAAV,CAA5B,GoBrQgB,EAMC,EAAX,GACW,EAAO,EAApB,GACa,EAAO,EAApB,GACO,EAAO,EAA4B,EAA1C,GAES,EAAO,EAAlB,sMFhC0C,aACE,aACN,aACI,aACD,6pFIWrC,EAAc,MAAuB,EAAvB,CAAd,CAAJ,EAAyE,gBACrB,EAAU,EAAV,CAAT,EAA8B,EAA5D,SAIb,OAAc,aACd,OAAiB,MACjB,OAAkB,oPCywCd,OAAuC,MAAqC,4BACnD,EAAgB,EAAhB,EAAiC,mILjxC5D,EAAJ,IACW,sBAamC,EAT5C,EAAkB,KADhB,EAAJ,CAIE,EAAkB,KADhB,EAAJ,CAIE,EAAkB,KADhB,EAAJ,CAI6B,GAAjB,UACI,EAAI,EAAJ,GAEV,EAAJ,IACE,OAAgC,OAAU,gBAAtC,EAAI,GAAJ,IAAyC,UAC7C,OAAgC,OAAU,gBAAtC,OAAyC,UAC7C,OAAgC,OAAU,gBAAtC,OAAyC,gBAE3C,EAAJ,IACE,OAAgC,OAAI,gBAAhC,EAAI,GAAJ,OAAmC,UACvC,KADyB,KACA,SAAO,OAAI,kBAAhC,KAAmC,SAErC,EAAJ,IACE,OAAgC,OAAQ,gBAApC,EAAI,GAAJ,OAAuC,UAC3C,KADyB,KACA,SAAO,OAAQ,kBAApC,KAAuC,UAC3C,OAAgC,OAAQ,kBAApC,KAAuC,QAAlB,QAEvB,EAAJ,IACE,OAAgC,OAAO,gBAAnC,EAAI,GAAJ,OAAsC,UAC1C,KADyB,KACA,SAAO,OAAO,kBAAnC,KAAsC,UAC1C,OAAgC,OAAO,kBAAnC,KAAsC,UAC1C,OAAgC,OAAO,gBAAnC,EADqB,QACiB,SApBhB,KAAF,aAuBrB,wCKoiBD,OAAuC,MAAqC,4BACnD,EAAgB,EAAhB,EAAiC,4EE/kBhD,OACd,cAAI,IAAU,QADmB,KAAF,aAG1B,2EAIqB,wBACR,UAAJ,OACd,OAAS,4BAAK,yDAAV,OAD6B,KAAF,aAG1B,sEC63CA,EAAD,CAAJ,EAAgD,EAAjB,CAT3B,KAAoB,WACO,SACC,IAAD,CAAZ,EAAnB,IAC8B,CAAX,EAAnB,EAC8B,KACd,EAAhB,GAKS,EAAT,EACS,EACU,EAAnB,EACA,EAAM,EAAM,EAAN,EACN,EAAM,EAAM,EAAN,CACN,CAAM,EACN,CAAM,EAAM,EAAN,CACa,CAAnB,MACS,EAAM,EAAN,CAAY,UACG,CAAjB,CAAsB,SAAtB,iRG5yCO,cACG,QAAK,KAAtB,MAAwB,EAAF,MADQ,KAAF,aAGvB,yBG5BQ,OAAG,yIAgCE,YAAe,iBAAI,yBH1DnB,SAAJ,OACJ,OAAS,OAAL,IAAO,IAAK,KADI,KAAF,oBAGvB,wCXRS,mBACX,EAAD,CAAJ,EACyB,EAAhB,UAEmB,YAAiB,eACzB,UAAJ,OACd,OAAa,OAAQ,gBAAjB,EAAI,GAAJ,IAAoB,YACxB,OAAiB,OAAQ,gBAArB,EAAQ,EAAR,GAAwB,YAC5B,OAAiB,OAAQ,gBAArB,EAAQ,EAAR,GAAwB,UAHQ,KAAF,4eK2gB3B,UAAoB,wCAKvB,OAAuC,MAAqC,4BAC7C,EAAgB,EAAhB,qCuBtdjB,0CAfd,EAAJ,0BAxBO,OAAY,yBAIG,SAAe,OACd,WAAgB,GACP,EAAX,GACjB,GAAJ,oBACmC,EAAS,EAAlC,OACE,EAAwB,EAAyB,EAA7D,EACY,EAAyB,EAAzB,CAAmC,EAA0B,EAAzE,iBAVO,wCpCq8BO,EAAS,EAAT,CACZ,EAAY,EAAZ,CAAJ,EAA0B,SAErB,EAAD,CAAJ,IACkB,EAAR,UAED,oBAAmC,UAE/B,kCAEO,EAAJ,OACE,EAAa,EAAY,EAAZ,CAAb,CAAR,0DAGJ,EAAJ,mCAJ+B,KAAF,QAMf,EAAa,EAAoB,EAApB,CAAb,CAAR,0DAGD,yDqBxrB8C,0nDkBlWnB,2BACV,aACC,oHDFyD,sE3BiC1D,aACU,aACR,eAMlB,iGGqCkB,aACQ,aACL,aACH,aACG,aACN,aACO,aACL,WACoB,EAAjB,2BACjB,kBAMH,wCwB5F6F,OAAQ,wCACjB,uEDkLlE,aAEE,aACC,aAEM,aACE,eAM7B,mGFpFkB,aAEE,aACC,WAES,GAAjB,2BACO,aAEF,aACA,aAEY,aACO,aAER,aACH,eAM1B,wCG9HgF,OAAQ,yFJqFtE,aACS,aACP,aACC,aACG,aACA,aACE,aACI,aACA,aACP,aACO,aACX,aACe,aACR,aACE,WAEM,EAAjB,yBACmB,EAAjB,qEIrGuE,8FNwDxE,aACS,aACP,aACC,aACG,aACA,aACM,aACA,aACX,aACH,aACM,aACH,aACW,aACI,aACR,WAEQ,EAAjB,qEMvE8D,uGLqH7D,aACE,aACC,aACF,aACA,aACK,aACD,aACO,aACZ,aACW,aACZ,aACC,aACO,aACI,aACC,aACF,aACC,WAEK,EAAjB,yBACgB,EAAjB,sCMzImC,wCDEkC,orBEjBxF,MAAD,CAAJ,4F9CqBY,a8CjBG,WACkB,WAAjB,SAAK,kBAAoB,aAAzB,OAChB,kHACY,EAAZ,iCAIY,OACR,EAAJ,MACS,8IDZA,0CCkBG,OACR,EAAJ,IACE,qFDGA,OAAa,aACC,2CCCJ,OACR,EAAJ,IACE,gElBsF8C,8DiB9FvC,KAAiB,EAAS,gHE8Hd,8EL+hByC,OA1B7C,EAC4D,EAA5C,IAAhB,OAEN,EAAS,EAAT,GACmB,EAAf,GACL,EAAK,GAAL,GAGF,EAAU,IACD,EAAK,GAAL,GACT,EAAU,IAEL,EAAK,IAAL,CAAgB,IAAjB,CAA2B,EAAS,EAAT,CAAa,EAAb,CAA3B,CAAJ,EACsB,EAAf,GAA4B,IAA5B,CAAuC,IAAxC,CAAJ,EACE,EAAU,GAAV,EAAa,EAAU,GAAV,MAIjB,EAAU,OAEZ,EAAU,GAAV,QAEK,EAIyE,gBACnE,MAAoC,kBAC1C,4BMjoBS,OAAQ,4HhD2CH,oCAAW,EAAyB,IAAiB,+CgDjBhE,cAAW,cAA6B,4D9BtEtB,sB8BsEP,IAA4C,EAAjC,GAAkD,GAAiB,8D3B/ExF,OAAiB,kE0BanB,aAGQ,2B1BhBqB,aAAa,uC2BiCnC,OAAQ,yFhDOH,cAAW,2BAAW,uBqBxChC,OACf,OAAgB,OAAQ,OAAQ,qBACzB,iDAJmE,4H0BsP7C,2BAGX,yEErKmB,YACjB,UAAJ,eACwB,QACzB,EAAb,EACa,EAAR,MAAe,OAAQ,+BAAZ,OACC,OAAQ,iDAAc,yDACrC,kEFwKmB,cAGR,aAGQ,2BE7KjB,aACQ,aACR,kBAEF,EAAyB,EAxDb,EAVe,CAAtB,EAAU,EAAV,CAAe,EAAhB,CAkEM,EAAV,EACE,KAAF,EARkD,KAAF,QAUlD,+EFsI8B,2BAGjB,aAGY,2BE3IvB,oBACA,aACU,OAAQ,uCAhBgB,KAAF,aAoB7B,mGFwKiB,eAGF,aAGU,0EASR,aAGC,aAGN,gBAGU,iBAGL,sHA5IY,2CAMK,wEAoCrB,aAGO,8LAfK,iCAGA,yFA0KJ,eAGH,aAGA,sJ/CtKgB,kBAAoB,mCAExB,kBAAe,wF+C0Hf,aAGb,wF/C3HH,0BAEH,EAAI,EAAJ,KACG,mBAAa,+BAA9B,KADgC,KAAF,QAG2B,EAAxB,GAAhB,UACyC,EAA5B,GAAhB,UACO,EAAI,EAAJ,KAEN,qBAAa,UADf,EAAyD,EAA5B,GAA7B,CAEF,EAAM,EAAjB,KACiB,iBAAN,YACM,KAAN,YACM,KAAN,UAEE,EAAR,MAAe,sBAAJ,OAEI,qBAAkB,YACf,KAFJ,EAAyD,EAAI,EAAJ,CAAzB,GAAhC,CAEN,YACU,KAAV,YACU,KAAV,UALmC,KAAF,QAQzC,sBAAL,KAhBuC,KAAF,QAmBjB,0BACiB,EAAJ,GAAhB,QACN,EAAR,IAAW,EAAI,EAAJ,KAC4C,mBAAgB,cAAvD,EAAoC,EAAJ,GAAhC,SADgB,KAAF,QAKjB,cAAkB,uBAA0B,SAC/B,GAAhB,QACF,EAAR,IAAW,EAAI,EAAJ,KAEC,qBAAiB,YAEf,KADJ,EAAsD,EAA1B,GAA5B,CACF,YACM,KAAN,YACM,iBAAN,YACM,iBAAN,YACM,iBAAN,YACM,iBAAN,YACM,iBAAN,YACM,iBAAN,UAXoB,KAAF,QAca,mCACE,mCAE9C,OACE,cACA,8EAAgB,8EAIhB,0BAAyB,0BAA4B,0BAA0B,0BAC/E,0BAA8B,0BAC5B,gBAAmB,cAAoB,cAAwB,cACjE,0BAAkC,0BAAiC,0BAAsC,0BACzG,0BAAiC,0BAAgC,0BAAqC,0BACtG,cAA6B,cAA8B,cAAuB,cAAiC,cAEnH,cACA,0BAA8B,0BAA8B,0BAC5D,0BAA8B,0BAA8B,0BACvB,aAAoE,SAdzG,EAAgB,EAChB,EAA+B,EAC/B,EAA4B,EAC5B,EAA+B,EAC/B,EAAyB,EAA4B,EAA0B,EAC/E,EAA8B,EAC9B,EAAqB,EAAoB,EAAwB,EACjE,EAAkC,EAAiC,EAAsC,EACzG,EAAiC,EAAgC,EAAqC,EACtG,EAA6B,EAA8B,EAAuB,EAAiC,EACnH,EAA2B,EAC3B,EACA,EAA8B,EAA8B,EAC5D,EAA8B,EAA8B,EAC5D,EAAqC,EAA6B,IAAuC,qCgDhNjF,OAAQ,oID0TT,aAMP,gBAME,8BASa,aAGA,oM/C/GrB,cAAc,uBAAsB,OACO,EAAxB,GAAhB,UACC,EAAI,EAAJ,KAGA,qBAAa,YACJ,iCAHV,EAAoD,EAAxB,GAA5B,CAGI,YACA,mBAAN,YACM,mBAAN,YAGQ,gBAAc,mBAAe,UAC/B,KAAN,IAAiB,UACX,KAAN,IAAiB,UACX,KAAN,IAAiB,UACX,KAAN,IAAiB,QAbH,KAAF,QAiBN,gBAAkB,mBAAmB,UAExD,OACE,cACA,cAAiB,cACjB,OAAW,SAAI,OAAW,SAAI,OAAW,SAAI,OAAW,SACtD,gBAEF,cAAoB,qCAAgC,cACpD,cAAoB,uBAA8B,OAClD,SANA,EAAiB,EACjB,EAAe,EAAe,EAAe,EAC7C,EAEA,EACA,WACoB,uBAA2B,GAE/C,EAA2B,oCgD9PP,OAAQ,uDH9BV,UAAJ,OACd,mBAAoB,OAAU,qBADQ,KAAF,mH5BqBlC,sBACQ,qBAAsB,0DAA4B,oBAAlD,uBAEL,qBAAsB,0DAAkC,oBAAxD,WACA,qBAAsB,0DAAkC,oBAAxD,QAGP,OAA2B,qBAAU,mBAAa,qCAElD,OAAgB,qBAA8B,oCACpC,oBACE,sEAGM,+EAIN,kDAIZ,OAAY,qBAA0B,0CAA2B,gDAEjE,iCAAe,kBAAc,kBAAgB,oBAAY,QAAI,wH8BiW3C,aAGJ,aAGU,aAGK,aAGG,aAGK,aAGF,cAGN,yFAhCG,qH/C1TpB,0BACmD,EAA/B,GAAhB,UAEA,EAAI,EAAJ,KAEA,qBAAa,YAEM,iCAHpB,EAA4C,EAA/B,GAAb,CAIF,EAAM,EAAjB,KACiB,KAAN,WAEM,KAAN,YACM,KAAN,YACM,KAAN,YACH,KAAR,wBAEoB,KAAN,iBAGO,KAAN,eAGM,KAAN,YACM,KAAN,YACK,KAAN,eAGW,iBAxBA,KAAF,QA2BzB,OAAgC,YAAW,EAAY,oCgDrF5B,OAAQ,uFDuarB,aAGU,aAGA,aAGF,aAGH,aAMF,sGA7BS,uH/CvTd,0BAC4C,EAAxB,GAAhB,UAEA,EAAI,EAAJ,KAEA,qBAAa,YAEV,KAHJ,EAAqC,EAAxB,GAAb,CAGF,YACP,YACS,EAAM,EAAjB,KAEsB,iBAAN,YACC,KAAN,YACM,KAAN,aACF,YACE,EAAM,EAAjB,KAEuB,iBAAN,aACR,YACE,EAAM,EAAjB,KAEuB,iBAAN,WAEG,mBApBG,KAAF,QAuBzB,OAA0B,cAAW,8EAAgB,EAAY,oCgD3H5C,OAAQ,yK5BmDzB,sBACQ,qBAAsB,0DAA4B,oBAAlD,uBAEL,qBAAsB,4DAAkC,oBAAxD,WACA,qBAAsB,4DAAkC,oBAAxD,QAGP,OAAgC,qBAAU,mBAAa,aAAS,sBAChE,OAA6B,qBAAU,mBAAa,qCACpD,OAAgC,qBAAU,mBAAa,qCACvD,OAA0B,qBAAU,mBAAa,aAAO,wBACxD,OAA4B,qBAAU,mBAAa,uBAAkB,4BAE7C,qBAA+B,uGACpB,yCADX,OAIxB,OAAiB,qBAAyB,oCAChC,gEACY,2EAGtB,OAAgB,qBAA8B,oCACpC,oBACE,sEAEM,mDACA,2BAA8E,qCAC9E,2BAA2C,4EAE9C,4CAEH,kDAIZ,OAAY,qBAA0B,2CAA2B,gDAEjE,mCACE,kBAAiB,kBAAmB,kBAAgB,kBAAmB,kBAAa,kBAAgB,oBACpG,QAAI,QAAI,wG2B/HK,0BAGK,aAGF,aAGU,cAGN,eAGF,kCpBgCG,SAAnB,KAAqD,gBACrC,EAA2B,EAAgB,EAAhB,CAA3B,CAMb,wCqBzCL,iCACU,4BAAc,4BAAc,wEAAtC,EAAc,EAAc,EAC5B,EACA,EACA,EACA,IACA,6EhDYF,OAAU,oF+CsDgB,eAGA,eAGA,eAGJ,eAGA,eAGG,eAGN,iBAGA,gBAGM,cAGL,4G/ChElB,cACA,yIAAmB,EAAmB,EACtC,EAAgB,EAAgB,EAChC,EAAkB,EAClB,IACA,qCgD7BiB,OAAQ,kGDGZ,aAGH,wFA2WQ,+UT9TL,WAAmB,4DAAsC,2BACzD,WAAmB,4DAAsC,2BACzD,WAAmB,4DAAsC,2BACzD,WAAmB,4DAAsC,2BAErD,WAA4B,uGACZ,gDAKjC,OAA+B,qBAAU,mBAAa,qCACtD,OAAgC,qBAAU,mBAAa,aAAa,sBACpE,OAAmC,qBAAU,mBAAa,uBAAe,wBAEzE,OAAqB,OAAsB,oCACjC,gEACY,2EAGtB,OAAoB,OAA2B,oCACrC,oBACE,sEAEM,2FAEH,4CAEG,cACF,4CAGF,iDAMW,WAA4B,mFAExC,qCAAwB,gCAAkC,aAAU,wBAAc,gCAClF,qCAAwB,gCAAkC,aAAU,wBAAc,gCAClF,qCAAwB,gCAAkC,aAAU,wBAAc,iDAI/F,OAAmC,qBAAU,mBAAa,qCAC1D,OAAgB,OAAoB,4CAAqB,0BAAuB,mCAChF,OAAa,OAAoB,4CAAqB,0BAAuB,mCAC7E,OAAmB,OAAoB,4CAAqB,0BAAuB,mCACnF,OAA2B,OAAoB,qCAClC,eACA,qCAGb,OAA6B,OAAsB,qCACzC,mEAEK,aAAY,mDAA4B,aAAY,mDACpD,aAAY,mDAAyB,aAAY,mDACjD,aAAY,mDAA+B,aAAY,2EAItE,OAAoB,OAA2B,qCACrC,oBACE,kDACG,+EAEG,oFAOlB,OAAgB,OAAoB,qCAC1B,sBACF,0BACC,aACP,mCAGF,OAAqB,OAAuB,qGAErB,qDAAyB,+DACzB,qDAAsB,+DACtB,qDAA4B,iEAExB,6CACb,sCAIhB,OAAY,OAAuB,2CACrB,0BACA,sCAGd,mCACE,kBAAY,kBACZ,kBAAoB,kBAAkB,kBAAmB,kBAAsB,kBAC/E,kBAAoB,kBAAsB,kBAC1C,kBAAgB,kBAAa,kBAAmB,kBAAgB,oBAChE,QAAQ,QAAQ,QAAQ,QAAQ,QAAY,kDY3MZ,uBCIJ,4BACK,SAAS,yLJ4E3B,8GAfF,oBAGE,oDC+Bf,6DACuB,4BAAe,wHACG,4BAAe,4BAAe,SACvE,OAAK,gBAFL,EAAY,EAAe,EAC3B,EAAgB,EAAc,EAAe,EAAe,EAC5D,IAAc,EAAL,qLANsG,+FAAgC,UAA5D,yfTyE1E,WAAmB,4DAAkC,2BACjD,WAAmB,4DAAsC,2BAC1D,WAAmB,4DAAqC,2BAGtE,OAA8B,qBAAU,yBAAgC,gCAKpE,uBACJ,OAA8B,qBAAU,yBAAgC,gCAIpE,uBACJ,OAA+B,qBAAU,mBAAa,qCACtD,OAAgC,qBAAU,mBAAa,aAAa,sBACpE,OAAmC,qBAAU,mBAAa,uBAAe,wBACzE,OAAkC,qBAAU,mBAAa,uBAAc,wBAGjD,WAA4B,+EAEnC,qCAAuB,+BACvB,aAAU,wBAAa,gDAGpB,WAA4B,+EAE/B,qCAA4B,+BAC5B,qCAAuB,gDAGnB,WAA4B,wGACZ,iDAInC,OAAe,OAAoB,4CAAqB,8CACpD,EAAJ,IACE,SAAiC,qCAAoB,sCAAuB,gDAK9E,OAAe,OAAoB,qCACtB,eACA,eACG,eACC,mCAGjB,OAAwB,OAAsB,qCACpC,oEACa,cAAY,sDAA2B,cAAY,6EAE1E,OAAoB,OAAsB,qCAChC,oEACa,cAAW,sDAA6B,cAAW,6EAE1E,OAAyB,OAAsB,qCACrC,oEACY,mGAIZ,oBACE,yEAEM,4FAEH,QAAe,QAAW,4CAEzB,aACE,6CAGJ,oBAZqC,QAenD,OAAoB,OAA2B,mBAAa,6BAI1D,OAAc,OAAoB,qCACrB,sBACL,8CAEY,IAAR,IAAR,IAAJ,uCACsB,QAAM,QAAM,QAAM,QAAM,QAAM,MAA/B,QACH,EAAI,EAAJ,KACd,SAAiC,qCAAoB,OAAW,+CAAiB,mEAA6B,uCADvF,KAAF,SAOzB,OAAuB,OAAsB,qCACnC,oEACa,cAAY,sDAA0B,cAAY,6EAEzE,OAAwB,OAAsB,qCACpC,oEACY,6EAGtB,OAAmB,OAA2B,qCACpC,oBACE,oBACD,+DACI,QAAe,0BACd,oDAEF,iDAKhB,OAAY,OAAuB,2CAA2B,0BAA0B,sCAExF,mCACE,kBAAkB,kBAAmB,kBAAiB,kBAAiB,kBAAsB,kBAC7F,kBAAoB,kBAAe,kBAAmB,kBAAc,kBACpE,kBAAoB,kBAAyB,kBAAwB,kBAAwB,kBAC7F,oBAAY,QAAI,QAAQ,QAAO,QAAe,QAAW,oTCvK5C,WAAmB,4DAAsC,2BACzD,WAAmB,4DAAsC,2BACzD,WAAmB,4DAAsC,2BACzD,WAAmB,4DAAsC,2BAErD,WAA4B,uGACZ,gDAKjC,OAA+B,qBAAU,mBAAa,qCACtD,OAAgC,qBAAU,mBAAa,aAAa,sBACpE,OAAmC,qBAAU,mBAAa,uBAAe,wBAEzE,OAAqB,OAAsB,oCACjC,gEACY,2EAGtB,OAAoB,OAA2B,oCACrC,oBACE,sEAEM,2FAEH,4CAEG,cACF,4CAGF,iDAMW,WAA4B,mFAExC,qCAAuB,gCACvB,aAAU,wBAAa,iDAIpC,OAAmC,qBAAU,mBAAa,qCAC1D,OAAqC,qBAAU,mBAAa,uBAAiB,wBAE7E,OAAoB,OAAoB,4CAAqB,0BAAuB,mCACpF,OAA2B,OAAoB,qCAClC,eACA,qCAGb,OAA6B,OAAsB,qCACzC,mEAEK,aAAY,mDACZ,aAAY,2EAI3B,OAAuB,OAAsB,qCACnC,mEACY,2EAGtB,OAAoB,OAA2B,qCACrC,oBACE,kDACG,QAAoB,+EAEjB,oFAOlB,OAAgB,OAAoB,qCAC1B,sBACF,0BACC,aACP,mCAGF,OAAqB,OAAuB,qGAEvB,qDACV,iEAEgB,6CACb,sCAIhB,OAAY,OAAuB,2CACrB,0BACA,sCAGd,mCACE,kBAAoB,kBAAkB,kBAAmB,kBAAsB,kBAC/E,kBAAoB,kBAAsB,kBAAoB,kBAA2B,kBACzF,kBAAY,kBAAqB,kBAAqB,kBAA6B,oBACnF,QAAQ,QAAQ,QAAQ,QAAQ,QAAoB,wRCtF3C,qBAAsB,oCAAqB,OAAiB,EAAW,8BAAa,oBAApF,WACI,qBAAsB,oCAAqB,OAAiB,EAAe,8BAAiB,oBAA5F,WACG,qBAAsB,oCAAqB,OAAiB,EAAgB,8BAAkB,oBAA9F,OAGlB,OAA+B,qBAAU,mBAAa,qCACtD,OAAgC,qBAAU,mBAAa,aAAS,sBAChE,OAA+B,qBAAU,mBAAa,uBAAW,wBAGjE,OAAe,qBAAuB,2CAC9B,0BACC,wDAGL,EAAJ,IACE,qBAAoC,oCAAoB,qCAAoB,gDAE9E,OAAe,qBAAuB,8DAEhB,qBAA+B,+EAEtC,qCAAuB,+BACvB,aAAU,wBAAa,yCAHhB,WAMH,qBAA+B,uGACf,aAAyC,yCADzD,OAInB,OAAwB,qBAAyB,oCACvC,kEACa,cAAY,sDAA2B,cAAY,6EAG1E,OAAqB,qBAAyB,qCACpC,oEACY,mCAA6B,+EAIzC,oBACE,yEAEM,4FAEH,QAAY,4CAEf,eACI,aACE,gCAEH,cACD,6CAGC,cACD,0DAIA,oBArBqC,QAwBnD,OAAoB,qBAA8B,mBAAa,6BAE/D,OAA2B,qBAA8B,qCAC/C,oBACE,oBACD,+DACI,6CAEH,gBACI,iCAED,gDAGA,6BAEO,0BAET,uDAGb,OAAY,qBAA0B,qCACxB,gBACE,sCAGhB,mCACE,kBAAkB,kBAAmB,kBAAkB,kBAAe,kBACtE,kBAAwB,kBAAqB,kBAAoB,kBACjE,oBAAY,QAAI,QAAQ,QAAW,QAAe,+CzC/F9B,6T2ChC2B,EAAjB,+DAcV,OAA0B,2FAEtB,aAAuC,aAAsB,+BAC1E,wBAAa,aAA8B,yCAHlC,WAMD,OAA0B,2FACV,yCADhB,OAIrB,mCAA2B,QAAe,mBAC1C,OAAgB,OAAyB,OAAQ,6BAEjD,OAAe,OAAkB,wBACpB,oBACL,0BACC,mCAET,OAAe,OAAkB,wBACpB,eACA,eACG,eACA,eACA,eACC,mCAEjB,OAAiC,OAAK,OAAQ,uBAAiB,wBAE/D,OAAwB,OAAoB,wBAClC,gEACa,aAAY,kDAA2B,aAAY,2EAE1E,OAAuB,OAAoB,wBACjC,mEACY,6EAGtB,YACA,sRAmDW,qBAAsB,oCAAqB,OAAiB,EAAW,8BAAa,oBAApF,WACI,qBAAsB,oCAAqB,OAAiB,EAAe,8BAAiB,oBAA5F,WACD,qBAAsB,oCAAqB,OAAiB,EAAc,8BAAgB,oBAA1F,OAGd,OAA+B,qBAAU,mBAAa,qCACtD,OAAgC,qBAAU,mBAAa,aAAa,2CAI1D,oBACE,sEAEM,+EAGN,eACI,aACE,4CAGJ,oBAZqC,OAenD,OACE,qBAAU,mBACV,OAAuC,mBAAkB,mBAAmB,aAA1D,8BAEhB,EAAJ,IACE,qBAAoC,oCAAoB,qCAAuB,iFAOvE,oBACE,oBACD,gCACK,iDAEF,oBANuC,OASrD,OACE,qBAAU,mBACV,OAA8C,mBAAkB,mBAAmB,aAA/D,+BAEF,IAAR,IAAR,IAAJ,sCACsB,QAAM,QAAM,QAAM,QAAM,QAAM,MAA/B,QACH,EAAI,EAAJ,KACd,qBAAoC,qCAAoB,OAAW,+CAAiB,+EAAqC,uCADlG,KAAF,SAOzB,OAAY,qBAA0B,2CAA2B,0BAAgC,sCAEjG,mCACE,kBAAkB,kBAAmB,oBAAY,QAAI,QAAQ,+CKnJ/C,UAAW,aAAO,IAAU,0CAQ1B,cAAW,4CAQnB,cAAiB,OAAN,IAAM,GAAW,gCAQjC,UAAW,EAAa,EAAe,EAAa,gCApBxC,iP/B5Ce,iDACL,qFEurCvB,OAAuC,MAAqC,4BAC7C,EAAgB,EAAhB,uC6BroC1B,cAAW,4CAQP,cAAiB,qBAAN,EAAM,EAAc,IAA4B,4EADiB,2EAQ7E,UAAW,EAAY,EAAe,EAAY,4D5BA9C,EAAI,GAAJ,KACd,2BAAa,UAAS,QAA6B,SAA7C,QAAmD,MAAK,UAAU,WAA9C,WAAd,KADa,aAG3B,OAAS,MAET,qBAAqB,mBAAa,mBAAa,kBAE5B,CAAT,EAAc,UAAd,CAAV,IACA,mBAAsB,0BAAsB,4BAAsB,mCAAjD,cACjB,qBAAqB,mBAAa,mBAAe,4BAEjD,qBAAyB,mBAAa,0BACtC,qBAA2B,mBAAa,0BACxC,qBAAkB,mBAAa,0BAC/B,qBAAmB,mBAAgB,mBAAH,SAChC,qBAAmB,mBAAgB,mBAAH,SAChC,qBAAmB,mBAAgB,mBAAH,SAChC,qBAAsB,mBAAgB,yBAAH,SACnC,qBAAqB,mBAAa,EAAG,UACrC,qBAA0B,oDcjKZ,EAAI,EAAJ,YACA,EAAe,KAAI,KAAb,EAAI,EAAJ,CAAD,GADK,KAAF,mCGyNhB,mBACM,EAAK,KAAI,EAAJ,YACL,EAAK,gBACL,EAAM,gBACN,EAAM,OAEP,UAAT,CAAJ,WAEgB,EAAe,EAAR,MADG,KAAK,KAAQ,EAAR,CAAL,CACa,EAAjB,YACN,EAAkB,EAAZ,MAAmB,EAAnB,aAEN,EAAM,gBACN,EAAM,qEAjBuC,UACjD,2DXhGe,OAAE,QAAK,SAAE,EAAF,cAAS,QAAK,WAAE,EAAF,EAAP,aACZ,QAAK,SAAE,EAAF,cAAS,QAAK,WAAE,EAAF,EAAP,MAC/B,OAAS,OAAE,QAAK,SAAE,EAAF,cAAS,QAAK,OAA1B,QAA4B,EAAF,EAAP,aACnB,EAAK,aACL,EAAK,4DWsJM,OAAQ,OAAK,2EZ7OlB,SAAJ,OACJ,OAAS,OAAE,QAAK,OAAZ,MAAc,EAAF,KADI,KAAF,sBAGvB,OY2OG,6BACoB,OAAI,yBACxB,6BACoB,OAAG,yBACvB,sBAEA,OAAS,OAAL,IAAO,QACX,OAAS,OAAL,IAAO,QACX,OAAU,OAAN,IAAQ,SACZ,OAAS,OAAL,IAAO,QACX,OAAS,OAAL,IAAO,QACX,OAAU,OAAN,IAAQ,SACZ,OAAS,OAAL,IAAO,QACX,OAAS,OAAL,IAAO,QACX,OAAW,OAAP,IAAS,SACb,OAAoB,OAAG,OAAnB,cACJ,OAAoB,OAAG,OAAnB,cACJ,OAAmB,OAAG,OAAlB,aACJ,OAAS,cAAS,gBAAU,mCAAxB,mBACA,EAAM,sFXvSY,KAAc,KAAc,KW+QrC,WACQ,KAAG,KAAG,KAAlB,WACP,gIrBrKK,UAAkB,EAAgB,EAAhB,0DS5CZ,gBACA,OAEvB,SAAW,EAAK,EAAL,MAEK,EAAI,EAAJ,GACD,EAAR,IAAW,EAAI,EAAJ,GACV,KAAJ,EACa,EAAR,IAAW,EAAI,EAAJ,YACG,EAAI,EAAJ,CAAS,EAAT,YAAjB,MAAiC,EAAI,EAAJ,CAAQ,EAAR,CAAF,MADR,KAAF,QAGb,SAAM,EAAJ,GAAS,EAAT,CAAc,KALF,KAAF,MADA,KAAF,QASnB,gBAAc,2FAEZ,8BSQW,OAAG,OAAG,0EADwC,mGG/Ef,wCACzC,mBACW,OAAL,IAAO,QACX,OAAS,OAAL,IAAO,QACX,OAAU,OAAN,IAAQ,2ClB4wCT,UAAkB,EAAgB,EAAhB,EAAiC,iHMzxC5C,EAAJ,cAEiB,OAAjB,EAAY,EAAZ,GAAqB,QAFR,KAAF,0EayMC,KAAI,KAAI,KAApB,UACc,eAAwB,yDACP,CAAT,YAAJ,SAAyC,CAAT,YAAN,SAAyC,CAAT,YAAJ,YAA2B,oEZ3KnD,uDACjD,OAAG,OAAG,yBDLD,SAAJ,OACJ,OAAS,OAAE,QAAK,OAAZ,MAAc,EAAF,KADI,KAAF,oCa+K2F,kBAAxG,OACO,OAAM,6BAEJ,qDD9M2B,4CAC7C,YACC,oGC4MO,WACK,aAAa,+BAAe,gBAArC,OAEC,OAAO,qBAAkB,EAAG,OAC5B,OAAI,qBAAkB,EAAI,aAC1B,cAAoB,qBAAkB,EAAI,OACnD,OAAkB,mBAAa,mBAAsB,4BAIvD,OAAsB,mBAAa,0BAEjC,OAAwB,mBAAa,0BACrC,OAAe,mBAAa,0BAC5B,OAAgB,mBAAgB,mBAAH,SAC7B,SAAmB,mBAAgB,yBAAH,SAChC,OAAkB,mBAAa,uBAEjC,OAAuB,wBAGvB,OAAsB,mBAAa,0BAEjC,OAAwB,mBAAa,0BACrC,OAAgB,mBAAgB,mBAAH,SAC7B,SAAmB,mBAAgB,yBAAH,SAChC,OAAW,mBAAa,OAE1B,OAAuB,mFC2DoB,CAAT,YAAL,GAAwC,CAAT,YAAJ,GAAwC,CAAT,YAAL,CAAjE,UACD,SACY,eAAwB,sCAC9B,aAAQ,wBAAf,OACO,OAAM,yBAEjB,OAAO,qBAAkB,EAAG,OAC5B,OAAI,qBAAkB,EAAI,OAC1B,OAAQ,qBAAkB,EAAI,OACvC,OAAkB,mBAAa,mBAAsB,kCAEtC,+BAAe,qBAAiB,EAAG,OACzC,OAAI,qBAAiB,EAAI,OACzB,OAAQ,qBAAiB,EAAI,OACtC,OAAkB,mBAAa,mBAAqB,4BAGtD,OAAsB,mBAAa,0BAGnC,OAAwB,mBAAa,0BACrC,OAAe,mBAAa,0BAC5B,OAAgB,mBAAgB,mBAAH,SAC7B,SAAmB,mBAAgB,yBAAH,SAChC,SAAmB,mBAAgB,yBAAH,SAChC,SAAmB,mBAAgB,yBAAH,SAChC,OAAkB,mBAAa,uBAG/B,OAAwB,mBAAa,0BACrC,OAAe,mBAAa,0BAC5B,OAAgB,mBAAgB,mBAAH,SAC7B,SAAmB,mBAAgB,yBAAH,SAChC,SAAmB,mBAAgB,yBAAH,SAChC,OAAkB,mBAAa,uBAE/B,OAAuB,mFClGK,eAAwB,yDACf,CAAT,YAAL,SAAwC,CAAT,YAAJ,SAAwC,CAAT,YAAL,kBAA4B,wBAAzF,OACQ,OAAM,yBAClB,OAAK,qBAAkB,EAAG,OACnC,OAAkB,mBAAa,mBAAsB,4BAKtC,SAAmC,WAAhB,EAAI,MlBqoBd,CAAnB,CkBroBkB,gBACG,KAA1B,MACoB,SAAJ,OACE,KAAhB,IAAuB,QADY,KAAF,QAK1B,OAAQ,qBAAoB,EAAG,OACxC,mBAAgB,EAAM,UACtB,mBAAgB,EAAM,UACtB,mBAAgB,EALmB,KAAI,EAAxB,EAAgB,KAAhB,CAKO,MACtB,OAAkB,mBAAa,mBAAwB,4BAIzD,OAAsB,mBAAa,0BAEjC,OAAwB,mBAAa,0BACrC,OAAe,mBAAa,0BAC5B,OAAgB,mBAAgB,mBAAH,SAC7B,SAAmB,mBAAgB,yBAAH,SAChC,OAAkB,mBAAa,uBAEjC,OAAuB,wBAGvB,OAAsB,mBAAa,0BAEjC,OAAwB,mBAAa,0BACrC,OAAgB,mBAAgB,mBAAH,SAC7B,SAAmB,mBAAgB,yBAAH,SAChC,SAAmB,mBAAgB,yBAAH,SAChC,OAAW,mBAAa,OAE1B,OAAuB,kDQnHT,UAAW,iEP+EG,eAAwB,yDACf,CAAT,YAAL,SAAwC,CAAT,YAAJ,SAAwC,CAAT,YAAL,kBAA4B,wBAAzF,OACO,OAAM,yBAEhB,OACD,OAAK,qBAAc,EAAG,WAEhB,aAAU,0CAAnB,OACG,OAAK,qBAAc,GAAgB,aACnC,cAA+B,qBAAc,GAAqB,OAE5D,iBAAU,iDAChB,OAAK,qBAAc,GAAoB,OAElD,qBAAqB,mBAAa,mBAAkB,4BAEpD,qBAAyB,mBAAa,0BAGtC,qBAA2B,mBAAa,0BACxC,qBAAkB,mBAAa,0BAC/B,qBAAmB,mBAAgB,mBAAH,SAChC,qBAAsB,mBAAgB,0BAAqB,aAAxB,WACnC,qBAAsB,mBAAgB,yBAAH,SACnC,qBAAuB,mBAAa,OACpC,qBAAqB,mBAAa,WAGlC,qBAAsB,mBAAgB,0BAAqB,aAAxB,WACnC,qBAAuB,mBAAa,OACpC,qBAAqB,mBAAa,EAAY,EAAG,OAGjD,qBAA2B,mBAAa,0BACxC,qBAAkB,mBAAa,0BAC/B,qBAAmB,mBAAgB,mBAAH,SAChC,qBAAsB,mBAAgB,0BAAqB,aAAxB,WACnC,qBAAuB,mBAAa,OACpC,qBAAqB,mBAAa,WAElC,qBAA0B,mEEtHjB,OAAK,qBAAoB,EAAG,OACrC,iBAAqB,mBAAa,qBAAmB,gEAIrD,iBAA2B,OAAQ,0BACnC,iBAAkB,OAAQ,0BAC1B,iBAAmB,OAAW,mBAAH,SAC3B,mBAAsB,OAAW,2BAAH,SAC9B,mBAAsB,OAAW,2BAAH,SAC9B,iBAAqB,OAAQ,YKxB4C,EAAsB,kEL8HrE,eAAwB,0CpCrQU,eoCsQzB,CAAT,YAAL,SAAwC,CAAT,YAAJ,SAAwC,CAAT,YAAL,kBAA4B,wBAAzF,OACO,OAAM,yBAEhB,OACV,mBAAwB,kBAET,aAAU,+BAAe,gBAAlC,OACN,mBAA0B,cAE1B,qBAAyB,mBAAa,0BACtC,mBAAkB,0BAClB,mBAAoB,0BACpB,qBAA0B,8DEvQN,sBAAJ,OACd,mBAAe,kBAD4B,KAAF,QAG3C,mBAAwB,iC7CmPH,wCA1FL,wCAhIF,wCAuBA,wCAvCD,2C2C4Ib,wBACA,0BACA,0BACA,wBACA,wBACA,qGpC/Je,EAAiB,EAAjB,CAEgC,EAAY,EAAqB,EAArE,OAEK,EAAmB,EAAzB,EACC,EAAO,EAApB,GACO,EAAO,EAA2B,EAAzC,EACa,EAAO,EAApB,GACW,EAAO,EAAlB,GACW,EAAO,EAAlB,UACO,0CmB5BC,QAAG,QAAG,qDELN,WAAG,WAAG,WAAG,mCVuCX,EAAc,MAAd,CAAJ,EAA2D,gBAChB,EAAe,EAA7C,cAIN","sourceRoot":"./examples","sourcesContent":["// Alignment guarantees\n\n// @ts-ignore: decorator\n@inline export const AL_BITS: u32 = 4; // 16 bytes to fit up to v128\n// @ts-ignore: decorator\n@inline export const AL_SIZE: usize = 1 << <usize>AL_BITS;\n// @ts-ignore: decorator\n@inline export const AL_MASK: usize = AL_SIZE - 1;\n\n// Extra debugging\n\n// @ts-ignore: decorator\n@inline export const DEBUG = true;\n// @ts-ignore: decorator\n@inline export const TRACE = false;\n// @ts-ignore: decorator\n@inline export const RTRACE = isDefined(ASC_RTRACE);\n// @ts-ignore: decorator\n@inline export const PROFILE = isDefined(ASC_PROFILE);\n\n// Memory manager\n\n// ╒════════════ Memory manager block layout (32-bit) ═════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤\n// │                           MM info                             │ -4\n// ╞>ptr═══════════════════════════════════════════════════════════╡\n// │                              ...                              │\n@unmanaged export class BLOCK {\n  /** Memory manager info. */\n  mmInfo: usize;\n}\n\n/** Overhead of a memory manager block. */\n// @ts-ignore: decorator\n@inline export const BLOCK_OVERHEAD: usize = offsetof<BLOCK>();\n\n/** Maximum size of a memory manager block's payload. */\n// @ts-ignore: decorator\n@inline export const BLOCK_MAXSIZE: usize = (1 << 30) - BLOCK_OVERHEAD;\n\n// Garbage collector\n\n// ╒══════════ Garbage collector object layout (32-bit) ═══════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤\n// │                     Memory manager block                      │ -20\n// ╞═══════════════════════════════════════════════════════════════╡\n// │                            GC info                            │ -16\n// ├───────────────────────────────────────────────────────────────┤\n// │                            GC info                            │ -12\n// ├───────────────────────────────────────────────────────────────┤\n// │                            RT id                              │ -8\n// ├───────────────────────────────────────────────────────────────┤\n// │                            RT size                            │ -4\n// ╞>ptr═══════════════════════════════════════════════════════════╡\n// │                              ...                              │\n@unmanaged export class OBJECT extends BLOCK {\n  /** Garbage collector info. */\n  gcInfo: u32;\n  /** Garbage collector info. */\n  gcInfo2: u32;\n  /** Runtime class id. */\n  rtId: u32;\n  /** Runtime object size. */\n  rtSize: u32;\n}\n\n/** Overhead of a garbage collector object. Excludes memory manager block overhead. */\n// @ts-ignore: decorator\n@inline export const OBJECT_OVERHEAD: usize = (offsetof<OBJECT>() - BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK;\n\n/** Maximum size of a garbage collector object's payload. */\n// @ts-ignore: decorator\n@inline export const OBJECT_MAXSIZE: usize = BLOCK_MAXSIZE - OBJECT_OVERHEAD;\n\n/** Total of memory manager and garbage collector overhead. */\n// @ts-ignore: decorator\n@inline export const TOTAL_OVERHEAD: usize = BLOCK_OVERHEAD + OBJECT_OVERHEAD;\n","import { AL_BITS, AL_SIZE, AL_MASK, DEBUG, BLOCK, BLOCK_OVERHEAD, BLOCK_MAXSIZE } from \"./common\";\nimport { oninit, onalloc, onresize, onmove, onfree } from \"./rtrace\";\nimport { E_ALLOCATION_TOO_LARGE } from \"../util/error\";\n\n// === The TLSF (Two-Level Segregate Fit) memory allocator ===\n// see: http://www.gii.upv.es/tlsf/\n\n// - `ffs(x)` is equivalent to `ctz(x)` with x != 0\n// - `fls(x)` is equivalent to `sizeof(x) * 8 - clz(x) - 1`\n\n// ╒══════════════ Block size interpretation (32-bit) ═════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┼─┴─┴─┴─╫─┴─┴─┴─┤\n// │ |                    FL                       │ SB = SL + AL  │ ◄─ usize\n// └───────────────────────────────────────────────┴───────╨───────┘\n// FL: first level, SL: second level, AL: alignment, SB: small block\n\n// @ts-ignore: decorator\n@inline const SL_BITS: u32 = 4;\n// @ts-ignore: decorator\n@inline const SL_SIZE: u32 = 1 << SL_BITS;\n\n// @ts-ignore: decorator\n@inline const SB_BITS: u32 = SL_BITS + AL_BITS;\n// @ts-ignore: decorator\n@inline const SB_SIZE: u32 = 1 << SB_BITS;\n\n// @ts-ignore: decorator\n@inline const FL_BITS: u32 = 31 - SB_BITS;\n\n// [00]: < 256B (SB)  [12]: < 1M\n// [01]: < 512B       [13]: < 2M\n// [02]: < 1K         [14]: < 4M\n// [03]: < 2K         [15]: < 8M\n// [04]: < 4K         [16]: < 16M\n// [05]: < 8K         [17]: < 32M\n// [06]: < 16K        [18]: < 64M\n// [07]: < 32K        [19]: < 128M\n// [08]: < 64K        [20]: < 256M\n// [09]: < 128K       [21]: < 512M\n// [10]: < 256K       [22]: <= 1G - OVERHEAD\n// [11]: < 512K\n// VMs limit to 2GB total (currently), making one 1G block max (or three 512M etc.) due to block overhead\n\n// Tags stored in otherwise unused alignment bits\n\n// @ts-ignore: decorator\n@inline const FREE: usize = 1 << 0;\n// @ts-ignore: decorator\n@inline const LEFTFREE: usize = 1 << 1;\n// @ts-ignore: decorator\n@inline const TAGS_MASK: usize = FREE | LEFTFREE; // <= AL_MASK\n\n// ╒════════════════════ Block layout (32-bit) ════════════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┼─┼─┤            ┐\n// │                          size                             │L│F│ ◄─┐ info   overhead\n// ╞>ptr═══════════════════════════════════════════════════════╧═╧═╡   │        ┘\n// │                        if free: ◄ prev                        │ ◄─┤ usize\n// ├───────────────────────────────────────────────────────────────┤   │\n// │                        if free: next ►                        │ ◄─┤\n// ├───────────────────────────────────────────────────────────────┤   │\n// │                             ...                               │   │ >= 0\n// ├───────────────────────────────────────────────────────────────┤   │\n// │                        if free: back ▲                        │ ◄─┘\n// └───────────────────────────────────────────────────────────────┘ >= MIN SIZE\n// F: FREE, L: LEFTFREE\n@unmanaged export class Block extends BLOCK {\n\n  /** Previous free block, if any. Only valid if free, otherwise part of payload. */\n  prev: Block | null;\n  /** Next free block, if any. Only valid if free, otherwise part of payload. */\n  next: Block | null;\n\n  // If the block is free, there is a 'back'reference at its end pointing at its start.\n}\n\n// Block constants. A block must have a minimum size of three pointers so it can hold `prev`,\n// `next` and `back` if free.\n\n// @ts-ignore: decorator\n@inline const BLOCK_MINSIZE: usize = ((3 * sizeof<usize>() + BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK) - BLOCK_OVERHEAD; // prev + next + back\n// @ts-ignore: decorator\n// @inline const BLOCK_MAXSIZE: usize = 1 << (FL_BITS + SB_BITS - 1); // exclusive, lives in common.ts\n\n/** Gets the left block of a block. Only valid if the left block is free. */\n// @ts-ignore: decorator\n@inline function GETFREELEFT(block: Block): Block {\n  return load<Block>(changetype<usize>(block) - sizeof<usize>());\n}\n\n/** Gets the right block of a block by advancing to the right by its size. */\n// @ts-ignore: decorator\n@inline function GETRIGHT(block: Block): Block {\n  return changetype<Block>(changetype<usize>(block) + BLOCK_OVERHEAD + (block.mmInfo & ~TAGS_MASK));\n}\n\n// ╒═════════════════════ Root layout (32-bit) ════════════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤          ┐\n// │        0        |           flMap                            S│ ◄────┐\n// ╞═══════════════════════════════════════════════════════════════╡      │\n// │                           slMap[0] S                          │ ◄─┐  │\n// ├───────────────────────────────────────────────────────────────┤   │  │\n// │                           slMap[1]                            │ ◄─┤  │\n// ├───────────────────────────────────────────────────────────────┤  u32 │\n// │                           slMap[22]                           │ ◄─┘  │\n// ╞═══════════════════════════════════════════════════════════════╡    usize\n// │                            head[0]                            │ ◄────┤\n// ├───────────────────────────────────────────────────────────────┤      │\n// │                              ...                              │ ◄────┤\n// ├───────────────────────────────────────────────────────────────┤      │\n// │                           head[367]                           │ ◄────┤\n// ╞═══════════════════════════════════════════════════════════════╡      │\n// │                             tail                              │ ◄────┘\n// └───────────────────────────────────────────────────────────────┘   SIZE   ┘\n// S: Small blocks map\n@unmanaged class Root {\n  /** First level bitmap. */\n  flMap: usize;\n}\n\n// Root constants. Where stuff is stored inside of the root structure.\n\n// @ts-ignore: decorator\n@inline const SL_START: usize = sizeof<usize>();\n// @ts-ignore: decorator\n@inline const SL_END: usize = SL_START + (FL_BITS << alignof<u32>());\n// @ts-ignore: decorator\n@inline const HL_START: usize = (SL_END + AL_MASK) & ~AL_MASK;\n// @ts-ignore: decorator\n@inline const HL_END: usize = HL_START + FL_BITS * SL_SIZE * sizeof<usize>();\n// @ts-ignore: decorator\n@inline const ROOT_SIZE: usize = HL_END + sizeof<usize>();\n\n// @ts-ignore: decorator\n@lazy export let ROOT: Root = changetype<Root>(0); // unsafe initializion below\n\n/** Gets the second level map of the specified first level. */\n// @ts-ignore: decorator\n@inline function GETSL(root: Root, fl: usize): u32 {\n  return load<u32>(\n    changetype<usize>(root) + (fl << alignof<u32>()),\n    SL_START\n  );\n}\n\n/** Sets the second level map of the specified first level. */\n// @ts-ignore: decorator\n@inline function SETSL(root: Root, fl: usize, slMap: u32): void {\n  store<u32>(\n    changetype<usize>(root) + (fl << alignof<u32>()),\n    slMap,\n    SL_START\n  );\n}\n\n/** Gets the head of the free list for the specified combination of first and second level. */\n// @ts-ignore: decorator\n@inline function GETHEAD(root: Root, fl: usize, sl: u32): Block | null {\n  return load<Block>(\n    changetype<usize>(root) + (((fl << SL_BITS) + <usize>sl) << alignof<usize>()),\n    HL_START\n  );\n}\n\n/** Sets the head of the free list for the specified combination of first and second level. */\n// @ts-ignore: decorator\n@inline function SETHEAD(root: Root, fl: usize, sl: u32, head: Block | null): void {\n  store<Block | null>(\n    changetype<usize>(root) + (((fl << SL_BITS) + <usize>sl) << alignof<usize>()),\n    head,\n    HL_START\n  );\n}\n\n/** Gets the tail block.. */\n// @ts-ignore: decorator\n@inline function GETTAIL(root: Root): Block {\n  return load<Block>(\n    changetype<usize>(root),\n    HL_END\n  );\n}\n\n/** Sets the tail block. */\n// @ts-ignore: decorator\n@inline function SETTAIL(root: Root, tail: Block): void {\n  store<Block>(\n    changetype<usize>(root),\n    tail,\n    HL_END\n  );\n}\n\n/** Inserts a previously used block back into the free list. */\nfunction insertBlock(root: Root, block: Block): void {\n  if (DEBUG) assert(block); // cannot be null\n  let blockInfo = block.mmInfo;\n  if (DEBUG) assert(blockInfo & FREE); // must be free\n\n  let right = GETRIGHT(block);\n  let rightInfo = right.mmInfo;\n\n  // merge with right block if also free\n  if (rightInfo & FREE) {\n    removeBlock(root, right);\n    block.mmInfo = blockInfo = blockInfo + BLOCK_OVERHEAD + (rightInfo & ~TAGS_MASK); // keep block tags\n    right = GETRIGHT(block);\n    rightInfo = right.mmInfo;\n    // 'back' is set below\n  }\n\n  // merge with left block if also free\n  if (blockInfo & LEFTFREE) {\n    let left = GETFREELEFT(block);\n    let leftInfo = left.mmInfo;\n    if (DEBUG) assert(leftInfo & FREE); // must be free according to right tags\n    removeBlock(root, left);\n    block = left;\n    block.mmInfo = blockInfo = leftInfo + BLOCK_OVERHEAD + (blockInfo & ~TAGS_MASK); // keep left tags\n    // 'back' is set below\n  }\n\n  right.mmInfo = rightInfo | LEFTFREE;\n  // reference to right is no longer used now, hence rightInfo is not synced\n\n  // we now know the size of the block\n  let size = blockInfo & ~TAGS_MASK;\n  if (DEBUG) assert(size >= BLOCK_MINSIZE); // must be a valid size\n  if (DEBUG) assert(changetype<usize>(block) + BLOCK_OVERHEAD + size == changetype<usize>(right)); // must match\n\n  // set 'back' to itself at the end of block\n  store<Block>(changetype<usize>(right) - sizeof<usize>(), block);\n\n  // mapping_insert\n  let fl: usize, sl: u32;\n  if (size < SB_SIZE) {\n    fl = 0;\n    sl = <u32>(size >> AL_BITS);\n  } else {\n    const inv: usize = sizeof<usize>() * 8 - 1;\n    let boundedSize = min(size, BLOCK_MAXSIZE);\n    fl = inv - clz<usize>(boundedSize);\n    sl = <u32>((boundedSize >> (fl - SL_BITS)) ^ (1 << SL_BITS));\n    fl -= SB_BITS - 1;\n  }\n  if (DEBUG) assert(fl < FL_BITS && sl < SL_SIZE); // fl/sl out of range\n\n  // perform insertion\n  let head = GETHEAD(root, fl, sl);\n  block.prev = null;\n  block.next = head;\n  if (head) head.prev = block;\n  SETHEAD(root, fl, sl, block);\n\n  // update first and second level maps\n  root.flMap |= (1 << fl);\n  SETSL(root, fl, GETSL(root, fl) | (1 << sl));\n}\n\n/** Removes a free block from internal lists. */\nfunction removeBlock(root: Root, block: Block): void {\n  let blockInfo = block.mmInfo;\n  if (DEBUG) assert(blockInfo & FREE); // must be free\n  let size = blockInfo & ~TAGS_MASK;\n  if (DEBUG) assert(size >= BLOCK_MINSIZE); // must be valid\n\n  // mapping_insert\n  let fl: usize, sl: u32;\n  if (size < SB_SIZE) {\n    fl = 0;\n    sl = <u32>(size >> AL_BITS);\n  } else {\n    const inv: usize = sizeof<usize>() * 8 - 1;\n    let boundedSize = min(size, BLOCK_MAXSIZE);\n    fl = inv - clz<usize>(boundedSize);\n    sl = <u32>((boundedSize >> (fl - SL_BITS)) ^ (1 << SL_BITS));\n    fl -= SB_BITS - 1;\n  }\n  if (DEBUG) assert(fl < FL_BITS && sl < SL_SIZE); // fl/sl out of range\n\n  // link previous and next free block\n  let prev = block.prev;\n  let next = block.next;\n  if (prev) prev.next = next;\n  if (next) next.prev = prev;\n\n  // update head if we are removing it\n  if (block == GETHEAD(root, fl, sl)) {\n    SETHEAD(root, fl, sl, next);\n\n    // clear second level map if head is empty now\n    if (!next) {\n      let slMap = GETSL(root, fl);\n      SETSL(root, fl, slMap &= ~(1 << sl));\n\n      // clear first level map if second level is empty now\n      if (!slMap) root.flMap &= ~(1 << fl);\n    }\n  }\n  // note: does not alter left/back because it is likely that splitting\n  // is performed afterwards, invalidating those changes. so, the caller\n  // must perform those updates.\n}\n\n/** Searches for a free block of at least the specified size. */\nfunction searchBlock(root: Root, size: usize): Block | null {\n  // size was already asserted by caller\n\n  // mapping_search\n  let fl: usize, sl: u32;\n  if (size < SB_SIZE) {\n    fl = 0;\n    sl = <u32>(size >> AL_BITS);\n  } else {\n    const halfMaxSize = BLOCK_MAXSIZE >> 1; // don't round last fl\n    const inv: usize = sizeof<usize>() * 8 - 1;\n    const invRound = inv - SL_BITS;\n    let requestSize = size < halfMaxSize\n      ? size + (1 << (invRound - clz<usize>(size))) - 1\n      : size;\n    fl = inv - clz<usize>(requestSize);\n    sl = <u32>((requestSize >> (fl - SL_BITS)) ^ (1 << SL_BITS));\n    fl -= SB_BITS - 1;\n  }\n  if (DEBUG) assert(fl < FL_BITS && sl < SL_SIZE); // fl/sl out of range\n\n  // search second level\n  let slMap = GETSL(root, fl) & (~0 << sl);\n  let head: Block | null = null;\n  if (!slMap) {\n    // search next larger first level\n    let flMap = root.flMap & (~0 << (fl + 1));\n    if (!flMap) {\n      head = null;\n    } else {\n      fl = ctz<usize>(flMap);\n      slMap = GETSL(root, fl);\n      if (DEBUG) assert(slMap);  // can't be zero if fl points here\n      head = GETHEAD(root, fl, ctz<u32>(slMap));\n    }\n  } else {\n    head = GETHEAD(root, fl, ctz<u32>(slMap));\n  }\n  return head;\n}\n\n/** Prepares the specified block before (re-)use, possibly splitting it. */\nfunction prepareBlock(root: Root, block: Block, size: usize): void {\n  // size was already asserted by caller\n\n  let blockInfo = block.mmInfo;\n  if (DEBUG) assert(!((size + BLOCK_OVERHEAD) & AL_MASK)); // size must be aligned so the new block is\n\n  // split if the block can hold another MINSIZE block incl. overhead\n  let remaining = (blockInfo & ~TAGS_MASK) - size;\n  if (remaining >= BLOCK_OVERHEAD + BLOCK_MINSIZE) {\n    block.mmInfo = size | (blockInfo & LEFTFREE); // also discards FREE\n\n    let spare = changetype<Block>(changetype<usize>(block) + BLOCK_OVERHEAD + size);\n    spare.mmInfo = (remaining - BLOCK_OVERHEAD) | FREE; // not LEFTFREE\n    insertBlock(root, spare); // also sets 'back'\n\n  // otherwise tag block as no longer FREE and right as no longer LEFTFREE\n  } else {\n    block.mmInfo = blockInfo & ~FREE;\n    GETRIGHT(block).mmInfo &= ~LEFTFREE;\n  }\n}\n\n/** Adds more memory to the pool. */\nfunction addMemory(root: Root, start: usize, endU64: u64): bool {\n  let end = <usize>endU64;\n  if (DEBUG) assert(<u64>start <= endU64); // must be valid\n  start = ((start + BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK) - BLOCK_OVERHEAD;\n  end &= ~AL_MASK;\n\n  let tail = GETTAIL(root);\n  let tailInfo: usize = 0;\n  if (tail) { // more memory\n    if (DEBUG) assert(start >= changetype<usize>(tail) + BLOCK_OVERHEAD);\n\n    // merge with current tail if adjacent\n    const offsetToTail = AL_SIZE;\n    if (start - offsetToTail == changetype<usize>(tail)) {\n      start -= offsetToTail;\n      tailInfo = tail.mmInfo;\n    } else {\n      // We don't do this, but a user might `memory.grow` manually\n      // leading to non-adjacent pages managed by TLSF.\n    }\n\n  } else if (DEBUG) { // first memory\n    assert(start >= changetype<usize>(root) + ROOT_SIZE); // starts after root\n  }\n\n  // check if size is large enough for a free block and the tail block\n  let size = end - start;\n  if (size < BLOCK_OVERHEAD + BLOCK_MINSIZE + BLOCK_OVERHEAD) {\n    return false;\n  }\n\n  // left size is total minus its own and the zero-length tail's header\n  let leftSize = size - 2 * BLOCK_OVERHEAD;\n  let left = changetype<Block>(start);\n  left.mmInfo = leftSize | FREE | (tailInfo & LEFTFREE);\n  left.prev = null;\n  left.next = null;\n\n  // tail is a zero-length used block\n  tail = changetype<Block>(start + BLOCK_OVERHEAD + leftSize);\n  tail.mmInfo = 0 | LEFTFREE;\n  SETTAIL(root, tail);\n\n  insertBlock(root, left); // also merges with free left before tail / sets 'back'\n\n  return true;\n}\n\n/** Grows memory to fit at least another block of the specified size. */\nfunction growMemory(root: Root, size: usize): void {\n  if (ASC_LOW_MEMORY_LIMIT) {\n    unreachable();\n    return;\n  }\n  // Here, both rounding performed in searchBlock ...\n  const halfMaxSize = BLOCK_MAXSIZE >> 1;\n  if (size < halfMaxSize) { // don't round last fl\n    const invRound = (sizeof<usize>() * 8 - 1) - SL_BITS;\n    size += (1 << (invRound - clz<usize>(size))) - 1;\n  }\n  // and additional BLOCK_OVERHEAD must be taken into account. If we are going\n  // to merge with the tail block, that's one time, otherwise it's two times.\n  let pagesBefore = memory.size();\n  size += BLOCK_OVERHEAD << usize((<usize>pagesBefore << 16) - BLOCK_OVERHEAD != changetype<usize>(GETTAIL(root)));\n  let pagesNeeded = <i32>(((size + 0xffff) & ~0xffff) >>> 16);\n  let pagesWanted = max(pagesBefore, pagesNeeded); // double memory\n  if (memory.grow(pagesWanted) < 0) {\n    if (memory.grow(pagesNeeded) < 0) unreachable();\n  }\n  let pagesAfter = memory.size();\n  addMemory(root, <usize>pagesBefore << 16, <u64>pagesAfter << 16);\n}\n\n/** Computes the size (excl. header) of a block. */\nfunction computeSize(size: usize): usize {\n  // Size must be large enough and aligned minus preceeding overhead\n  return size <= BLOCK_MINSIZE\n    ? BLOCK_MINSIZE\n    : ((size + BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK) - BLOCK_OVERHEAD;\n}\n\n/** Prepares and checks an allocation size. */\nfunction prepareSize(size: usize): usize {\n  if (size > BLOCK_MAXSIZE) throw new Error(E_ALLOCATION_TOO_LARGE);\n  return computeSize(size);\n}\n\n/** Initializes the root structure. */\nfunction initialize(): void {\n  if (isDefined(ASC_RTRACE)) oninit(__heap_base);\n  let rootOffset = (__heap_base + AL_MASK) & ~AL_MASK;\n  let pagesBefore = memory.size();\n  let pagesNeeded = <i32>((((rootOffset + ROOT_SIZE) + 0xffff) & ~0xffff) >>> 16);\n  if (pagesNeeded > pagesBefore && memory.grow(pagesNeeded - pagesBefore) < 0) unreachable();\n  let root = changetype<Root>(rootOffset);\n  root.flMap = 0;\n  SETTAIL(root, changetype<Block>(0));\n  for (let fl: usize = 0; fl < FL_BITS; ++fl) {\n    SETSL(root, fl, 0);\n    for (let sl: u32 = 0; sl < SL_SIZE; ++sl) {\n      SETHEAD(root, fl, sl, null);\n    }\n  }\n  let memStart = rootOffset + ROOT_SIZE;\n  if (ASC_LOW_MEMORY_LIMIT) {\n    const memEnd = <u64>ASC_LOW_MEMORY_LIMIT & ~AL_MASK;\n    if (memStart <= memEnd) addMemory(root, memStart, memEnd);\n    else unreachable(); // low memory limit already exceeded\n  } else {\n    addMemory(root, memStart, <u64>memory.size() << 16);\n  }\n  ROOT = root;\n}\n\n/** Allocates a block of the specified size. */\nexport function allocateBlock(root: Root, size: usize): Block {\n  let payloadSize = prepareSize(size);\n  let block = searchBlock(root, payloadSize);\n  if (!block) {\n    growMemory(root, payloadSize);\n    block = changetype<Block>(searchBlock(root, payloadSize));\n    if (DEBUG) assert(block); // must be found now\n  }\n  if (DEBUG) assert((block.mmInfo & ~TAGS_MASK) >= payloadSize); // must fit\n  removeBlock(root, block);\n  prepareBlock(root, block, payloadSize);\n  if (isDefined(ASC_RTRACE)) onalloc(block);\n  return block;\n}\n\n/** Reallocates a block to the specified size. */\nexport function reallocateBlock(root: Root, block: Block, size: usize): Block {\n  let payloadSize = prepareSize(size);\n  let blockInfo = block.mmInfo;\n  let blockSize = blockInfo & ~TAGS_MASK;\n\n  // possibly split and update runtime size if it still fits\n  if (payloadSize <= blockSize) {\n    prepareBlock(root, block, payloadSize);\n    if (isDefined(ASC_RTRACE)) {\n      if (payloadSize != blockSize) onresize(block, BLOCK_OVERHEAD + blockSize);\n    }\n    return block;\n  }\n\n  // merge with right free block if merger is large enough\n  let right = GETRIGHT(block);\n  let rightInfo = right.mmInfo;\n  if (rightInfo & FREE) {\n    let mergeSize = blockSize + BLOCK_OVERHEAD + (rightInfo & ~TAGS_MASK);\n    if (mergeSize >= payloadSize) {\n      removeBlock(root, right);\n      block.mmInfo = (blockInfo & TAGS_MASK) | mergeSize;\n      prepareBlock(root, block, payloadSize);\n      if (isDefined(ASC_RTRACE)) onresize(block, BLOCK_OVERHEAD + blockSize);\n      return block;\n    }\n  }\n\n  // otherwise move the block\n  return moveBlock(root, block, size);\n}\n\n/** Moves a block to a new one of the specified size. */\nfunction moveBlock(root: Root, block: Block, newSize: usize): Block {\n  let newBlock = allocateBlock(root, newSize);\n  memory.copy(changetype<usize>(newBlock) + BLOCK_OVERHEAD, changetype<usize>(block) + BLOCK_OVERHEAD, block.mmInfo & ~TAGS_MASK);\n  if (changetype<usize>(block) >= __heap_base) {\n    if (isDefined(ASC_RTRACE)) onmove(block, newBlock);\n    freeBlock(root, block);\n  }\n  return newBlock;\n}\n\n/** Frees a block. */\nexport function freeBlock(root: Root, block: Block): void {\n  if (isDefined(ASC_RTRACE)) onfree(block);\n  block.mmInfo = block.mmInfo | FREE;\n  insertBlock(root, block);\n}\n\n/** Checks that a used block is valid to be freed or reallocated. */\nfunction checkUsedBlock(ptr: usize): Block {\n  let block = changetype<Block>(ptr - BLOCK_OVERHEAD);\n  assert(\n    ptr != 0 && !(ptr & AL_MASK) &&  // must exist and be aligned\n    !(block.mmInfo & FREE)           // must be used\n  );\n  return block;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __alloc(size: usize): usize {\n  if (!ROOT) initialize();\n  return changetype<usize>(allocateBlock(ROOT, size)) + BLOCK_OVERHEAD;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __realloc(ptr: usize, size: usize): usize {\n  if (!ROOT) initialize();\n  return (ptr < __heap_base\n    ? changetype<usize>(moveBlock(ROOT, checkUsedBlock(ptr), size))\n    : changetype<usize>(reallocateBlock(ROOT, checkUsedBlock(ptr), size))\n  ) + BLOCK_OVERHEAD;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __free(ptr: usize): void {\n  if (ptr < __heap_base) return;\n  if (!ROOT) initialize();\n  freeBlock(ROOT, checkUsedBlock(ptr));\n}\n","// This file is shared with the compiler and must remain portable\n\n// ╒═══════════════════ Typeinfo interpretation ═══════════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤ ◄─ __rtti_base\n// │                             count                             │\n// ╞═══════════════════════════════════════════════════════════════╡ ┐\n// │                      Typeinfo#flags [id=0]                    │ id < count\n// ├───────────────────────────────────────────────────────────────┤\n// │                              ...                              │\n\n/** Runtime type information data structure. */\n@unmanaged\nexport class Typeinfo {\n  /** Flags describing the shape of this class type. */\n  flags: TypeinfoFlags = TypeinfoFlags.NONE;\n}\n\n/** Runtime type information flags. */\nexport const enum TypeinfoFlags {\n  /** No specific flags. */\n  NONE = 0,\n  /** Type is an `ArrayBufferView`. */\n  ARRAYBUFFERVIEW = 1 << 0,\n  /** Type is an `Array`. */\n  ARRAY = 1 << 1,\n  /** Type is a `StaticArray`. */\n  STATICARRAY = 1 << 2,\n  /** Type is a `Set`. */\n  SET = 1 << 3,\n  /** Type is a `Map`. */\n  MAP = 1 << 4,\n  /** Type has no outgoing pointers. */\n  POINTERFREE = 1 << 5,\n  /** Value alignment of 1 byte. */\n  VALUE_ALIGN_0 = 1 << 6,\n  /** Value alignment of 2 bytes. */\n  VALUE_ALIGN_1 = 1 << 7,\n  /** Value alignment of 4 bytes. */\n  VALUE_ALIGN_2 = 1 << 8,\n  /** Value alignment of 8 bytes. */\n  VALUE_ALIGN_3 = 1 << 9,\n  /** Value alignment of 16 bytes. */\n  VALUE_ALIGN_4 = 1 << 10,\n  /** Value is a signed type. */\n  VALUE_SIGNED = 1 << 11,\n  /** Value is a float type. */\n  VALUE_FLOAT = 1 << 12,\n  /** Value type is nullable. */\n  VALUE_NULLABLE = 1 << 13,\n  /** Value type is managed. */\n  VALUE_MANAGED = 1 << 14,\n  /** Key alignment of 1 byte. */\n  KEY_ALIGN_0 = 1 << 15,\n  /** Key alignment of 2 bytes. */\n  KEY_ALIGN_1 = 1 << 16,\n  /** Key alignment of 4 bytes. */\n  KEY_ALIGN_2 = 1 << 17,\n  /** Key alignment of 8 bytes. */\n  KEY_ALIGN_3 = 1 << 18,\n  /** Key alignment of 16 bytes. */\n  KEY_ALIGN_4 = 1 << 19,\n  /** Key is a signed type. */\n  KEY_SIGNED = 1 << 20,\n  /** Key is a float type. */\n  KEY_FLOAT = 1 << 21,\n  /** Key type is nullable. */\n  KEY_NULLABLE = 1 << 22,\n  /** Key type is managed. */\n  KEY_MANAGED = 1 << 23\n}\n","import { BLOCK, BLOCK_OVERHEAD, OBJECT_OVERHEAD, OBJECT_MAXSIZE, TOTAL_OVERHEAD, DEBUG, TRACE, RTRACE, PROFILE } from \"./common\";\nimport { onvisit, oncollect, oninterrupt, onyield } from \"./rtrace\";\nimport { TypeinfoFlags } from \"../shared/typeinfo\";\nimport { E_ALLOCATION_TOO_LARGE, E_ALREADY_PINNED, E_NOT_PINNED } from \"../util/error\";\n\n// === ITCMS: An incremental Tri-Color Mark & Sweep garbage collector ===\n// Adapted from Bach Le's μgc, see: https://github.com/bullno1/ugc\n\n// ╒═════════════╤══════════════ Colors ═══════════════════════════╕\n// │ Color       │ Meaning                                         │\n// ├─────────────┼─────────────────────────────────────────────────┤\n// │ WHITE*      │ Unprocessed                                     │\n// │ BLACK*      │ Processed                                       │\n// │ GRAY        │ Processed with unprocessed children             │\n// │ TRANSPARENT │ Manually pinned (always reachable)              │\n// └─────────────┴─────────────────────────────────────────────────┘\n// * flipped between cycles\n\n// @ts-ignore: decorator\n@lazy let white = 0;\n// @ts-ignore: decorator\n@inline const gray = 2;\n// @ts-ignore: decorator\n@inline const transparent = 3;\n// @ts-ignore: decorator\n@inline const COLOR_MASK = 3;\n\n/** Size in memory of all objects currently managed by the GC. */\n// @ts-ignore: decorator\n@lazy let total: usize = 0;\n\n/** Currently transitioning from SWEEP to MARK state. */\n// @ts-ignore: decorator\n@inline const STATE_IDLE = 0;\n/** Currently marking reachable objects. */\n// @ts-ignore: decorator\n@inline const STATE_MARK = 1;\n/** Currently sweeping unreachable objects. */\n// @ts-ignore: decorator\n@inline const STATE_SWEEP = 2;\n/** Current collector state. */\n// @ts-ignore: decorator\n@lazy let state = STATE_IDLE;\n\n// @ts-ignore: decorator\n@lazy let fromSpace = initLazy(changetype<Object>(memory.data(offsetof<Object>())));\n// @ts-ignore: decorator\n@lazy let toSpace = initLazy(changetype<Object>(memory.data(offsetof<Object>())));\n// @ts-ignore: decorator\n@lazy let pinSpace = initLazy(changetype<Object>(memory.data(offsetof<Object>())));\n// @ts-ignore: decorator\n@lazy let iter: Object = changetype<Object>(0); // unsafe initializion below\n\nfunction initLazy(space: Object): Object {\n  space.nextWithColor = changetype<usize>(space);\n  space.prev = space;\n  return space;\n}\n\n/** Visit cookie indicating scanning of an object. */\n// @ts-ignore: decorator\n@inline const VISIT_SCAN = 0;\n\n// ╒═══════════════ Managed object layout (32-bit) ════════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤\n// │                      Memory manager block                     │\n// ╞═══════════════════════════════════════════════════════════╤═══╡\n// │                              next                         │ C │ = nextWithColor\n// ├───────────────────────────────────────────────────────────┴───┤\n// │                              prev                             │\n// ├───────────────────────────────────────────────────────────────┤\n// │                              rtId                             │\n// ├───────────────────────────────────────────────────────────────┤\n// │                              rtSize                           │\n// ╞>ptr═══════════════════════════════════════════════════════════╡\n// │                               ...                             │\n// C: color\n\n/** Represents a managed object in memory, consisting of a header followed by the object's data. */\n@unmanaged class Object extends BLOCK {\n  /** Pointer to the next object with color flags stored in the alignment bits. */\n  nextWithColor: usize; // *u32\n  /** Pointer to the previous object. */\n  prev: Object; // *u32\n  /** Runtime id. */\n  rtId: u32;\n  /** Runtime size. */\n  rtSize: u32;\n\n  /** Gets the pointer to the next object. */\n  get next(): Object {\n    return changetype<Object>(this.nextWithColor & ~COLOR_MASK);\n  }\n\n  /** Sets the pointer to the next object. */\n  set next(obj: Object) {\n    this.nextWithColor = changetype<usize>(obj) | (this.nextWithColor & COLOR_MASK);\n  }\n\n  /** Gets this object's color. */\n  get color(): i32 {\n    return i32(this.nextWithColor & COLOR_MASK);\n  }\n\n  /** Sets this object's color. */\n  set color(color: i32) {\n    this.nextWithColor = (this.nextWithColor & ~COLOR_MASK) | color;\n  }\n\n  /** Gets the size of this object in memory. */\n  get size(): usize {\n    return BLOCK_OVERHEAD + (this.mmInfo & ~3);\n  }\n\n  /** Tests if this object is pointerfree. */\n  get isPointerfree(): bool {\n    let rtId = this.rtId;\n    // 0: Object, 1: ArrayBuffer, 2: String\n    return rtId <= idof<string>() || (__typeinfo(rtId) & TypeinfoFlags.POINTERFREE) != 0;\n  }\n\n  /** Unlinks this object from its list. */\n  unlink(): void {\n    let next = this.next;\n    if (next == null) {\n      if (DEBUG) assert(this.prev == null && changetype<usize>(this) < __heap_base);\n      return; // static data not yet linked\n    }\n    let prev = this.prev;\n    if (DEBUG) assert(prev);\n    next.prev = prev;\n    prev.next = next;\n  }\n\n  /** Links this object to the specified list, with the given color. */\n  linkTo(list: Object, withColor: i32): void {\n    let prev = list.prev;\n    this.nextWithColor = changetype<usize>(list) | withColor;\n    this.prev = prev;\n    prev.next = this;\n    list.prev = this;\n  }\n\n  /** Marks this object as gray, that is reachable with unscanned children. */\n  makeGray(): void {\n    if (this == iter) iter = assert(this.prev);\n    this.unlink();\n    this.linkTo(toSpace, this.isPointerfree ? i32(!white) : gray);\n  }\n}\n\n/** Visits all objects considered to be program roots. */\nfunction visitRoots(cookie: u32): void {\n  __visit_globals(cookie);\n  let pn = pinSpace;\n  let iter = pn.next;\n  while (iter != pn) {\n    if (DEBUG) assert(iter.color == transparent);\n    __visit_members(changetype<usize>(iter) + TOTAL_OVERHEAD, cookie);\n    iter = iter.next;\n  }\n}\n\n/** Visits all objects on the stack. */\nfunction visitStack(cookie: u32): void {\n  let ptr = __stack_pointer;\n  while (ptr < __heap_base) {\n    __visit(load<usize>(ptr), cookie);\n    ptr += sizeof<usize>();\n  }\n}\n\n/** Performs a single step according to the current state. */\nfunction step(): usize {\n  // Magic constants responsible for pause times. Obtained experimentally\n  // using the compiler compiling itself. 2048 budget pro run by default.\n  const MARKCOST = isDefined(ASC_GC_MARKCOST) ? ASC_GC_MARKCOST : 1;\n  const SWEEPCOST = isDefined(ASC_GC_SWEEPCOST) ? ASC_GC_SWEEPCOST : 10;\n  let obj: Object;\n  switch (state) {\n    case STATE_IDLE: {\n      state = STATE_MARK;\n      visitCount = 0;\n      visitRoots(VISIT_SCAN);\n      iter = toSpace;\n      return visitCount * MARKCOST;\n    }\n    case STATE_MARK: {\n      let black = i32(!white);\n      obj = iter.next;\n      while (obj != toSpace) {\n        iter = obj;\n        if (obj.color != black) { // skip already-blacks (pointerfree)\n          obj.color = black;\n          visitCount = 0;\n          __visit_members(changetype<usize>(obj) + TOTAL_OVERHEAD, VISIT_SCAN);\n          return visitCount * MARKCOST;\n        }\n        obj = obj.next;\n      }\n      visitCount = 0;\n      visitRoots(VISIT_SCAN);\n      obj = iter.next;\n      if (obj == toSpace) {\n        visitStack(VISIT_SCAN);\n        obj = iter.next;\n        while (obj != toSpace) {\n          if (obj.color != black) {\n            obj.color = black;\n            __visit_members(changetype<usize>(obj) + TOTAL_OVERHEAD, VISIT_SCAN);\n          }\n          obj = obj.next;\n        }\n        let from = fromSpace;\n        fromSpace = toSpace;\n        toSpace = from;\n        white = black;\n        iter = from.next;\n        state = STATE_SWEEP;\n      }\n      return visitCount * MARKCOST;\n    }\n    case STATE_SWEEP: {\n      obj = iter;\n      if (obj != toSpace) {\n        iter = obj.next;\n        if (DEBUG) assert(obj.color == i32(!white)); // old white\n        free(obj);\n        return SWEEPCOST;\n      }\n      toSpace.nextWithColor = changetype<usize>(toSpace);\n      toSpace.prev = toSpace;\n      state = STATE_IDLE;\n      break;\n    }\n  }\n  return 0;\n}\n\n/** Frees an object. */\nfunction free(obj: Object): void {\n  if (changetype<usize>(obj) < __heap_base) {\n    obj.nextWithColor = 0; // may become linked again\n    obj.prev = changetype<Object>(0);\n  } else {\n    total -= obj.size;\n    if (isDefined(__finalize)) {\n      __finalize(changetype<usize>(obj) + TOTAL_OVERHEAD);\n    }\n    __free(changetype<usize>(obj) + BLOCK_OVERHEAD);\n  }\n}\n\n// Garbage collector interface\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __new(size: usize, id: i32): usize {\n  if (size >= OBJECT_MAXSIZE) throw new Error(E_ALLOCATION_TOO_LARGE);\n  if (total >= threshold) interrupt();\n  let obj = changetype<Object>(__alloc(OBJECT_OVERHEAD + size) - BLOCK_OVERHEAD);\n  obj.rtId = id;\n  obj.rtSize = <u32>size;\n  obj.linkTo(fromSpace, white); // inits next/prev\n  total += obj.size;\n  let ptr = changetype<usize>(obj) + TOTAL_OVERHEAD;\n  // may be visited before being fully initialized, so must fill\n  memory.fill(ptr, 0, size);\n  return ptr;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __renew(oldPtr: usize, size: usize): usize {\n  let oldObj = changetype<Object>(oldPtr - TOTAL_OVERHEAD);\n  // Update object size if its block is large enough\n  if (size <= (oldObj.mmInfo & ~3) - OBJECT_OVERHEAD) {\n    oldObj.rtSize = <u32>size;\n    return oldPtr;\n  }\n  // If not the same object anymore, we have to move it move it due to the\n  // shadow stack potentially still referencing the old object\n  let newPtr = __new(size, oldObj.rtId);\n  memory.copy(newPtr, oldPtr, min(size, oldObj.rtSize));\n  return newPtr;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __link(parentPtr: usize, childPtr: usize, expectMultiple: bool): void {\n  // Write barrier is unnecessary if non-incremental\n  if (!childPtr) return;\n  if (DEBUG) assert(parentPtr);\n  let child = changetype<Object>(childPtr - TOTAL_OVERHEAD);\n  if (child.color == white) {\n    let parent = changetype<Object>(parentPtr - TOTAL_OVERHEAD);\n    let parentColor = parent.color;\n    if (parentColor == i32(!white)) {\n      // Maintain the invariant that no black object may point to a white object.\n      if (expectMultiple) {\n        // Move the barrier \"backward\". Suitable for containers receiving multiple stores.\n        // Avoids a barrier for subsequent objects stored into the same container.\n        parent.makeGray();\n      } else {\n        // Move the barrier \"forward\". Suitable for objects receiving isolated stores.\n        child.makeGray();\n      }\n    } else if (parentColor == transparent && state == STATE_MARK) {\n      // Pinned objects are considered 'black' during the mark phase.\n      child.makeGray();\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@lazy let visitCount = 0;\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __visit(ptr: usize, cookie: i32): void {\n  if (!ptr) return;\n  let obj = changetype<Object>(ptr - TOTAL_OVERHEAD);\n  if (RTRACE) if (!onvisit(obj)) return;\n  if (obj.color == white) {\n    obj.makeGray();\n    ++visitCount;\n  }\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __pin(ptr: usize): usize {\n  if (ptr) {\n    let obj = changetype<Object>(ptr - TOTAL_OVERHEAD);\n    if (obj.color == transparent) {\n      throw new Error(E_ALREADY_PINNED);\n    }\n    obj.unlink(); // from fromSpace\n    obj.linkTo(pinSpace, transparent);\n  }\n  return ptr;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __unpin(ptr: usize): void {\n  if (!ptr) return;\n  let obj = changetype<Object>(ptr - TOTAL_OVERHEAD);\n  if (obj.color != transparent) {\n    throw new Error(E_NOT_PINNED);\n  }\n  if (state == STATE_MARK) {\n    // We may be right at the point after marking roots for the second time and\n    // entering the sweep phase, in which case the object would be missed if it\n    // is not only pinned but also a root. Make sure it isn't missed.\n    obj.makeGray();\n  } else {\n    obj.unlink();\n    obj.linkTo(fromSpace, white);\n  }\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __collect(): void {\n  if (TRACE) trace(\"GC (full) at\", 1, total);\n  if (state > STATE_IDLE) {\n    // finish current cycle\n    while (state != STATE_IDLE) step();\n  }\n  // perform a full cycle\n  step();\n  while (state != STATE_IDLE) step();\n  threshold = <usize>(<u64>total * IDLEFACTOR / 100) + GRANULARITY;\n  if (TRACE) trace(\"GC (full) done at cur/max\", 2, total, memory.size() << 16);\n  if (RTRACE || PROFILE) oncollect(total);\n}\n\n// Garbage collector automation\n\n/** How often to interrupt. The default of 1024 means \"interrupt each 1024 bytes allocated\". */\n// @ts-ignore: decorator\n@inline const GRANULARITY: usize = isDefined(ASC_GC_GRANULARITY) ? ASC_GC_GRANULARITY : 1024;\n/** How long to interrupt. The default of 200% means \"run at double the speed of allocations\". */\n// @ts-ignore: decorator\n@inline const STEPFACTOR: usize = isDefined(ASC_GC_SWEEPFACTOR) ? ASC_GC_SWEEPFACTOR : 200;\n/** How long to idle. The default of 200% means \"wait for memory to double before kicking in again\". */\n// @ts-ignore: decorator\n@inline const IDLEFACTOR: usize = isDefined(ASC_GC_IDLEFACTOR) ? ASC_GC_IDLEFACTOR : 200;\n\n/** Threshold of memory used by objects to exceed before interrupting again. */\n// @ts-ignore: decorator\n@lazy let threshold: usize = ((<usize>memory.size() << 16) - __heap_base) >> 1;\n\n/** Performs a reasonable amount of incremental GC steps. */\nfunction interrupt(): void {\n  if (PROFILE) oninterrupt(total);\n  if (TRACE) trace(\"GC (auto) at\", 1, total);\n  let budget: isize = GRANULARITY * STEPFACTOR / 100;\n  do {\n    budget -= step();\n    if (state == STATE_IDLE) {\n      if (TRACE) trace(\"└ GC (auto) done at cur/max\", 2, total, memory.size() << 16);\n      threshold = <usize>(<u64>total * IDLEFACTOR / 100) + GRANULARITY;\n      if (PROFILE) onyield(total);\n      return;\n    }\n  } while (budget > 0);\n  if (TRACE) trace(\"└ GC (auto) ongoing at\", 1, total);\n  threshold = total + GRANULARITY * usize(total - threshold < GRANULARITY);\n  if (PROFILE) onyield(total);\n}\n","import { FutureId, getFutureStatus } from '../mugl';\nimport { ImageSource } from '../dom';\n\nexport { ImageSource };\n\n/** JS number type. */\nexport type Num = f64;\n\n/** Float type. */\nexport type Float = f32;\n\n/** Int type. */\nexport type Int = i32;\n\n/** Unsigned Int type. */\nexport type UInt = u32;\n\n/** Unsigned int array type. */\n export type UIntArray = StaticArray<UInt>;\n\n/** RGBA color type. */\nexport type Color = StaticArray<Float>;\n\n/** An (width, height) 2D extent. */\nexport type Extent2D = StaticArray<UInt>;\n\n/** An (width, height, depth) 3D extent. */\nexport type Extent3D = StaticArray<UInt>;\n\n/** A (x, y) 2D point. */\nexport type Origin2D = StaticArray<UInt>;\n\n/** A (x, y, z) 3D point. */\nexport type Origin3D = StaticArray<UInt>;\n\n/** Future base type. */\nexport class Future<T = null> {\n  private _status: FutureStatus = FutureStatus.Pending;\n\n  public constructor(\n    public readonly id: FutureId\n  ) {\n  }\n\n  /** Returns resolved value of the future. */\n  public get value(): T | null {\n    return null;\n  }\n\n  /** Returns current status of the future. */\n  public get status(): FutureStatus {\n    return this._status || (this._status = getFutureStatus(this.id));\n  }\n}\n\n/** Status of a future. */\n export enum FutureStatus {\n  /** The future is still pending. */\n  Pending = 0,\n  /** The future is resolved. */\n  Done = 1,\n  /** An error occurred while resolving the future. */\n  Error = 2,\n}\n","/**\n * All WebGL core and extension constants.\n * @see https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Constants\n * @see https://github.com/KhronosGroup/WebGL/blob/main/specs/latest/1.0/webgl.idl\n * @see https://github.com/KhronosGroup/WebGL/blob/main/specs/latest/2.0/webgl.idl\n * @see https://github.com/KhronosGroup/WebGL/tree/main/extensions\n * @packageDocumentation\n */\n\n/* WebGL 1.0 constants */\n\n/* ClearBufferMask */\nexport const DEPTH_BUFFER_BIT = 0x00000100;\nexport const STENCIL_BUFFER_BIT = 0x00000400;\nexport const COLOR_BUFFER_BIT = 0x00004000;\n\n/* BeginMode */\nexport const POINTS = 0x0000;\nexport const LINES = 0x0001;\nexport const LINE_LOOP = 0x0002;\nexport const LINE_STRIP = 0x0003;\nexport const TRIANGLES = 0x0004;\nexport const TRIANGLE_STRIP = 0x0005;\nexport const TRIANGLE_FAN = 0x0006;\n\n/* AlphaFunction (not supported in ES20) */\n/*      NEVER */\n/*      LESS */\n/*      EQUAL */\n/*      LEQUAL */\n/*      GREATER */\n/*      NOTEQUAL */\n/*      GEQUAL */\n/*      ALWAYS */\n\n/* BlendingFactorDest */\nexport const ZERO = 0;\nexport const ONE = 1;\nexport const SRC_COLOR = 0x0300;\nexport const ONE_MINUS_SRC_COLOR = 0x0301;\nexport const SRC_ALPHA = 0x0302;\nexport const ONE_MINUS_SRC_ALPHA = 0x0303;\nexport const DST_ALPHA = 0x0304;\nexport const ONE_MINUS_DST_ALPHA = 0x0305;\n\n/* BlendingFactorSrc */\n/*      ZERO */\n/*      ONE */\nexport const DST_COLOR = 0x0306;\nexport const ONE_MINUS_DST_COLOR = 0x0307;\nexport const SRC_ALPHA_SATURATE = 0x0308;\n/*      SRC_ALPHA */\n/*      ONE_MINUS_SRC_ALPHA */\n/*      DST_ALPHA */\n/*      ONE_MINUS_DST_ALPHA */\n\n/* BlendEquationSeparate */\nexport const FUNC_ADD = 0x8006;\nexport const BLEND_EQUATION = 0x8009;\nexport const BLEND_EQUATION_RGB = 0x8009;   /* same as BLEND_EQUATION */\nexport const BLEND_EQUATION_ALPHA = 0x883D;\n\n/* BlendSubtract */\nexport const FUNC_SUBTRACT = 0x800A;\nexport const FUNC_REVERSE_SUBTRACT = 0x800B;\n\n/* Separate Blend Functions */\nexport const BLEND_DST_RGB = 0x80C8;\nexport const BLEND_SRC_RGB = 0x80C9;\nexport const BLEND_DST_ALPHA = 0x80CA;\nexport const BLEND_SRC_ALPHA = 0x80CB;\nexport const CONSTANT_COLOR = 0x8001;\nexport const ONE_MINUS_CONSTANT_COLOR = 0x8002;\nexport const CONSTANT_ALPHA = 0x8003;\nexport const ONE_MINUS_CONSTANT_ALPHA = 0x8004;\nexport const BLEND_COLOR = 0x8005;\n\n/* Buffer Objects */\nexport const ARRAY_BUFFER = 0x8892;\nexport const ELEMENT_ARRAY_BUFFER = 0x8893;\nexport const ARRAY_BUFFER_BINDING = 0x8894;\nexport const ELEMENT_ARRAY_BUFFER_BINDING = 0x8895;\n\nexport const STREAM_DRAW = 0x88E0;\nexport const STATIC_DRAW = 0x88E4;\nexport const DYNAMIC_DRAW = 0x88E8;\n\nexport const BUFFER_SIZE = 0x8764;\nexport const BUFFER_USAGE = 0x8765;\n\nexport const CURRENT_VERTEX_ATTRIB = 0x8626;\n\n/* CullFaceMode */\nexport const FRONT = 0x0404;\nexport const BACK = 0x0405;\nexport const FRONT_AND_BACK = 0x0408;\n\n/* DepthFunction */\n/*      NEVER */\n/*      LESS */\n/*      EQUAL */\n/*      LEQUAL */\n/*      GREATER */\n/*      NOTEQUAL */\n/*      GEQUAL */\n/*      ALWAYS */\n\n/* EnableCap */\n/* TEXTURE_2D */\nexport const CULL_FACE = 0x0B44;\nexport const BLEND = 0x0BE2;\nexport const DITHER = 0x0BD0;\nexport const STENCIL_TEST = 0x0B90;\nexport const DEPTH_TEST = 0x0B71;\nexport const SCISSOR_TEST = 0x0C11;\nexport const POLYGON_OFFSET_FILL = 0x8037;\nexport const SAMPLE_ALPHA_TO_COVERAGE = 0x809E;\nexport const SAMPLE_COVERAGE = 0x80A0;\n\n/* ErrorCode */\nexport const NO_ERROR = 0;\nexport const INVALID_ENUM = 0x0500;\nexport const INVALID_VALUE = 0x0501;\nexport const INVALID_OPERATION = 0x0502;\nexport const OUT_OF_MEMORY = 0x0505;\n\n/* FrontFaceDirection */\nexport const CW = 0x0900;\nexport const CCW = 0x0901;\n\n/* GetPName */\nexport const LINE_WIDTH = 0x0B21;\nexport const ALIASED_POINT_SIZE_RANGE = 0x846D;\nexport const ALIASED_LINE_WIDTH_RANGE = 0x846E;\nexport const CULL_FACE_MODE = 0x0B45;\nexport const FRONT_FACE = 0x0B46;\nexport const DEPTH_RANGE = 0x0B70;\nexport const DEPTH_WRITEMASK = 0x0B72;\nexport const DEPTH_CLEAR_VALUE = 0x0B73;\nexport const DEPTH_FUNC = 0x0B74;\nexport const STENCIL_CLEAR_VALUE = 0x0B91;\nexport const STENCIL_FUNC = 0x0B92;\nexport const STENCIL_FAIL = 0x0B94;\nexport const STENCIL_PASS_DEPTH_FAIL = 0x0B95;\nexport const STENCIL_PASS_DEPTH_PASS = 0x0B96;\nexport const STENCIL_REF = 0x0B97;\nexport const STENCIL_VALUE_MASK = 0x0B93;\nexport const STENCIL_WRITEMASK = 0x0B98;\nexport const STENCIL_BACK_FUNC = 0x8800;\nexport const STENCIL_BACK_FAIL = 0x8801;\nexport const STENCIL_BACK_PASS_DEPTH_FAIL = 0x8802;\nexport const STENCIL_BACK_PASS_DEPTH_PASS = 0x8803;\nexport const STENCIL_BACK_REF = 0x8CA3;\nexport const STENCIL_BACK_VALUE_MASK = 0x8CA4;\nexport const STENCIL_BACK_WRITEMASK = 0x8CA5;\nexport const VIEWPORT = 0x0BA2;\nexport const SCISSOR_BOX = 0x0C10;\n/*      SCISSOR_TEST */\nexport const COLOR_CLEAR_VALUE = 0x0C22;\nexport const COLOR_WRITEMASK = 0x0C23;\nexport const UNPACK_ALIGNMENT = 0x0CF5;\nexport const PACK_ALIGNMENT = 0x0D05;\nexport const MAX_TEXTURE_SIZE = 0x0D33;\nexport const MAX_VIEWPORT_DIMS = 0x0D3A;\nexport const SUBPIXEL_BITS = 0x0D50;\nexport const RED_BITS = 0x0D52;\nexport const GREEN_BITS = 0x0D53;\nexport const BLUE_BITS = 0x0D54;\nexport const ALPHA_BITS = 0x0D55;\nexport const DEPTH_BITS = 0x0D56;\nexport const STENCIL_BITS = 0x0D57;\nexport const POLYGON_OFFSET_UNITS = 0x2A00;\n/*      POLYGON_OFFSET_FILL */\nexport const POLYGON_OFFSET_FACTOR = 0x8038;\nexport const TEXTURE_BINDING_2D = 0x8069;\nexport const SAMPLE_BUFFERS = 0x80A8;\nexport const SAMPLES = 0x80A9;\nexport const SAMPLE_COVERAGE_VALUE = 0x80AA;\nexport const SAMPLE_COVERAGE_INVERT = 0x80AB;\n\n/* GetTextureParameter */\n/*      TEXTURE_MAG_FILTER */\n/*      TEXTURE_MIN_FILTER */\n/*      TEXTURE_WRAP_S */\n/*      TEXTURE_WRAP_T */\n\nexport const COMPRESSED_TEXTURE_FORMATS = 0x86A3;\n\n/* HintMode */\nexport const DONT_CARE = 0x1100;\nexport const FASTEST = 0x1101;\nexport const NICEST = 0x1102;\n\n/* HintTarget */\nexport const GENERATE_MIPMAP_HINT = 0x8192;\n\n/* DataType */\nexport const BYTE = 0x1400;\nexport const UNSIGNED_BYTE = 0x1401;\nexport const SHORT = 0x1402;\nexport const UNSIGNED_SHORT = 0x1403;\nexport const INT = 0x1404;\nexport const UNSIGNED_INT = 0x1405;\nexport const FLOAT = 0x1406;\n\n/* PixelFormat */\nexport const DEPTH_COMPONENT = 0x1902;\nexport const ALPHA = 0x1906;\nexport const RGB = 0x1907;\nexport const RGBA = 0x1908;\nexport const LUMINANCE = 0x1909;\nexport const LUMINANCE_ALPHA = 0x190A;\n\n/* PixelType */\n/*      UNSIGNED_BYTE */\nexport const UNSIGNED_SHORT_4_4_4_4 = 0x8033;\nexport const UNSIGNED_SHORT_5_5_5_1 = 0x8034;\nexport const UNSIGNED_SHORT_5_6_5 = 0x8363;\n\n/* Shaders */\nexport const FRAGMENT_SHADER = 0x8B30;\nexport const VERTEX_SHADER = 0x8B31;\nexport const MAX_VERTEX_ATTRIBS = 0x8869;\nexport const MAX_VERTEX_UNIFORM_VECTORS = 0x8DFB;\nexport const MAX_VARYING_VECTORS = 0x8DFC;\nexport const MAX_COMBINED_TEXTURE_IMAGE_UNITS = 0x8B4D;\nexport const MAX_VERTEX_TEXTURE_IMAGE_UNITS = 0x8B4C;\nexport const MAX_TEXTURE_IMAGE_UNITS = 0x8872;\nexport const MAX_FRAGMENT_UNIFORM_VECTORS = 0x8DFD;\nexport const SHADER_TYPE = 0x8B4F;\nexport const DELETE_STATUS = 0x8B80;\nexport const LINK_STATUS = 0x8B82;\nexport const VALIDATE_STATUS = 0x8B83;\nexport const ATTACHED_SHADERS = 0x8B85;\nexport const ACTIVE_UNIFORMS = 0x8B86;\nexport const ACTIVE_ATTRIBUTES = 0x8B89;\nexport const SHADING_LANGUAGE_VERSION = 0x8B8C;\nexport const CURRENT_PROGRAM = 0x8B8D;\n\n/* StencilFunction */\nexport const NEVER = 0x0200;\nexport const LESS = 0x0201;\nexport const EQUAL = 0x0202;\nexport const LEQUAL = 0x0203;\nexport const GREATER = 0x0204;\nexport const NOTEQUAL = 0x0205;\nexport const GEQUAL = 0x0206;\nexport const ALWAYS = 0x0207;\n\n/* StencilOp */\n/*      ZERO */\nexport const KEEP = 0x1E00;\nexport const REPLACE = 0x1E01;\nexport const INCR = 0x1E02;\nexport const DECR = 0x1E03;\nexport const INVERT = 0x150A;\nexport const INCR_WRAP = 0x8507;\nexport const DECR_WRAP = 0x8508;\n\n/* StringName */\nexport const VENDOR = 0x1F00;\nexport const RENDERER = 0x1F01;\nexport const VERSION = 0x1F02;\n\n/* TextureMagFilter */\nexport const NEAREST = 0x2600;\nexport const LINEAR = 0x2601;\n\n/* TextureMinFilter */\n/*      NEAREST */\n/*      LINEAR */\nexport const NEAREST_MIPMAP_NEAREST = 0x2700;\nexport const LINEAR_MIPMAP_NEAREST = 0x2701;\nexport const NEAREST_MIPMAP_LINEAR = 0x2702;\nexport const LINEAR_MIPMAP_LINEAR = 0x2703;\n\n/* TextureParameterName */\nexport const TEXTURE_MAG_FILTER = 0x2800;\nexport const TEXTURE_MIN_FILTER = 0x2801;\nexport const TEXTURE_WRAP_S = 0x2802;\nexport const TEXTURE_WRAP_T = 0x2803;\n\n/* TextureTarget */\nexport const TEXTURE_2D = 0x0DE1;\nexport const TEXTURE = 0x1702;\n\nexport const TEXTURE_CUBE_MAP = 0x8513;\nexport const TEXTURE_BINDING_CUBE_MAP = 0x8514;\nexport const TEXTURE_CUBE_MAP_POSITIVE_X = 0x8515;\nexport const TEXTURE_CUBE_MAP_NEGATIVE_X = 0x8516;\nexport const TEXTURE_CUBE_MAP_POSITIVE_Y = 0x8517;\nexport const TEXTURE_CUBE_MAP_NEGATIVE_Y = 0x8518;\nexport const TEXTURE_CUBE_MAP_POSITIVE_Z = 0x8519;\nexport const TEXTURE_CUBE_MAP_NEGATIVE_Z = 0x851A;\nexport const MAX_CUBE_MAP_TEXTURE_SIZE = 0x851C;\n\n/* TextureUnit */\nexport const TEXTURE0 = 0x84C0;\nexport const TEXTURE1 = 0x84C1;\nexport const TEXTURE2 = 0x84C2;\nexport const TEXTURE3 = 0x84C3;\nexport const TEXTURE4 = 0x84C4;\nexport const TEXTURE5 = 0x84C5;\nexport const TEXTURE6 = 0x84C6;\nexport const TEXTURE7 = 0x84C7;\nexport const TEXTURE8 = 0x84C8;\nexport const TEXTURE9 = 0x84C9;\nexport const TEXTURE10 = 0x84CA;\nexport const TEXTURE11 = 0x84CB;\nexport const TEXTURE12 = 0x84CC;\nexport const TEXTURE13 = 0x84CD;\nexport const TEXTURE14 = 0x84CE;\nexport const TEXTURE15 = 0x84CF;\nexport const TEXTURE16 = 0x84D0;\nexport const TEXTURE17 = 0x84D1;\nexport const TEXTURE18 = 0x84D2;\nexport const TEXTURE19 = 0x84D3;\nexport const TEXTURE20 = 0x84D4;\nexport const TEXTURE21 = 0x84D5;\nexport const TEXTURE22 = 0x84D6;\nexport const TEXTURE23 = 0x84D7;\nexport const TEXTURE24 = 0x84D8;\nexport const TEXTURE25 = 0x84D9;\nexport const TEXTURE26 = 0x84DA;\nexport const TEXTURE27 = 0x84DB;\nexport const TEXTURE28 = 0x84DC;\nexport const TEXTURE29 = 0x84DD;\nexport const TEXTURE30 = 0x84DE;\nexport const TEXTURE31 = 0x84DF;\nexport const ACTIVE_TEXTURE = 0x84E0;\n\n/* TextureWrapMode */\nexport const REPEAT = 0x2901;\nexport const CLAMP_TO_EDGE = 0x812F;\nexport const MIRRORED_REPEAT = 0x8370;\n\n/* Uniform Types */\nexport const FLOAT_VEC2 = 0x8B50;\nexport const FLOAT_VEC3 = 0x8B51;\nexport const FLOAT_VEC4 = 0x8B52;\nexport const INT_VEC2 = 0x8B53;\nexport const INT_VEC3 = 0x8B54;\nexport const INT_VEC4 = 0x8B55;\nexport const BOOL = 0x8B56;\nexport const BOOL_VEC2 = 0x8B57;\nexport const BOOL_VEC3 = 0x8B58;\nexport const BOOL_VEC4 = 0x8B59;\nexport const FLOAT_MAT2 = 0x8B5A;\nexport const FLOAT_MAT3 = 0x8B5B;\nexport const FLOAT_MAT4 = 0x8B5C;\nexport const SAMPLER_2D = 0x8B5E;\nexport const SAMPLER_CUBE = 0x8B60;\n\n/* Vertex Arrays */\nexport const VERTEX_ATTRIB_ARRAY_ENABLED = 0x8622;\nexport const VERTEX_ATTRIB_ARRAY_SIZE = 0x8623;\nexport const VERTEX_ATTRIB_ARRAY_STRIDE = 0x8624;\nexport const VERTEX_ATTRIB_ARRAY_TYPE = 0x8625;\nexport const VERTEX_ATTRIB_ARRAY_NORMALIZED = 0x886A;\nexport const VERTEX_ATTRIB_ARRAY_POINTER = 0x8645;\nexport const VERTEX_ATTRIB_ARRAY_BUFFER_BINDING = 0x889F;\n\n/* Read Format */\nexport const IMPLEMENTATION_COLOR_READ_TYPE = 0x8B9A;\nexport const IMPLEMENTATION_COLOR_READ_FORMAT = 0x8B9B;\n\n/* Shader Source */\nexport const COMPILE_STATUS = 0x8B81;\n\n/* Shader Precision-Specified Types */\nexport const LOW_FLOAT = 0x8DF0;\nexport const MEDIUM_FLOAT = 0x8DF1;\nexport const HIGH_FLOAT = 0x8DF2;\nexport const LOW_INT = 0x8DF3;\nexport const MEDIUM_INT = 0x8DF4;\nexport const HIGH_INT = 0x8DF5;\n\n/* Framebuffer Object. */\nexport const FRAMEBUFFER = 0x8D40;\nexport const RENDERBUFFER = 0x8D41;\n\nexport const RGBA4 = 0x8056;\nexport const RGB5_A1 = 0x8057;\nexport const RGB565 = 0x8D62;\nexport const DEPTH_COMPONENT16 = 0x81A5;\nexport const STENCIL_INDEX = 0x1901;\nexport const STENCIL_INDEX8 = 0x8D48;\nexport const DEPTH_STENCIL = 0x84F9;\n\nexport const RENDERBUFFER_WIDTH = 0x8D42;\nexport const RENDERBUFFER_HEIGHT = 0x8D43;\nexport const RENDERBUFFER_INTERNAL_FORMAT = 0x8D44;\nexport const RENDERBUFFER_RED_SIZE = 0x8D50;\nexport const RENDERBUFFER_GREEN_SIZE = 0x8D51;\nexport const RENDERBUFFER_BLUE_SIZE = 0x8D52;\nexport const RENDERBUFFER_ALPHA_SIZE = 0x8D53;\nexport const RENDERBUFFER_DEPTH_SIZE = 0x8D54;\nexport const RENDERBUFFER_STENCIL_SIZE = 0x8D55;\n\nexport const FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE = 0x8CD0;\nexport const FRAMEBUFFER_ATTACHMENT_OBJECT_NAME = 0x8CD1;\nexport const FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL = 0x8CD2;\nexport const FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE = 0x8CD3;\n\nexport const COLOR_ATTACHMENT0 = 0x8CE0;\nexport const DEPTH_ATTACHMENT = 0x8D00;\nexport const STENCIL_ATTACHMENT = 0x8D20;\nexport const DEPTH_STENCIL_ATTACHMENT = 0x821A;\n\nexport const NONE = 0;\n\nexport const FRAMEBUFFER_COMPLETE = 0x8CD5;\nexport const FRAMEBUFFER_INCOMPLETE_ATTACHMENT = 0x8CD6;\nexport const FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT = 0x8CD7;\nexport const FRAMEBUFFER_INCOMPLETE_DIMENSIONS = 0x8CD9;\nexport const FRAMEBUFFER_UNSUPPORTED = 0x8CDD;\n\nexport const FRAMEBUFFER_BINDING = 0x8CA6;\nexport const RENDERBUFFER_BINDING = 0x8CA7;\nexport const MAX_RENDERBUFFER_SIZE = 0x84E8;\n\nexport const INVALID_FRAMEBUFFER_OPERATION = 0x0506;\n\n/* WebGL-specific enums */\nexport const UNPACK_FLIP_Y_WEBGL = 0x9240;\nexport const UNPACK_PREMULTIPLY_ALPHA_WEBGL = 0x9241;\nexport const CONTEXT_LOST_WEBGL = 0x9242;\nexport const UNPACK_COLORSPACE_CONVERSION_WEBGL = 0x9243;\nexport const BROWSER_DEFAULT_WEBGL = 0x9244;\n\n/* WebGL 2.0 constants */\n\nexport const READ_BUFFER = 0x0C02;\nexport const UNPACK_ROW_LENGTH = 0x0CF2;\nexport const UNPACK_SKIP_ROWS = 0x0CF3;\nexport const UNPACK_SKIP_PIXELS = 0x0CF4;\nexport const PACK_ROW_LENGTH = 0x0D02;\nexport const PACK_SKIP_ROWS = 0x0D03;\nexport const PACK_SKIP_PIXELS = 0x0D04;\nexport const COLOR = 0x1800;\nexport const DEPTH = 0x1801;\nexport const STENCIL = 0x1802;\nexport const RED = 0x1903;\nexport const RGB8 = 0x8051;\nexport const RGBA8 = 0x8058;\nexport const RGB10_A2 = 0x8059;\nexport const TEXTURE_BINDING_3D = 0x806A;\nexport const UNPACK_SKIP_IMAGES = 0x806D;\nexport const UNPACK_IMAGE_HEIGHT = 0x806E;\nexport const TEXTURE_3D = 0x806F;\nexport const TEXTURE_WRAP_R = 0x8072;\nexport const MAX_3D_TEXTURE_SIZE = 0x8073;\nexport const UNSIGNED_INT_2_10_10_10_REV = 0x8368;\nexport const MAX_ELEMENTS_VERTICES = 0x80E8;\nexport const MAX_ELEMENTS_INDICES = 0x80E9;\nexport const TEXTURE_MIN_LOD = 0x813A;\nexport const TEXTURE_MAX_LOD = 0x813B;\nexport const TEXTURE_BASE_LEVEL = 0x813C;\nexport const TEXTURE_MAX_LEVEL = 0x813D;\nexport const MIN = 0x8007;\nexport const MAX = 0x8008;\nexport const DEPTH_COMPONENT24 = 0x81A6;\nexport const MAX_TEXTURE_LOD_BIAS = 0x84FD;\nexport const TEXTURE_COMPARE_MODE = 0x884C;\nexport const TEXTURE_COMPARE_FUNC = 0x884D;\nexport const CURRENT_QUERY = 0x8865;\nexport const QUERY_RESULT = 0x8866;\nexport const QUERY_RESULT_AVAILABLE = 0x8867;\nexport const STREAM_READ = 0x88E1;\nexport const STREAM_COPY = 0x88E2;\nexport const STATIC_READ = 0x88E5;\nexport const STATIC_COPY = 0x88E6;\nexport const DYNAMIC_READ = 0x88E9;\nexport const DYNAMIC_COPY = 0x88EA;\nexport const MAX_DRAW_BUFFERS = 0x8824;\nexport const DRAW_BUFFER0 = 0x8825;\nexport const DRAW_BUFFER1 = 0x8826;\nexport const DRAW_BUFFER2 = 0x8827;\nexport const DRAW_BUFFER3 = 0x8828;\nexport const DRAW_BUFFER4 = 0x8829;\nexport const DRAW_BUFFER5 = 0x882A;\nexport const DRAW_BUFFER6 = 0x882B;\nexport const DRAW_BUFFER7 = 0x882C;\nexport const DRAW_BUFFER8 = 0x882D;\nexport const DRAW_BUFFER9 = 0x882E;\nexport const DRAW_BUFFER10 = 0x882F;\nexport const DRAW_BUFFER11 = 0x8830;\nexport const DRAW_BUFFER12 = 0x8831;\nexport const DRAW_BUFFER13 = 0x8832;\nexport const DRAW_BUFFER14 = 0x8833;\nexport const DRAW_BUFFER15 = 0x8834;\nexport const MAX_FRAGMENT_UNIFORM_COMPONENTS = 0x8B49;\nexport const MAX_VERTEX_UNIFORM_COMPONENTS = 0x8B4A;\nexport const SAMPLER_3D = 0x8B5F;\nexport const SAMPLER_2D_SHADOW = 0x8B62;\nexport const FRAGMENT_SHADER_DERIVATIVE_HINT = 0x8B8B;\nexport const PIXEL_PACK_BUFFER = 0x88EB;\nexport const PIXEL_UNPACK_BUFFER = 0x88EC;\nexport const PIXEL_PACK_BUFFER_BINDING = 0x88ED;\nexport const PIXEL_UNPACK_BUFFER_BINDING = 0x88EF;\nexport const FLOAT_MAT2x3 = 0x8B65;\nexport const FLOAT_MAT2x4 = 0x8B66;\nexport const FLOAT_MAT3x2 = 0x8B67;\nexport const FLOAT_MAT3x4 = 0x8B68;\nexport const FLOAT_MAT4x2 = 0x8B69;\nexport const FLOAT_MAT4x3 = 0x8B6A;\nexport const SRGB = 0x8C40;\nexport const SRGB8 = 0x8C41;\nexport const SRGB8_ALPHA8 = 0x8C43;\nexport const COMPARE_REF_TO_TEXTURE = 0x884E;\nexport const RGBA32F = 0x8814;\nexport const RGB32F = 0x8815;\nexport const RGBA16F = 0x881A;\nexport const RGB16F = 0x881B;\nexport const VERTEX_ATTRIB_ARRAY_INTEGER = 0x88FD;\nexport const MAX_ARRAY_TEXTURE_LAYERS = 0x88FF;\nexport const MIN_PROGRAM_TEXEL_OFFSET = 0x8904;\nexport const MAX_PROGRAM_TEXEL_OFFSET = 0x8905;\nexport const MAX_VARYING_COMPONENTS = 0x8B4B;\nexport const TEXTURE_2D_ARRAY = 0x8C1A;\nexport const TEXTURE_BINDING_2D_ARRAY = 0x8C1D;\nexport const R11F_G11F_B10F = 0x8C3A;\nexport const UNSIGNED_INT_10F_11F_11F_REV = 0x8C3B;\nexport const RGB9_E5 = 0x8C3D;\nexport const UNSIGNED_INT_5_9_9_9_REV = 0x8C3E;\nexport const TRANSFORM_FEEDBACK_BUFFER_MODE = 0x8C7F;\nexport const MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS = 0x8C80;\nexport const TRANSFORM_FEEDBACK_VARYINGS = 0x8C83;\nexport const TRANSFORM_FEEDBACK_BUFFER_START = 0x8C84;\nexport const TRANSFORM_FEEDBACK_BUFFER_SIZE = 0x8C85;\nexport const TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN = 0x8C88;\nexport const RASTERIZER_DISCARD = 0x8C89;\nexport const MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS = 0x8C8A;\nexport const MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS = 0x8C8B;\nexport const INTERLEAVED_ATTRIBS = 0x8C8C;\nexport const SEPARATE_ATTRIBS = 0x8C8D;\nexport const TRANSFORM_FEEDBACK_BUFFER = 0x8C8E;\nexport const TRANSFORM_FEEDBACK_BUFFER_BINDING = 0x8C8F;\nexport const RGBA32UI = 0x8D70;\nexport const RGB32UI = 0x8D71;\nexport const RGBA16UI = 0x8D76;\nexport const RGB16UI = 0x8D77;\nexport const RGBA8UI = 0x8D7C;\nexport const RGB8UI = 0x8D7D;\nexport const RGBA32I = 0x8D82;\nexport const RGB32I = 0x8D83;\nexport const RGBA16I = 0x8D88;\nexport const RGB16I = 0x8D89;\nexport const RGBA8I = 0x8D8E;\nexport const RGB8I = 0x8D8F;\nexport const RED_INTEGER = 0x8D94;\nexport const RGB_INTEGER = 0x8D98;\nexport const RGBA_INTEGER = 0x8D99;\nexport const SAMPLER_2D_ARRAY = 0x8DC1;\nexport const SAMPLER_2D_ARRAY_SHADOW = 0x8DC4;\nexport const SAMPLER_CUBE_SHADOW = 0x8DC5;\nexport const UNSIGNED_INT_VEC2 = 0x8DC6;\nexport const UNSIGNED_INT_VEC3 = 0x8DC7;\nexport const UNSIGNED_INT_VEC4 = 0x8DC8;\nexport const INT_SAMPLER_2D = 0x8DCA;\nexport const INT_SAMPLER_3D = 0x8DCB;\nexport const INT_SAMPLER_CUBE = 0x8DCC;\nexport const INT_SAMPLER_2D_ARRAY = 0x8DCF;\nexport const UNSIGNED_INT_SAMPLER_2D = 0x8DD2;\nexport const UNSIGNED_INT_SAMPLER_3D = 0x8DD3;\nexport const UNSIGNED_INT_SAMPLER_CUBE = 0x8DD4;\nexport const UNSIGNED_INT_SAMPLER_2D_ARRAY = 0x8DD7;\nexport const DEPTH_COMPONENT32F = 0x8CAC;\nexport const DEPTH32F_STENCIL8 = 0x8CAD;\nexport const FLOAT_32_UNSIGNED_INT_24_8_REV = 0x8DAD;\nexport const FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING = 0x8210;\nexport const FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE = 0x8211;\nexport const FRAMEBUFFER_ATTACHMENT_RED_SIZE = 0x8212;\nexport const FRAMEBUFFER_ATTACHMENT_GREEN_SIZE = 0x8213;\nexport const FRAMEBUFFER_ATTACHMENT_BLUE_SIZE = 0x8214;\nexport const FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE = 0x8215;\nexport const FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE = 0x8216;\nexport const FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE = 0x8217;\nexport const FRAMEBUFFER_DEFAULT = 0x8218;\nexport const UNSIGNED_INT_24_8 = 0x84FA;\nexport const DEPTH24_STENCIL8 = 0x88F0;\nexport const UNSIGNED_NORMALIZED = 0x8C17;\nexport const DRAW_FRAMEBUFFER_BINDING = 0x8CA6; /* Same as FRAMEBUFFER_BINDING */\nexport const READ_FRAMEBUFFER = 0x8CA8;\nexport const DRAW_FRAMEBUFFER = 0x8CA9;\nexport const READ_FRAMEBUFFER_BINDING = 0x8CAA;\nexport const RENDERBUFFER_SAMPLES = 0x8CAB;\nexport const FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER = 0x8CD4;\nexport const MAX_COLOR_ATTACHMENTS = 0x8CDF;\nexport const COLOR_ATTACHMENT1 = 0x8CE1;\nexport const COLOR_ATTACHMENT2 = 0x8CE2;\nexport const COLOR_ATTACHMENT3 = 0x8CE3;\nexport const COLOR_ATTACHMENT4 = 0x8CE4;\nexport const COLOR_ATTACHMENT5 = 0x8CE5;\nexport const COLOR_ATTACHMENT6 = 0x8CE6;\nexport const COLOR_ATTACHMENT7 = 0x8CE7;\nexport const COLOR_ATTACHMENT8 = 0x8CE8;\nexport const COLOR_ATTACHMENT9 = 0x8CE9;\nexport const COLOR_ATTACHMENT10 = 0x8CEA;\nexport const COLOR_ATTACHMENT11 = 0x8CEB;\nexport const COLOR_ATTACHMENT12 = 0x8CEC;\nexport const COLOR_ATTACHMENT13 = 0x8CED;\nexport const COLOR_ATTACHMENT14 = 0x8CEE;\nexport const COLOR_ATTACHMENT15 = 0x8CEF;\nexport const FRAMEBUFFER_INCOMPLETE_MULTISAMPLE = 0x8D56;\nexport const MAX_SAMPLES = 0x8D57;\nexport const HALF_FLOAT = 0x140B;\nexport const RG = 0x8227;\nexport const RG_INTEGER = 0x8228;\nexport const R8 = 0x8229;\nexport const RG8 = 0x822B;\nexport const R16F = 0x822D;\nexport const R32F = 0x822E;\nexport const RG16F = 0x822F;\nexport const RG32F = 0x8230;\nexport const R8I = 0x8231;\nexport const R8UI = 0x8232;\nexport const R16I = 0x8233;\nexport const R16UI = 0x8234;\nexport const R32I = 0x8235;\nexport const R32UI = 0x8236;\nexport const RG8I = 0x8237;\nexport const RG8UI = 0x8238;\nexport const RG16I = 0x8239;\nexport const RG16UI = 0x823A;\nexport const RG32I = 0x823B;\nexport const RG32UI = 0x823C;\nexport const VERTEX_ARRAY_BINDING = 0x85B5;\nexport const R8_SNORM = 0x8F94;\nexport const RG8_SNORM = 0x8F95;\nexport const RGB8_SNORM = 0x8F96;\nexport const RGBA8_SNORM = 0x8F97;\nexport const SIGNED_NORMALIZED = 0x8F9C;\nexport const COPY_READ_BUFFER = 0x8F36;\nexport const COPY_WRITE_BUFFER = 0x8F37;\nexport const COPY_READ_BUFFER_BINDING = 0x8F36; /* Same as COPY_READ_BUFFER */\nexport const COPY_WRITE_BUFFER_BINDING = 0x8F37; /* Same as COPY_WRITE_BUFFER */\nexport const UNIFORM_BUFFER = 0x8A11;\nexport const UNIFORM_BUFFER_BINDING = 0x8A28;\nexport const UNIFORM_BUFFER_START = 0x8A29;\nexport const UNIFORM_BUFFER_SIZE = 0x8A2A;\nexport const MAX_VERTEX_UNIFORM_BLOCKS = 0x8A2B;\nexport const MAX_FRAGMENT_UNIFORM_BLOCKS = 0x8A2D;\nexport const MAX_COMBINED_UNIFORM_BLOCKS = 0x8A2E;\nexport const MAX_UNIFORM_BUFFER_BINDINGS = 0x8A2F;\nexport const MAX_UNIFORM_BLOCK_SIZE = 0x8A30;\nexport const MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS = 0x8A31;\nexport const MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS = 0x8A33;\nexport const UNIFORM_BUFFER_OFFSET_ALIGNMENT = 0x8A34;\nexport const ACTIVE_UNIFORM_BLOCKS = 0x8A36;\nexport const UNIFORM_TYPE = 0x8A37;\nexport const UNIFORM_SIZE = 0x8A38;\nexport const UNIFORM_BLOCK_INDEX = 0x8A3A;\nexport const UNIFORM_OFFSET = 0x8A3B;\nexport const UNIFORM_ARRAY_STRIDE = 0x8A3C;\nexport const UNIFORM_MATRIX_STRIDE = 0x8A3D;\nexport const UNIFORM_IS_ROW_MAJOR = 0x8A3E;\nexport const UNIFORM_BLOCK_BINDING = 0x8A3F;\nexport const UNIFORM_BLOCK_DATA_SIZE = 0x8A40;\nexport const UNIFORM_BLOCK_ACTIVE_UNIFORMS = 0x8A42;\nexport const UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES = 0x8A43;\nexport const UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER = 0x8A44;\nexport const UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER = 0x8A46;\nexport const INVALID_INDEX = 0xFFFFFFFF;\nexport const MAX_VERTEX_OUTPUT_COMPONENTS = 0x9122;\nexport const MAX_FRAGMENT_INPUT_COMPONENTS = 0x9125;\nexport const MAX_SERVER_WAIT_TIMEOUT = 0x9111;\nexport const OBJECT_TYPE = 0x9112;\nexport const SYNC_CONDITION = 0x9113;\nexport const SYNC_STATUS = 0x9114;\nexport const SYNC_FLAGS = 0x9115;\nexport const SYNC_FENCE = 0x9116;\nexport const SYNC_GPU_COMMANDS_COMPLETE = 0x9117;\nexport const UNSIGNALED = 0x9118;\nexport const SIGNALED = 0x9119;\nexport const ALREADY_SIGNALED = 0x911A;\nexport const TIMEOUT_EXPIRED = 0x911B;\nexport const CONDITION_SATISFIED = 0x911C;\nexport const WAIT_FAILED = 0x911D;\nexport const SYNC_FLUSH_COMMANDS_BIT = 0x00000001;\nexport const VERTEX_ATTRIB_ARRAY_DIVISOR = 0x88FE;\nexport const ANY_SAMPLES_PASSED = 0x8C2F;\nexport const ANY_SAMPLES_PASSED_CONSERVATIVE = 0x8D6A;\nexport const SAMPLER_BINDING = 0x8919;\nexport const RGB10_A2UI = 0x906F;\nexport const INT_2_10_10_10_REV = 0x8D9F;\nexport const TRANSFORM_FEEDBACK = 0x8E22;\nexport const TRANSFORM_FEEDBACK_PAUSED = 0x8E23;\nexport const TRANSFORM_FEEDBACK_ACTIVE = 0x8E24;\nexport const TRANSFORM_FEEDBACK_BINDING = 0x8E25;\nexport const TEXTURE_IMMUTABLE_FORMAT = 0x912F;\nexport const MAX_ELEMENT_INDEX = 0x8D6B;\nexport const TEXTURE_IMMUTABLE_LEVELS = 0x82DF;\n\nexport const TIMEOUT_IGNORED = -1;\n\n/* WebGL-specific enums */\nexport const MAX_CLIENT_WAIT_TIMEOUT_WEBGL = 0x9247;\n\n/* WebGL extension constants */\n\n/* ANGLE_instanced_arrays  */\nexport const VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE = 0x88FE;\n\n/* EXT_blend_minmax */\nexport const MIN_EXT = 0x8007;\nexport const MAX_EXT = 0x8008;\n\n/* EXT_clip_cull_distance */\nexport const MAX_CLIP_DISTANCES_EXT = 0x0D32;\nexport const MAX_CULL_DISTANCES_EXT = 0x82F9;\nexport const MAX_COMBINED_CLIP_AND_CULL_DISTANCES_EXT = 0x82FA;\n\nexport const CLIP_DISTANCE0_EXT = 0x3000;\nexport const CLIP_DISTANCE1_EXT = 0x3001;\nexport const CLIP_DISTANCE2_EXT = 0x3002;\nexport const CLIP_DISTANCE3_EXT = 0x3003;\nexport const CLIP_DISTANCE4_EXT = 0x3004;\nexport const CLIP_DISTANCE5_EXT = 0x3005;\nexport const CLIP_DISTANCE6_EXT = 0x3006;\nexport const CLIP_DISTANCE7_EXT = 0x3007;\n\n/* EXT_color_buffer_half_float */\nexport const RGBA16F_EXT = 0x881A;\nexport const RGB16F_EXT = 0x881B;\nexport const FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE_EXT = 0x8211;\nexport const UNSIGNED_NORMALIZED_EXT = 0x8C17;\n\n/* EXT_disjoint_timer_query */\nexport const QUERY_COUNTER_BITS_EXT = 0x8864;\nexport const CURRENT_QUERY_EXT = 0x8865;\nexport const QUERY_RESULT_EXT = 0x8866;\nexport const QUERY_RESULT_AVAILABLE_EXT = 0x8867;\nexport const TIME_ELAPSED_EXT = 0x88BF;\nexport const TIMESTAMP_EXT = 0x8E28;\nexport const GPU_DISJOINT_EXT = 0x8FBB;\n\n/* EXT_disjoint_timer_query_webgl2 */\n/*\nexport const QUERY_COUNTER_BITS_EXT = 0x8864;\nexport const TIME_ELAPSED_EXT = 0x88BF;\nexport const TIMESTAMP_EXT = 0x8E28;\nexport const GPU_DISJOINT_EXT = 0x8FBB;\n*/\n\n/* EXT_sRGB */\nexport const SRGB_EXT = 0x8C40;\nexport const SRGB_ALPHA_EXT = 0x8C42;\nexport const SRGB8_ALPHA8_EXT = 0x8C43;\nexport const FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING_EXT = 0x8210;\n\n/* EXT_texture_compression_bptc */\nexport const COMPRESSED_RGBA_BPTC_UNORM_EXT = 0x8E8C;\nexport const COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT = 0x8E8D;\nexport const COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT = 0x8E8E;\nexport const COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT = 0x8E8F;\n\n/* EXT_texture_compression_rgtc */\nexport const COMPRESSED_RED_RGTC1_EXT = 0x8DBB;\nexport const COMPRESSED_SIGNED_RED_RGTC1_EXT = 0x8DBC;\nexport const COMPRESSED_RED_GREEN_RGTC2_EXT = 0x8DBD;\nexport const COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT = 0x8DBE;\n\n/* EXT_texture_filter_anisotropic */\nexport const TEXTURE_MAX_ANISOTROPY_EXT = 0x84FE;\nexport const MAX_TEXTURE_MAX_ANISOTROPY_EXT = 0x84FF;\n\n/* EXT_texture_norm16 */\nexport const R16_EXT = 0x822A;\nexport const RG16_EXT = 0x822C;\nexport const RGB16_EXT = 0x8054;\nexport const RGBA16_EXT = 0x805B;\nexport const R16_SNORM_EXT = 0x8F98;\nexport const RG16_SNORM_EXT = 0x8F99;\nexport const RGB16_SNORM_EXT = 0x8F9A;\nexport const RGBA16_SNORM_EXT = 0x8F9B;\n\n/* KHR_parallel_shader_compile */\nexport const COMPLETION_STATUS_KHR = 0x91B1;\n\n/* OES_standard_derivatives */\nexport const FRAGMENT_SHADER_DERIVATIVE_HINT_OES = 0x8B8B;\n\n/* OES_texture_half_float */\nexport const HALF_FLOAT_OES = 0x8D61;\n\n/* OES_vertex_array_object */\nexport const VERTEX_ARRAY_BINDING_OES = 0x85B5;\n\n/* OVR_multiview2 */\nexport const FRAMEBUFFER_ATTACHMENT_TEXTURE_NUM_VIEWS_OVR = 0x9630;\nexport const FRAMEBUFFER_ATTACHMENT_TEXTURE_BASE_VIEW_INDEX_OVR = 0x9632;\nexport const MAX_VIEWS_OVR = 0x9631;\nexport const FRAMEBUFFER_INCOMPLETE_VIEW_TARGETS_OVR = 0x9633;\n\n/* WEBGL_blend_equation_advanced_coherent  */\nexport const MULTIPLY = 0x9294;\nexport const SCREEN = 0x9295;\nexport const OVERLAY = 0x9296;\nexport const DARKEN = 0x9297;\nexport const LIGHTEN = 0x9298;\nexport const COLORDODGE = 0x9299;\nexport const COLORBURN = 0x929A;\nexport const HARDLIGHT = 0x929B;\nexport const SOFTLIGHT = 0x929C;\nexport const DIFFERENCE = 0x929E;\nexport const EXCLUSION = 0x92A0;\nexport const HSL_HUE = 0x92AD;\nexport const HSL_SATURATION = 0x92AE;\nexport const HSL_COLOR = 0x92AF;\nexport const HSL_LUMINOSITY = 0x92B0;\n\n/* WEBGL_color_buffer_float */\nexport const RGBA32F_EXT = 0x8814;\n/*\nexport const FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE_EXT = 0x8211;\nexport const UNSIGNED_NORMALIZED_EXT = 0x8C17;\n*/\n\n/* WEBGL_compressed_texture_astc */\n/* Compressed Texture Format */\nexport const COMPRESSED_RGBA_ASTC_4x4_KHR = 0x93B0;\nexport const COMPRESSED_RGBA_ASTC_5x4_KHR = 0x93B1;\nexport const COMPRESSED_RGBA_ASTC_5x5_KHR = 0x93B2;\nexport const COMPRESSED_RGBA_ASTC_6x5_KHR = 0x93B3;\nexport const COMPRESSED_RGBA_ASTC_6x6_KHR = 0x93B4;\nexport const COMPRESSED_RGBA_ASTC_8x5_KHR = 0x93B5;\nexport const COMPRESSED_RGBA_ASTC_8x6_KHR = 0x93B6;\nexport const COMPRESSED_RGBA_ASTC_8x8_KHR = 0x93B7;\nexport const COMPRESSED_RGBA_ASTC_10x5_KHR = 0x93B8;\nexport const COMPRESSED_RGBA_ASTC_10x6_KHR = 0x93B9;\nexport const COMPRESSED_RGBA_ASTC_10x8_KHR = 0x93BA;\nexport const COMPRESSED_RGBA_ASTC_10x10_KHR = 0x93BB;\nexport const COMPRESSED_RGBA_ASTC_12x10_KHR = 0x93BC;\nexport const COMPRESSED_RGBA_ASTC_12x12_KHR = 0x93BD;\n\nexport const COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR = 0x93D0;\nexport const COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR = 0x93D1;\nexport const COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR = 0x93D2;\nexport const COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR = 0x93D3;\nexport const COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR = 0x93D4;\nexport const COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR = 0x93D5;\nexport const COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR = 0x93D6;\nexport const COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR = 0x93D7;\nexport const COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR = 0x93D8;\nexport const COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR = 0x93D9;\nexport const COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR = 0x93DA;\nexport const COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR = 0x93DB;\nexport const COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR = 0x93DC;\nexport const COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR = 0x93DD;\n\n/* WEBGL_compressed_texture_etc */\n/* Compressed Texture Formats */\nexport const COMPRESSED_R11_EAC = 0x9270;\nexport const COMPRESSED_SIGNED_R11_EAC = 0x9271;\nexport const COMPRESSED_RG11_EAC = 0x9272;\nexport const COMPRESSED_SIGNED_RG11_EAC = 0x9273;\nexport const COMPRESSED_RGB8_ETC2 = 0x9274;\nexport const COMPRESSED_SRGB8_ETC2 = 0x9275;\nexport const COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 0x9276;\nexport const COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 0x9277;\nexport const COMPRESSED_RGBA8_ETC2_EAC = 0x9278;\nexport const COMPRESSED_SRGB8_ALPHA8_ETC2_EAC = 0x9279;\n\n/* WEBGL_compressed_texture_etc1 */\n/* Compressed Texture Format */\nexport const COMPRESSED_RGB_ETC1_WEBGL = 0x8D64;\n\n/* WEBGL_compressed_texture_pvrtc */\n/* Compressed Texture Formats */\nexport const COMPRESSED_RGB_PVRTC_4BPPV1_IMG = 0x8C00;\nexport const COMPRESSED_RGB_PVRTC_2BPPV1_IMG = 0x8C01;\nexport const COMPRESSED_RGBA_PVRTC_4BPPV1_IMG = 0x8C02;\nexport const COMPRESSED_RGBA_PVRTC_2BPPV1_IMG = 0x8C03;\n\n/* WEBGL_compressed_texture_s3tc */\n/* Compressed Texture Formats */\nexport const COMPRESSED_RGB_S3TC_DXT1_EXT = 0x83F0;\nexport const COMPRESSED_RGBA_S3TC_DXT1_EXT = 0x83F1;\nexport const COMPRESSED_RGBA_S3TC_DXT3_EXT = 0x83F2;\nexport const COMPRESSED_RGBA_S3TC_DXT5_EXT = 0x83F3;\n\n/* WEBGL_compressed_texture_s3tc_srgb */\n/* Compressed Texture Formats */\nexport const COMPRESSED_SRGB_S3TC_DXT1_EXT = 0x8C4C;\nexport const COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT = 0x8C4D;\nexport const COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT = 0x8C4E;\nexport const COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT = 0x8C4F;\n\n/* WEBGL_debug_renderer_info */\nexport const UNMASKED_VENDOR_WEBGL = 0x9245;\nexport const UNMASKED_RENDERER_WEBGL = 0x9246;\n\n/* WEBGL_depth_texture */\nexport const UNSIGNED_INT_24_8_WEBGL = 0x84FA;\n\n/* WEBGL_draw_buffers */\nexport const COLOR_ATTACHMENT0_WEBGL = 0x8CE0;\nexport const COLOR_ATTACHMENT1_WEBGL = 0x8CE1;\nexport const COLOR_ATTACHMENT2_WEBGL = 0x8CE2;\nexport const COLOR_ATTACHMENT3_WEBGL = 0x8CE3;\nexport const COLOR_ATTACHMENT4_WEBGL = 0x8CE4;\nexport const COLOR_ATTACHMENT5_WEBGL = 0x8CE5;\nexport const COLOR_ATTACHMENT6_WEBGL = 0x8CE6;\nexport const COLOR_ATTACHMENT7_WEBGL = 0x8CE7;\nexport const COLOR_ATTACHMENT8_WEBGL = 0x8CE8;\nexport const COLOR_ATTACHMENT9_WEBGL = 0x8CE9;\nexport const COLOR_ATTACHMENT10_WEBGL = 0x8CEA;\nexport const COLOR_ATTACHMENT11_WEBGL = 0x8CEB;\nexport const COLOR_ATTACHMENT12_WEBGL = 0x8CEC;\nexport const COLOR_ATTACHMENT13_WEBGL = 0x8CED;\nexport const COLOR_ATTACHMENT14_WEBGL = 0x8CEE;\nexport const COLOR_ATTACHMENT15_WEBGL = 0x8CEF;\n\nexport const DRAW_BUFFER0_WEBGL = 0x8825;\nexport const DRAW_BUFFER1_WEBGL = 0x8826;\nexport const DRAW_BUFFER2_WEBGL = 0x8827;\nexport const DRAW_BUFFER3_WEBGL = 0x8828;\nexport const DRAW_BUFFER4_WEBGL = 0x8829;\nexport const DRAW_BUFFER5_WEBGL = 0x882A;\nexport const DRAW_BUFFER6_WEBGL = 0x882B;\nexport const DRAW_BUFFER7_WEBGL = 0x882C;\nexport const DRAW_BUFFER8_WEBGL = 0x882D;\nexport const DRAW_BUFFER9_WEBGL = 0x882E;\nexport const DRAW_BUFFER10_WEBGL = 0x882F;\nexport const DRAW_BUFFER11_WEBGL = 0x8830;\nexport const DRAW_BUFFER12_WEBGL = 0x8831;\nexport const DRAW_BUFFER13_WEBGL = 0x8832;\nexport const DRAW_BUFFER14_WEBGL = 0x8833;\nexport const DRAW_BUFFER15_WEBGL = 0x8834;\n\nexport const MAX_COLOR_ATTACHMENTS_WEBGL = 0x8CDF;\nexport const MAX_DRAW_BUFFERS_WEBGL = 0x8824;\n","import * as GLenum from './gl-const';\n\n/**\n * Buffer usage.\n * @see https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/bindBuffer\n * @see https://www.w3.org/TR/webgpu/#buffer-usage\n */\nexport enum BufferUsage {\n  /** Index buffer */\n  Index = 0x0010,\n\n  /** Vertex buffer */\n  Vertex = 0x0020,\n\n  /** Uniform buffer */\n  Uniform = 0x0040,\n\n  /** Data is updated infrequently */\n  Dynamic = 0x1000,\n\n  /** Data is overwritten each frame */\n  Stream = 0x2000,\n}\n\n/**\n * Texture usage.\n * @see https://www.w3.org/TR/webgpu/#typedefdef-gputextureusageflags\n */\nexport enum TextureUsage {\n  /** Use as texture binding */\n  TextureBinding = 0x04,\n\n  /** Use as render target */\n  RenderAttachment = 0x10,\n}\n\n/**\n * A color write mask.\n * @see https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/colorMask\n * @see https://www.w3.org/TR/webgpu/#typedefdef-gpucolorwriteflags\n */\nexport enum ColorWrite {\n  Red = 0x1,\n  Green = 0x2,\n  Blue = 0x4,\n  Alpha = 0x8,\n  All = 0xF,\n}\n\n/**\n * Texture view dimension type.\n * @see https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/texImage2D\n * @see https://www.w3.org/TR/webgpu/#enumdef-gputextureviewdimension\n */\nexport enum TextureDimension {\n  /** 2D texture */\n  D2 = GLenum.TEXTURE_2D,\n\n  /** 2D array texture. */\n  D2Array = GLenum.TEXTURE_2D_ARRAY,\n\n  /** Cube map texture */\n  CubeMap = GLenum.TEXTURE_CUBE_MAP,\n\n  /** 3D texture. */\n  D3 = GLenum.TEXTURE_3D,\n}\n\n/**\n * Texture format.\n * @see https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/texImage2D\n * @see https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/renderbufferStorage\n * @see https://www.w3.org/TR/webgpu/#texture-formats\n */\nexport enum TextureFormat {\n  // 8-bit formats\n  R8 = GLenum.R8,\n  R8SNORM = GLenum.R8_SNORM,\n  R8UI = GLenum.R8UI,\n  R8I = GLenum.R8I,\n\n  // 16-bit formats\n  R16UI = GLenum.R16UI,\n  R16I = GLenum.R16I,\n  RG8 = GLenum.RG8,\n  RG8SNORM = GLenum.RG8_SNORM,\n  RG8UI = GLenum.RG8UI,\n  RG8I = GLenum.RG8I,\n\n  // 32-bit formats\n  R32UI = GLenum.R32UI,\n  R32I = GLenum.R32I,\n  RG16UI = GLenum.RG16UI,\n  RG16I = GLenum.RG16I,\n  RGBA8 = GLenum.RGBA8,\n  SRGBA8 = GLenum.SRGB8_ALPHA8,\n  RGBA8SNORM = GLenum.RGBA8_SNORM,\n  RGBA8UI = GLenum.RGBA8UI,\n  RGBA8I = GLenum.RGBA8I,\n  // Packed 32-bit formats\n  RGB10A2 = GLenum.RGB10_A2,\n\n  // 64-bit formats\n  RG32UI = GLenum.RG32UI,\n  RG32I = GLenum.RG32I,\n  RGBA16UI = GLenum.RGBA16UI,\n  RGBA16I = GLenum.RGBA16I,\n\n  // 128-bit formats\n  RGBA32UI = GLenum.RGBA32UI,\n  RGBA32I = GLenum.RGBA32I,\n\n  // Float formats. Requires EXT_color_buffer_float\n  R16F = GLenum.R16F,\n  RG16F = GLenum.RG16F,\n  RG11B10F = GLenum.R11F_G11F_B10F,\n  RGBA16F = GLenum.RGBA16F,\n  R32F = GLenum.R32F,\n  RG32F = GLenum.RG32F,\n  RGBA32F = GLenum.RGBA32F,\n\n  // TODO: support BC / ETC2 / ASTC compressed formats\n\n  // Depth/stencil formats\n  Depth16 = GLenum.DEPTH_COMPONENT16,\n  Depth24 = GLenum.DEPTH_COMPONENT24,\n  Depth24Stencil8 = GLenum.DEPTH24_STENCIL8,\n  Depth32F = GLenum.DEPTH_COMPONENT32F,\n  Depth32FStencil8 = GLenum.DEPTH32F_STENCIL8,\n}\n\n/**\n * Texture addressing wrap mode (aka UV wrap).\n * @see https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/getTexParameter\n * @see https://www.w3.org/TR/webgpu/#enumdef-gpuaddressmode\n */\nexport enum AddressMode {\n  /** Clamp texture coords to (0.0 .. 1.0) */\n  ClampToEdge = GLenum.CLAMP_TO_EDGE,\n\n  /** Repeat texture coords within (0.0 .. 1.0) */\n  Repeat = GLenum.REPEAT,\n\n  /** Mirror-repeat texture coords (0.0 .. 1.0 .. 0.0) */\n  MirrorRepeat = GLenum.MIRRORED_REPEAT,\n}\n\n/**\n * Texture sampler filter mode.\n * @see https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/getTexParameter\n * @see https://www.w3.org/TR/webgpu/#enumdef-gpufiltermode\n */\nexport enum FilterMode {\n  /** use nearest-filtering (aka point-filtering) */\n  Nearest = GLenum.NEAREST,\n\n  /** use linear filtering */\n  Linear = GLenum.LINEAR,\n}\n\n/**\n * Comparision functions for depth and stencil checks.\n * @see https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/depthFunc\n * @see https://www.w3.org/TR/webgpu/#enumdef-gpucomparefunction\n */\nexport enum CompareFunction {\n  /** new value never passes comparion test */\n  Never = GLenum.NEVER,\n\n  /** new value passses if it is less than the existing value */\n  Less = GLenum.LESS,\n\n  /** new value passes if it is equal to existing value */\n  Equal = GLenum.EQUAL,\n\n  /** new value passes if it is less than or equal to existing value */\n  LessEqual = GLenum.LEQUAL,\n\n  /** new value passes if it is greater than existing value */\n  Greater = GLenum.GREATER,\n\n  /** new value passes if it is not equal to existing value */\n  NotEqual = GLenum.NOTEQUAL,\n\n  /** new value passes if it is greater than or equal to existing value */\n  GreaterEqual = GLenum.GEQUAL,\n\n  /** new value always passes */\n  Always = GLenum.ALWAYS\n}\n\n/**\n * Shader stage\n * @see https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/createShader\n */\nexport enum ShaderStage {\n  /** Vertex shader */\n  Vertex = 0x01,\n\n  /** Fragment shader */\n  Fragment = 0x02\n}\n\n/**\n * Primitive topology.\n * @see https://www.w3.org/TR/webgpu/#enumdef-gpuprimitivetopology\n * @see https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/drawElements\n */\nexport enum PrimitiveTopology {\n  /** Point list */\n  Points = GLenum.POINTS,\n\n  /** Line list */\n  Lines = GLenum.LINES,\n\n  /** Line strip */\n  LineStrip = GLenum.LINE_STRIP,\n\n  /** Triangle list */\n  Triangles = GLenum.TRIANGLES,\n\n  /** Triangle strip */\n  TriangleStrip = GLenum.TRIANGLE_STRIP\n}\n\n/**\n * Vertex index formats.\n * @see https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/drawElements\n * @see https://www.w3.org/TR/webgpu/#enumdef-gpuindexformat\n */\nexport enum IndexFormat {\n  /** 16-bit indices */\n  UInt16 = GLenum.UNSIGNED_SHORT,\n\n  /** 32-bit indices. */\n  UInt32 = GLenum.UNSIGNED_INT\n}\n\n/**\n * Identify which side is the front face by setting a winding orientation.\n * @see https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/frontFace\n * @see https://www.w3.org/TR/webgpu/#enumdef-gpufrontface\n */\nexport enum FrontFace {\n  /** Counter-clockwise winding. */\n  CCW = GLenum.CCW,\n\n  /** Clockwise winding. */\n  CW = GLenum.CW\n}\n\n/**\n * Specify the face to cull.\n * @see https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/cullFace\n * @see https://www.w3.org/TR/webgpu/#enumdef-gpucullmode\n */\nexport enum CullMode {\n  /** Disable culling */\n  None = GLenum.NONE,\n\n  /** Cull front face */\n  Front = GLenum.FRONT,\n\n  /** Cull back face */\n  Back = GLenum.BACK\n}\n\n/**\n * Stencil-buffer operation.\n * @see https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/stencilOpSeparate\n * @see https://www.w3.org/TR/webgpu/#enumdef-gpustenciloperation\n */\nexport enum StencilOperation {\n  /** keep the current stencil value */\n  Keep = GLenum.KEEP,\n\n  /** set the stencil value to zero */\n  Zero = GLenum.ZERO,\n\n  /** replace the stencil value with stencil reference value */\n  Replace = GLenum.REPLACE,\n\n  /** perform a logical bitwise invert operation on the stencil value */\n  Invert = GLenum.INVERT,\n\n  /** increment the current stencil value, clamp to max */\n  Increment = GLenum.INCR,\n\n  /** decrement the current stencil value, clamp to zero */\n  Decrement = GLenum.DECR,\n\n  /** increment the current stencil value, with wrap-around */\n  IncrementWrap = GLenum.INCR_WRAP,\n\n  /** decrement the current stencil value, with wrap-around */\n  DecrementWrap = GLenum.DECR_WRAP\n}\n\n/**\n * Alpha-blending factors.\n * @see https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/blendFunc\n * @see https://www.w3.org/TR/webgpu/#enumdef-gpublendfactor\n */\nexport enum BlendFactor {\n  /** blend factor of zero */\n  Zero = GLenum.ZERO,\n\n  /** blend factor of one */\n  One = GLenum.ONE,\n\n  /** blend factor of source color */\n  Src = GLenum.SRC_COLOR,\n\n  /** blend factor of one minus source color */\n  OneMinusSrc = GLenum.ONE_MINUS_SRC_COLOR,\n\n  /** blend factor of source alpha */\n  SrcAlpha = GLenum.SRC_ALPHA,\n\n  /** blend factor of one minus source alpha */\n  OneMinusSrcAlpha = GLenum.ONE_MINUS_SRC_ALPHA,\n\n  /** blend factor of destination color */\n  Dst = GLenum.DST_COLOR,\n\n  /** blend factor of one minus destination alpha */\n  OneMinusDst = GLenum.ONE_MINUS_DST_COLOR,\n\n  /** blend factor of destination alpha */\n  DstAlpha = GLenum.DST_ALPHA,\n\n  /** blend factor of one minus destination alpha */\n  OneMinusDstAlpha = GLenum.ONE_MINUS_DST_ALPHA,\n\n  /** blend factor of the minimum of either source alpha or one minus destination alpha */\n  SrcAlphaSaturated = GLenum.SRC_ALPHA_SATURATE,\n\n  /** blend factor of constant color */\n  Constant = GLenum.CONSTANT_COLOR,\n\n  /** blend factor of one minus constant color */\n  OneMinusConstant = GLenum.ONE_MINUS_CONSTANT_COLOR\n}\n\n/**\n * Blend operation.\n * @see https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/blendEquation\n * @see https://www.w3.org/TR/webgpu/#enumdef-gpublendoperation\n */\nexport enum BlendOperation {\n  /** Add source and destination pixel values */\n  Add = GLenum.FUNC_ADD,\n\n  /** Subtract destination from source pixel values */\n  Subtract = GLenum.FUNC_SUBTRACT,\n\n  /** Subtract source from destination pixel values */\n  ReverseSubtract = GLenum.FUNC_REVERSE_SUBTRACT,\n\n  /** The minimum of the source and destination pixel values. */\n  Min = GLenum.MIN,\n\n  /** The maximum of the source and destination pixel values. */\n  Max = GLenum.MAX\n}\n\n/// Vertex step mode.\n/// @see https://www.w3.org/TR/webgpu/#enumdef-gpuvertexstepmode\nexport enum VertexStepMode {\n  /** Per vertex */\n  Vertex = 0,\n\n  /** Instanced */\n  Instance = 1,\n}\n\n/**\n * Vertex component format.\n * Enum values encode the properties of the formats:\n * - bits 0-3 encodes the number of components (1, 2, 3 or 4)\n * - bits 4-7 encodes the number of bytes per component (1, 2 or 4)\n * - bits 8-11 encodes the data type (1 = int, 2 = float)\n * - bits 12-13 encodes the signedness and normalization for int (0 = unsigned, 1 = signed, 2 = unsigned normalized, 3 = signed normalized)\n * @see https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/vertexAttribPointer\n * @see https://www.w3.org/TR/webgpu/#enumdef-gpuvertexformat\n */\nexport enum VertexFormat {\n  UI8x2 = 0x01_1_2,\n  UI8x4 = 0x01_1_4,\n  I8x2 = 0x11_1_2,\n  I8x4 = 0x11_1_4,\n  UNORM8x2 = 0x21_1_2,\n  UNORM8x4 = 0x21_1_4,\n  SNORM8x2 = 0x31_1_2,\n  SNORM8x4 = 0x31_1_4,\n\n  UI16x2 = 0x01_2_2,\n  UI16x4 = 0x01_2_4,\n  I16x2 = 0x11_2_2,\n  I16x4 = 0x11_2_4,\n  UNORM16x2 = 0x21_2_2,\n  UNORM16x4 = 0x21_2_4,\n  SNORM16x2 = 0x31_2_2,\n  SNORM16x4 = 0x31_2_4,\n\n  F16x2 = 0x02_2_2,\n  F16x4 = 0x02_2_4,\n  F32 = 0x02_4_1,\n  F32x2 = 0x02_4_2,\n  F32x3 = 0x02_4_3,\n  F32x4 = 0x02_4_4,\n}\n\n/**\n * Binding type.\n */\nexport enum BindingType {\n  /** Uniform buffer type */\n  Buffer = 0x0,\n\n  /** Sampler type */\n  Sampler = 0x1,\n\n  /** Texture type */\n  Texture = 0x2,\n}\n\n/**\n * Sampler binding type.\n */\nexport enum SamplerBindingType {\n  Filtering = 0x0,\n\n  NonFiltering = 0x1,\n\n  Comparison = 0x2,\n}\n\n/**\n * Texture sample type\n */\nexport enum TextureSampleType {\n  Float = 0x0,\n\n  Depth = 0x1,\n\n  Int = 0x2,\n\n  UInt = 0x3,\n\n  UnfilterableFloat = 0x4,\n}\n\n/**\n * Cube map face.\n * @see https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/texImage2D\n */\nexport enum CubeMapFace {\n  /** Positive X face */\n  X = /* GLenum.TEXTURE_CUBE_MAP_POSITIVE_X + */ 0,\n\n  /** Negative X face */\n  NegativeX = 1,\n\n  /** Positive Y face */\n  Y = 2,\n\n  /** Negative Y face */\n  NegativeY = 3,\n\n  /** Positive Z face */\n  Z = 4,\n\n  /** Negative Z face */\n  NegativeZ = 5\n}\n\n/**\n * Hint for mipmap generation.\n * @see https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/hint\n */\nexport enum MipmapHint {\n  /** The most efficient option should be chosen. */\n  Fast = GLenum.FASTEST,\n\n  /** The most correct, or highest quality, option should be chosen. */\n  Nice = GLenum.NICEST\n}\n","import { DeviceId, BufferId, TextureId, SamplerId, ShaderId, BindGroupLayoutId, BindGroupId, RenderPipelineId, RenderPassId, createBuffer, deleteDevice, deleteBuffer, deleteTexture, deleteShader, createShader, createSampler, deleteSampler, deleteBindGroupLayout, createBindGroupLayout, deleteBindGroup, createBindGroup, createRenderPass, deleteRenderPass, createRenderPipeline, deleteRenderPipeline } from '../mugl';\nimport { BindGroupDescriptor, BindGroupLayoutDescriptor, BufferDescriptor, ColorTargetStates, DepthStencilState, RenderPassDescriptor, RenderPipelineDescriptor, SamplerDescriptor, ShaderDescriptor } from './descriptor';\nimport { BindingType } from './type';\n\nconst BIND_GROUP_LAYOUT_ENTRY_SIZE = 32;\nconst BIND_GROUP_ENTRY_SIZE = 24;\nconst VERTEX_ATTRIBUTE_SIZE = 12;\nconst VERTEX_BUFFER_LAYOUT_SIZE = 16;\nconst COLOR_TARGET_STATE_SIZE = 32;\nconst COLOR_ATTACHMENT_SIZE = 32;\n\n/**\n * A resource that can be destroyed.\n */\nexport abstract class Resource {\n  /**\n   * Destroy the resource.\n   */\n  public abstract destroy(): void;\n}\n\n/**\n * A GPU device resource.\n */\nexport class Device extends Resource {\n  public id: DeviceId;\n\n  public constructor(id: DeviceId) {\n    super();\n    this.id = id;\n  }\n\n  public destroy(): void {\n    deleteDevice(this.id);\n  }\n}\n\n/**\n * A GPU buffer resource.\n */\nexport class Buffer extends Resource {\n  public readonly id: BufferId;\n\n  public constructor(device: Device, desc: BufferDescriptor) {\n    super();\n    this.id = createBuffer(device.id, desc.size, desc.usage);\n  }\n\n  public destroy(): void {\n    deleteBuffer(this.id);\n  }\n}\n\n/**\n * A GPU texture resource.\n */\nexport class Texture extends Resource {\n  public readonly id: TextureId;\n\n  public constructor(id: TextureId) {\n    super();\n    this.id = id;\n  }\n\n  public destroy(): void {\n    deleteTexture(this.id);\n  }\n}\n\n/**\n * A GPU texture sampler resource.\n */\nexport class Sampler extends Resource {\n  public readonly id: SamplerId;\n\n  public constructor(device: Device, desc: SamplerDescriptor) {\n    super();\n    this.id = createSampler(\n      device.id,\n      desc.addressModeU, desc.addressModeV, desc.addressModeW,\n      desc.magFilter, desc.minFilter, desc.mipmapFilter,\n      desc.lodMinClamp, desc.lodMaxClamp,\n      desc.compare,\n      desc.maxAnisotropy\n    );\n  }\n\n  public destroy(): void {\n    deleteSampler(this.id);\n  }\n}\n\n/**\n * A GPU shader object.\n */\nexport class Shader extends Resource {\n  public readonly id: ShaderId;\n\n  public constructor(device: Device, desc: ShaderDescriptor) {\n    super();\n    const code = String.UTF8.encode(desc.code);\n    this.id = createShader(device.id, changetype<usize>(code), code.byteLength, desc.usage);\n  }\n\n  public destroy(): void {\n    deleteShader(this.id);\n  }\n}\n\n/**\n * A GPU bind group layout object.\n */\nexport class BindGroupLayout extends Resource {\n  public readonly id: BindGroupLayoutId;\n\n  public constructor(device: Device, desc: BindGroupLayoutDescriptor) {\n    super();\n    const len = desc.entries.length;\n    const entries = new ArrayBuffer(BIND_GROUP_LAYOUT_ENTRY_SIZE * len);\n    const entriesPtr = changetype<usize>(entries);\n    for (let i = 0; i < len; ++i) {\n      const base = entriesPtr + BIND_GROUP_LAYOUT_ENTRY_SIZE * i;\n      const entry = desc.entries[i];\n      // TODO: use a slice into a concatenated label string instead\n      const label = String.UTF8.encode(entry.label);\n      store<u32>(base, changetype<u32>(label), 0);\n      store<u32>(base, label.byteLength, 4);\n      // TODO: set default binding slot to i\n      store<u32>(base, entry.binding, 8);\n      store<u32>(base, entry.visibility, 12);\n      store<u32>(base, entry.type, 16);\n      switch (entry.type) {\n        case BindingType.Buffer:\n          store<u8>(base, entry.bufferDynamicOffset ? 1 : 0, 20);\n          break;\n        case BindingType.Sampler:\n          store<u32>(base, entry.samplerType, 20);\n          break;\n        case BindingType.Texture:\n          store<u32>(base, entry.textureSampleType, 20);\n          store<u32>(base, entry.textureDimension, 24);\n          store<u8>(base, entry.textureMultisampled ? 1 : 0, 28);\n          break;\n        default:\n          throw new RangeError('invalid value for BindingType');\n      }\n    }\n    this.id = createBindGroupLayout(device.id, entriesPtr, len);\n  }\n\n  public destroy(): void {\n    deleteBindGroupLayout(this.id);\n  }\n}\n\n/**\n * A GPU bind group object.\n */\nexport class BindGroup extends Resource {\n  public readonly id: BindGroupId;\n\n  public constructor(device: Device, desc: BindGroupDescriptor) {\n    super();\n    const len = desc.entries.length;\n    const entries = new ArrayBuffer(BIND_GROUP_ENTRY_SIZE * len);\n    const entriesPtr = changetype<usize>(entries);\n    for (let i = 0; i < len; ++i) {\n      const base = entriesPtr + BIND_GROUP_ENTRY_SIZE * i;\n      const entry = desc.entries[i];\n      // TODO: set default binding slot to i\n      store<u32>(base, entry.binding, 0);\n      if (entry.buffer) {\n        store<u32>(base, BindingType.Buffer, 4);\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        store<BufferId>(base, entry.buffer!.id, 8);\n        store<u32>(base, entry.bufferOffset, 16);\n        store<u32>(base, entry.bufferSize, 20);\n      } else if (entry.sampler) {\n        store<u32>(base, BindingType.Sampler, 4);\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        store<SamplerId>(base, entry.sampler!.id, 8);\n      } else if (entry.texture) {\n        store<u32>(base, BindingType.Texture, 4);\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        store<TextureId>(base, entry.texture!.id, 8);\n      } else {\n        throw new TypeError('one of buffer, sampler, texture must be specified for BindGroupEntry');\n      }\n    }\n    this.id = createBindGroup(device.id, desc.layout.id, entriesPtr, len);\n  }\n\n  public destroy(): void {\n    deleteBindGroup(this.id);\n  }\n}\n\n/**\n * A GPU render pipeline object.\n */\nexport class RenderPipeline extends Resource {\n  public readonly id: RenderPipelineId;\n\n  public constructor(device: Device, desc: RenderPipelineDescriptor) {\n    super();\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const depthStecil: DepthStencilState = desc.depthStencil ? desc.depthStencil! : {} as DepthStencilState;\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const targets: ColorTargetStates = desc.targets ? desc.targets! : {} as ColorTargetStates;\n\n    const buffersLen = desc.buffers.length;\n    let attributesLen = 0;\n    for (let i = 0; i < buffersLen; ++i) {\n      attributesLen += desc.buffers[i].attributes.length;\n    }\n    const attributes = new ArrayBuffer(VERTEX_ATTRIBUTE_SIZE * attributesLen);\n    const buffers = new ArrayBuffer(VERTEX_BUFFER_LAYOUT_SIZE * buffersLen);\n    for (let i = 0, j = 0; i < buffersLen; ++i) {\n      const base = changetype<usize>(buffers) + VERTEX_BUFFER_LAYOUT_SIZE * i;\n      const buffer = desc.buffers[i];\n      store<u32>(base, j, 0);\n      store<u32>(base, buffer.attributes.length, 4);\n      store<u32>(base, buffer.stride, 8);\n      store<u32>(base, buffer.stepMode, 12);\n\n      for (let k = 0; k < buffer.attributes.length; ++k) {\n        const attrBase = changetype<usize>(attributes) + VERTEX_ATTRIBUTE_SIZE * (j + k);\n        const attribute = buffer.attributes[k];\n        store<u32>(attrBase, attribute.format, 0);\n        store<u32>(attrBase, attribute.offset, 4);\n        store<u32>(attrBase, attribute.shaderLocation, 8);\n      }\n\n      j += buffer.attributes.length;\n    }\n\n    const bindGroupsLen = desc.bindGroups.length;\n    const bindGroups = new ArrayBuffer(8 * bindGroupsLen);\n    for (let i = 0; i < bindGroupsLen; ++i) {\n      store<BindGroupId>(changetype<usize>(bindGroups) + 8 * i, desc.bindGroups[i].id, 0);\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const colorsLen = targets.targets ? targets.targets!.length : 0;\n    const colors = new ArrayBuffer(COLOR_TARGET_STATE_SIZE * colorsLen);\n    for (let i = 0; i < colorsLen; ++i) {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      const target = targets.targets![i];\n      const base = changetype<usize>(colors) + COLOR_TARGET_STATE_SIZE * i;\n      store<u32>(base, target.format, 0);\n      store<u32>(base, target.writeMask, 4);\n      store<u32>(base, target.blendColor.operation, 8);\n      store<u32>(base, target.blendColor.srcFactor, 12);\n      store<u32>(base, target.blendColor.dstFactor, 16);\n      store<u32>(base, target.blendAlpha.operation, 20);\n      store<u32>(base, target.blendAlpha.srcFactor, 24);\n      store<u32>(base, target.blendAlpha.dstFactor, 28);\n    }\n\n    const vertexEntryPoint = String.UTF8.encode(desc.vertexEntryPoint);\n    const fragmentEntryPoint = String.UTF8.encode(desc.fragmentEntryPoint);\n\n    this.id = createRenderPipeline(\n      device.id,\n      desc.vertex.id, desc.fragment.id,\n      changetype<usize>(attributes), attributesLen,\n      changetype<usize>(buffers), buffersLen,\n      changetype<usize>(bindGroups), bindGroupsLen,\n      desc.primitive.topology, desc.primitive.indexFormat, desc.primitive.frontFace, desc.primitive.cullMode,\n      desc.multisample.sampleCount, desc.multisample.alphaToCoverage,\n      !!desc.depthStencil, depthStecil.format, depthStecil.depthWrite, depthStecil.depthCompare,\n      depthStecil.stencilFront.compare, depthStecil.stencilFront.failOp, depthStecil.stencilFront.depthFailOp, depthStecil.stencilFront.passOp,\n      depthStecil.stencilBack.compare, depthStecil.stencilBack.failOp, depthStecil.stencilBack.depthFailOp, depthStecil.stencilBack.passOp,\n      depthStecil.stencilReadMask, depthStecil.stencilWriteMask, depthStecil.depthBias, depthStecil.depthBiasSlopeScale, depthStecil.depthBiasClamp,\n      changetype<usize>(colors), colorsLen,\n      targets.writeMask,\n      targets.blendColor.operation, targets.blendColor.srcFactor, targets.blendColor.dstFactor,\n      targets.blendAlpha.operation, targets.blendAlpha.srcFactor, targets.blendAlpha.dstFactor,\n      changetype<usize>(vertexEntryPoint), vertexEntryPoint.byteLength, changetype<usize>(fragmentEntryPoint), fragmentEntryPoint.byteLength,\n    );\n  }\n\n  public destroy(): void {\n    deleteRenderPipeline(this.id);\n  }\n}\n\n/**\n * A GPU render pass object.\n */\nexport class RenderPass extends Resource {\n  public readonly id: RenderPassId;\n\n  public constructor(device: Device, desc: RenderPassDescriptor) {\n    super();\n\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const len = desc.colors ? desc.colors!.length : 0;\n    const colors = new ArrayBuffer(COLOR_ATTACHMENT_SIZE * len);\n    for (let i = 0; i < len; ++i) {\n      const base = changetype<usize>(colors) + COLOR_ATTACHMENT_SIZE * i;\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      const color = desc.colors![i];\n      store<TextureId>(base, color.view.texture.id, 0);\n      store<u32>(base, color.view.mipLevel, 8);\n      store<u32>(base, color.view.slice, 12);\n\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      const clearColor = color.clear ? color.clear! : [NaN, NaN, NaN, NaN];\n      store<f32>(base, clearColor[0], 16);\n      store<f32>(base, clearColor[1], 20);\n      store<f32>(base, clearColor[2], 24);\n      store<f32>(base, clearColor[3], 28);\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const clearColor = desc.clearColor ? desc.clearColor! : [NaN, NaN, NaN, NaN];\n\n    this.id = createRenderPass(\n      device.id,\n      desc.clearDepth, desc.clearStencil,\n      clearColor[0], clearColor[1], clearColor[2], clearColor[3],\n      !!desc.colors,\n      /* eslint-disable @typescript-eslint/no-non-null-assertion */\n      desc.depthStencil ? desc.depthStencil!.texture.id : 0,\n      desc.depthStencil ? desc.depthStencil!.mipLevel : 0,\n      desc.depthStencil ? desc.depthStencil!.slice : 0,\n      /* eslint-enable @typescript-eslint/no-non-null-assertion */\n      changetype<usize>(colors), len\n    );\n  }\n\n  public destroy(): void {\n    deleteRenderPass(this.id);\n  }\n}\n","const EXT_texture_filter_anisotropic = 0x1;\nconst OES_texture_half_float_linear = 0x2;\nconst OES_texture_float_linear = 0x4;\nconst EXT_color_buffer_float = 0x8;\nconst OES_draw_buffers_indexed = 0x10;\n\n\n/** Supported WebGL2 features. */\nexport enum WebGL2Feature {\n  TextureAnisotropic = EXT_texture_filter_anisotropic,\n  TextureHalfFloatLinear = OES_texture_half_float_linear,\n  TextureFloatLinear = OES_texture_float_linear,\n  ColorBufferFloat = EXT_color_buffer_float,\n  DrawBuffersIndexed = OES_draw_buffers_indexed,\n}\n\n/** Descriptor to create a WebGL2 device. */\nexport class WebGLContextAttributes {\n  alpha: boolean = true;\n  antialias: boolean = true;\n  depth: boolean = true;\n  desynchronized: boolean = false;\n  failIfMajorPerformanceCaveat: boolean = false;\n  powerPreference: string = 'high-performance';\n  premultipliedAlpha: boolean = true;\n  preserveDrawingBuffer: boolean = false;\n  stencil: boolean = false;\n}\n\n/** Attribute flags to create a WebGL2 device. */\nexport enum WebGLContextAttributeFlag {\n  Alpha = 0x0001,\n  Antialias = 0x0002,\n  Depth = 0x0004,\n  Desynchronized = 0x0008,\n  FailIfMajorPerformanceCaveat = 0x0010,\n  HighPerformance = 0x0020,\n  PremultipliedAlpha = 0x0040,\n  PreserveDrawingBuffer = 0x0080,\n  Stencil = 0x0100,\n}\n","// Common error messages for use across the standard library. Keeping error messages compact\n// and reusing them where possible ensures minimal static data in binaries.\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_INDEXOUTOFRANGE: string = \"Index out of range\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_VALUEOUTOFRANGE: string = \"Value out of range\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_INVALIDLENGTH: string = \"Invalid length\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_EMPTYARRAY: string = \"Array is empty\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_HOLEYARRAY: string = \"Element type must be nullable if array is holey\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_NOTIMPLEMENTED: string = \"Not implemented\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_KEYNOTFOUND: string = \"Key does not exist\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_ALLOCATION_TOO_LARGE: string = \"Allocation too large\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_ALREADY_PINNED: string = \"Object already pinned\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_NOT_PINNED: string = \"Object is not pinned\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_URI_MALFORMED: string = \"URI malformed\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_INVALIDDATE: string = \"Invalid Date\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_UNPAIRED_SURROGATE: string = \"Unpaired surrogate\";\n","// This file is shared with the compiler and must remain portable\n\n/** Runtime types. */\nexport enum Runtime {\n  /** Simple bump allocator without GC. */\n  Stub = 0,\n  /** Stop the world semi-automatic GC. */\n  Minimal = 1,\n  /** incremental GC. */\n  Incremental = 2,\n}\n","/// <reference path=\"../rt/index.d.ts\" />\n\nimport { idof } from \"../builtins\";\nimport { CharCode } from \"./string\";\n\n// @ts-ignore: decorator\n@inline\nexport const MAX_DOUBLE_LENGTH = 28;\n\n// @ts-ignore: decorator\n@lazy @inline const POWERS10 = memory.data<u32>([\n  1,\n  10,\n  100,\n  1000,\n  10000,\n  100000,\n  1000000,\n  10000000,\n  100000000,\n  1000000000\n]);\n\n/*\n  Lookup table for pairwise char codes in range [0-99]\n\n  \"00\", \"01\", \"02\", \"03\", \"04\", \"05\", \"06\", \"07\", \"08\", \"09\",\n  \"10\", \"11\", \"12\", \"13\", \"14\", \"15\", \"16\", \"17\", \"18\", \"19\",\n  \"20\", \"21\", \"22\", \"23\", \"24\", \"25\", \"26\", \"27\", \"28\", \"29\",\n  \"30\", \"31\", \"32\", \"33\", \"34\", \"35\", \"36\", \"37\", \"38\", \"39\",\n  \"40\", \"41\", \"42\", \"43\", \"44\", \"45\", \"46\", \"47\", \"48\", \"49\",\n  \"50\", \"51\", \"52\", \"53\", \"54\", \"55\", \"56\", \"57\", \"58\", \"59\",\n  \"60\", \"61\", \"62\", \"63\", \"64\", \"65\", \"66\", \"67\", \"68\", \"69\",\n  \"70\", \"71\", \"72\", \"73\", \"74\", \"75\", \"76\", \"77\", \"78\", \"79\",\n  \"80\", \"81\", \"82\", \"83\", \"84\", \"85\", \"86\", \"87\", \"88\", \"89\",\n  \"90\", \"91\", \"92\", \"93\", \"94\", \"95\", \"96\", \"97\", \"98\", \"99\"\n*/\n// @ts-ignore: decorator\n@lazy @inline const DIGITS = memory.data<u32>([\n  0x00300030, 0x00310030, 0x00320030, 0x00330030, 0x00340030,\n  0x00350030, 0x00360030, 0x00370030, 0x00380030, 0x00390030,\n  0x00300031, 0x00310031, 0x00320031, 0x00330031, 0x00340031,\n  0x00350031, 0x00360031, 0x00370031, 0x00380031, 0x00390031,\n  0x00300032, 0x00310032, 0x00320032, 0x00330032, 0x00340032,\n  0x00350032, 0x00360032, 0x00370032, 0x00380032, 0x00390032,\n  0x00300033, 0x00310033, 0x00320033, 0x00330033, 0x00340033,\n  0x00350033, 0x00360033, 0x00370033, 0x00380033, 0x00390033,\n  0x00300034, 0x00310034, 0x00320034, 0x00330034, 0x00340034,\n  0x00350034, 0x00360034, 0x00370034, 0x00380034, 0x00390034,\n  0x00300035, 0x00310035, 0x00320035, 0x00330035, 0x00340035,\n  0x00350035, 0x00360035, 0x00370035, 0x00380035, 0x00390035,\n  0x00300036, 0x00310036, 0x00320036, 0x00330036, 0x00340036,\n  0x00350036, 0x00360036, 0x00370036, 0x00380036, 0x00390036,\n  0x00300037, 0x00310037, 0x00320037, 0x00330037, 0x00340037,\n  0x00350037, 0x00360037, 0x00370037, 0x00380037, 0x00390037,\n  0x00300038, 0x00310038, 0x00320038, 0x00330038, 0x00340038,\n  0x00350038, 0x00360038, 0x00370038, 0x00380038, 0x00390038,\n  0x00300039, 0x00310039, 0x00320039, 0x00330039, 0x00340039,\n  0x00350039, 0x00360039, 0x00370039, 0x00380039, 0x00390039\n]);\n\n// Lookup table for pairwise char codes in range [0x00-0xFF]\n// @ts-ignore: decorator\n@lazy @inline const HEX_DIGITS =\n\"000102030405060708090a0b0c0d0e0f\\\n101112131415161718191a1b1c1d1e1f\\\n202122232425262728292a2b2c2d2e2f\\\n303132333435363738393a3b3c3d3e3f\\\n404142434445464748494a4b4c4d4e4f\\\n505152535455565758595a5b5c5d5e5f\\\n606162636465666768696a6b6c6d6e6f\\\n707172737475767778797a7b7c7d7e7f\\\n808182838485868788898a8b8c8d8e8f\\\n909192939495969798999a9b9c9d9e9f\\\na0a1a2a3a4a5a6a7a8a9aaabacadaeaf\\\nb0b1b2b3b4b5b6b7b8b9babbbcbdbebf\\\nc0c1c2c3c4c5c6c7c8c9cacbcccdcecf\\\nd0d1d2d3d4d5d6d7d8d9dadbdcdddedf\\\ne0e1e2e3e4e5e6e7e8e9eaebecedeeef\\\nf0f1f2f3f4f5f6f7f8f9fafbfcfdfeff\";\n\n// @ts-ignore: decorator\n@lazy @inline const ANY_DIGITS = \"0123456789abcdefghijklmnopqrstuvwxyz\";\n\n// @ts-ignore: decorator\n@lazy @inline const EXP_POWERS = memory.data<i16>([/* eslint-disable indent */\n  -1220, -1193, -1166, -1140, -1113, -1087, -1060, -1034, -1007,  -980,\n   -954,  -927,  -901,  -874,  -847,  -821,  -794,  -768,  -741,  -715,\n   -688,  -661,  -635,  -608,  -582,  -555,  -529,  -502,  -475,  -449,\n   -422,  -396,  -369,  -343,  -316,  -289,  -263,  -236,  -210,  -183,\n   -157,  -130,  -103,   -77,   -50,   -24,     3,    30,    56,    83,\n    109,   136,   162,   189,   216,   242,   269,   295,   322,   348,\n    375,   402,   428,   455,   481,   508,   534,   561,   588,   614,\n    641,   667,   694,   720,   747,   774,   800,   827,   853,   880,\n    907,   933,   960,   986,  1013,  1039,  1066\n/* eslint-enable indent */]);\n\n// 1e-348, 1e-340, ..., 1e340\n// @ts-ignore: decorator\n@lazy @inline const FRC_POWERS = memory.data<u64>([\n  0xFA8FD5A0081C0288, 0xBAAEE17FA23EBF76, 0x8B16FB203055AC76, 0xCF42894A5DCE35EA,\n  0x9A6BB0AA55653B2D, 0xE61ACF033D1A45DF, 0xAB70FE17C79AC6CA, 0xFF77B1FCBEBCDC4F,\n  0xBE5691EF416BD60C, 0x8DD01FAD907FFC3C, 0xD3515C2831559A83, 0x9D71AC8FADA6C9B5,\n  0xEA9C227723EE8BCB, 0xAECC49914078536D, 0x823C12795DB6CE57, 0xC21094364DFB5637,\n  0x9096EA6F3848984F, 0xD77485CB25823AC7, 0xA086CFCD97BF97F4, 0xEF340A98172AACE5,\n  0xB23867FB2A35B28E, 0x84C8D4DFD2C63F3B, 0xC5DD44271AD3CDBA, 0x936B9FCEBB25C996,\n  0xDBAC6C247D62A584, 0xA3AB66580D5FDAF6, 0xF3E2F893DEC3F126, 0xB5B5ADA8AAFF80B8,\n  0x87625F056C7C4A8B, 0xC9BCFF6034C13053, 0x964E858C91BA2655, 0xDFF9772470297EBD,\n  0xA6DFBD9FB8E5B88F, 0xF8A95FCF88747D94, 0xB94470938FA89BCF, 0x8A08F0F8BF0F156B,\n  0xCDB02555653131B6, 0x993FE2C6D07B7FAC, 0xE45C10C42A2B3B06, 0xAA242499697392D3,\n  0xFD87B5F28300CA0E, 0xBCE5086492111AEB, 0x8CBCCC096F5088CC, 0xD1B71758E219652C,\n  0x9C40000000000000, 0xE8D4A51000000000, 0xAD78EBC5AC620000, 0x813F3978F8940984,\n  0xC097CE7BC90715B3, 0x8F7E32CE7BEA5C70, 0xD5D238A4ABE98068, 0x9F4F2726179A2245,\n  0xED63A231D4C4FB27, 0xB0DE65388CC8ADA8, 0x83C7088E1AAB65DB, 0xC45D1DF942711D9A,\n  0x924D692CA61BE758, 0xDA01EE641A708DEA, 0xA26DA3999AEF774A, 0xF209787BB47D6B85,\n  0xB454E4A179DD1877, 0x865B86925B9BC5C2, 0xC83553C5C8965D3D, 0x952AB45CFA97A0B3,\n  0xDE469FBD99A05FE3, 0xA59BC234DB398C25, 0xF6C69A72A3989F5C, 0xB7DCBF5354E9BECE,\n  0x88FCF317F22241E2, 0xCC20CE9BD35C78A5, 0x98165AF37B2153DF, 0xE2A0B5DC971F303A,\n  0xA8D9D1535CE3B396, 0xFB9B7CD9A4A7443C, 0xBB764C4CA7A44410, 0x8BAB8EEFB6409C1A,\n  0xD01FEF10A657842C, 0x9B10A4E5E9913129, 0xE7109BFBA19C0C9D, 0xAC2820D9623BF429,\n  0x80444B5E7AA7CF85, 0xBF21E44003ACDD2D, 0x8E679C2F5E44FF8F, 0xD433179D9C8CB841,\n  0x9E19DB92B4E31BA9, 0xEB96BF6EBADF77D9, 0xAF87023B9BF0EE6B\n]);\n\n// @ts-ignore: decorator\n@inline\nexport function isPowerOf2<T extends number>(value: T): bool {\n  return popcnt<T>(value) == 1;\n}\n\n// Count number of decimals for u32 values\n// In our case input value always non-zero so we can simplify some parts\nexport function decimalCount32(value: u32): u32 {\n  if (value < 100000) {\n    if (value < 100) {\n      return 1 + u32(value >= 10);\n    } else {\n      return 3 + u32(value >= 10000) + u32(value >= 1000);\n    }\n  } else {\n    if (value < 10000000) {\n      return 6 + u32(value >= 1000000);\n    } else {\n      return 8 + u32(value >= 1000000000) + u32(value >= 100000000);\n    }\n  }\n}\n\n// Count number of decimals for u64 values\n// In our case input value always greater than 2^32-1 so we can skip some parts\nexport function decimalCount64High(value: u64): u32 {\n  if (value < 1000000000000000) {\n    if (value < 1000000000000) {\n      return 10 + u32(value >= 100000000000) + u32(value >= 10000000000);\n    } else {\n      return 13 + u32(value >= 100000000000000) + u32(value >= 10000000000000);\n    }\n  } else {\n    if (value < 100000000000000000) {\n      return 16 + u32(value >= 10000000000000000);\n    } else {\n      return 18 + u32(value >= 10000000000000000000) + u32(value >= 1000000000000000000);\n    }\n  }\n}\n\nfunction ulog_base(num: u64, base: i32): u32 {\n  if (isPowerOf2(base)) {\n    return (63 - <u32>clz(num)) / (31 - <u32>clz(base)) + 1;\n  }\n  let b64 = u64(base), b = b64, e: u32 = 1;\n  while (num >= b) {\n    num /= b;\n    b *= b;\n    e <<= 1;\n  }\n  while (num >= 1) {\n    num /= b64;\n    e++;\n  }\n  return e - 1;\n}\n\nfunction utoa32_dec_lut(buffer: usize, num: u32, offset: usize): void {\n  while (num >= 10000) {\n    // in most VMs i32/u32 div and modulo by constant can be shared and simplificate\n    let t = num / 10000;\n    let r = num % 10000;\n    num = t;\n\n    let d1 = r / 100;\n    let d2 = r % 100;\n\n    let digits1 = <u64>load<u32>(DIGITS + (<usize>d1 << alignof<u32>()));\n    let digits2 = <u64>load<u32>(DIGITS + (<usize>d2 << alignof<u32>()));\n\n    offset -= 4;\n    store<u64>(buffer + (offset << 1), digits1 | (digits2 << 32));\n  }\n\n  if (num >= 100) {\n    let t  = num / 100;\n    let d1 = num % 100;\n    num = t;\n    offset -= 2;\n    let digits = load<u32>(DIGITS + (<usize>d1 << alignof<u32>()));\n    store<u32>(buffer + (offset << 1), digits);\n  }\n\n  if (num >= 10) {\n    offset -= 2;\n    let digits = load<u32>(DIGITS + (<usize>num << alignof<u32>()));\n    store<u32>(buffer + (offset << 1), digits);\n  } else {\n    offset -= 1;\n    let digit = CharCode._0 + num;\n    store<u16>(buffer + (offset << 1), digit);\n  }\n}\n\nfunction utoa64_dec_lut(buffer: usize, num: u64, offset: usize): void {\n  while (num >= 100000000) {\n    let t = num / 100000000;\n    let r = <usize>(num - t * 100000000);\n    num = t;\n\n    let b = r / 10000;\n    let c = r % 10000;\n\n    let b1 = b / 100;\n    let b2 = b % 100;\n    let c1 = c / 100;\n    let c2 = c % 100;\n\n    let digits1 = <u64>load<u32>(DIGITS + (<usize>c1 << alignof<u32>()));\n    let digits2 = <u64>load<u32>(DIGITS + (<usize>c2 << alignof<u32>()));\n\n    offset -= 4;\n    store<u64>(buffer + (offset << 1), digits1 | (digits2 << 32));\n\n    digits1 = <u64>load<u32>(DIGITS + (<usize>b1 << alignof<u32>()));\n    digits2 = <u64>load<u32>(DIGITS + (<usize>b2 << alignof<u32>()));\n\n    offset -= 4;\n    store<u64>(buffer + (offset << 1), digits1 | (digits2 << 32));\n  }\n\n  utoa32_dec_lut(buffer, <u32>num, offset);\n}\n\nfunction utoa_hex_lut(buffer: usize, num: u64, offset: usize): void {\n  const lut = changetype<usize>(HEX_DIGITS);\n  while (offset >= 2) {\n    offset -= 2;\n    store<u32>(\n      buffer + (offset << 1),\n      load<u32>(lut + ((<usize>num & 0xFF) << alignof<u32>()))\n    );\n    num >>= 8;\n  }\n  if (offset & 1) {\n    store<u16>(buffer, load<u16>(lut + (<usize>num << 6)));\n  }\n}\n\nfunction utoa_dec_simple<T extends number>(buffer: usize, num: T, offset: usize): void {\n  do {\n    let t = num / 10;\n    let r = <u32>(num % 10);\n    num = changetype<T>(t);\n    offset--;\n    store<u16>(buffer + (offset << 1), CharCode._0 + r);\n  } while (num);\n}\n\nfunction utoa_hex_simple<T extends number>(buffer: usize, num: T, offset: usize): void {\n  do {\n    let d = num & 0x0F | CharCode._0;\n    d += select<T>(<T>0x27, <T>0, d > <T>CharCode._9);\n    offset--;\n    store<u16>(buffer + (offset << 1), d);\n    // @ts-ignore: type\n    num >>= 4;\n  } while (num);\n}\n\n// @ts-ignore: decorator\n@inline\nexport function utoa32_dec_core(buffer: usize, num: u32, offset: usize): void {\n  if (ASC_SHRINK_LEVEL >= 1) {\n    utoa_dec_simple<u32>(buffer, num, offset);\n  } else {\n    utoa32_dec_lut(buffer, num, offset);\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction utoa32_hex_core(buffer: usize, num: u32, offset: usize): void {\n  if (ASC_SHRINK_LEVEL >= 1) {\n    utoa_hex_simple<u32>(buffer, num, offset);\n  } else {\n    utoa_hex_lut(buffer, num, offset);\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction utoa64_dec_core(buffer: usize, num: u64, offset: usize): void {\n  if (ASC_SHRINK_LEVEL >= 1) {\n    utoa_dec_simple<u64>(buffer, num, offset);\n  } else {\n    utoa64_dec_lut(buffer, num, offset);\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction utoa64_hex_core(buffer: usize, num: u64, offset: usize): void {\n  if (ASC_SHRINK_LEVEL >= 1) {\n    utoa_hex_simple<u64>(buffer, num, offset);\n  } else {\n    utoa_hex_lut(buffer, num, offset);\n  }\n}\n\nfunction utoa64_any_core(buffer: usize, num: u64, offset: usize, radix: i32): void {\n  const lut = changetype<usize>(ANY_DIGITS);\n  let base = u64(radix);\n  if ((radix & (radix - 1)) == 0) { // for radix which pow of two\n    let shift = u64(ctz(radix) & 7);\n    let mask = base - 1;\n    do {\n      offset--;\n      store<u16>(buffer + (offset << 1), load<u16>(lut + (usize(num & mask) << 1)));\n      num >>= shift;\n    } while (num);\n  } else {\n    do {\n      offset--;\n      let q = num / base;\n      store<u16>(buffer + (offset << 1), load<u16>(lut + (usize(num - q * base) << 1)));\n      num = q;\n    } while (num);\n  }\n}\n\nexport function utoa32(value: u32, radix: i32): String {\n  if (radix < 2 || radix > 36) {\n    throw new RangeError(\"toString() radix argument must be between 2 and 36\");\n  }\n  if (!value) return \"0\";\n  let out: String;\n\n  if (radix == 10) {\n    let decimals = decimalCount32(value);\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\n    utoa32_dec_core(changetype<usize>(out), value, decimals);\n  } else if (radix == 16) {\n    let decimals = (31 - clz(value) >> 2) + 1;\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\n    utoa32_hex_core(changetype<usize>(out), value, decimals);\n  } else {\n    let decimals = ulog_base(value, radix);\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\n    utoa64_any_core(changetype<usize>(out), value, decimals, radix);\n  }\n  return out;\n}\n\nexport function itoa32(value: i32, radix: i32): String {\n  if (radix < 2 || radix > 36) {\n    throw new RangeError(\"toString() radix argument must be between 2 and 36\");\n  }\n  if (!value) return \"0\";\n\n  let sign = (value >>> 31) << 1;\n  if (sign) value = -value;\n  let out: String;\n\n  if (radix == 10) {\n    let decimals = decimalCount32(value);\n    out = changetype<String>(__new((decimals << 1) + sign, idof<String>()));\n    utoa32_dec_core(changetype<usize>(out) + sign, value, decimals);\n  } else if (radix == 16) {\n    let decimals = (31 - clz(value) >> 2) + 1;\n    out = changetype<String>(__new((decimals << 1) + sign, idof<String>()));\n    utoa32_hex_core(changetype<usize>(out) + sign, value, decimals);\n  } else {\n    let val32 = u32(value);\n    let decimals = ulog_base(val32, radix);\n    out = changetype<String>(__new((decimals << 1) + sign, idof<String>()));\n    utoa64_any_core(changetype<usize>(out) + sign, val32, decimals, radix);\n  }\n  if (sign) store<u16>(changetype<usize>(out), CharCode.MINUS);\n  return out;\n}\n\nexport function utoa64(value: u64, radix: i32): String {\n  if (radix < 2 || radix > 36) {\n    throw new RangeError(\"toString() radix argument must be between 2 and 36\");\n  }\n  if (!value) return \"0\";\n  let out: String;\n\n  if (radix == 10) {\n    if (value <= u32.MAX_VALUE) {\n      let val32    = <u32>value;\n      let decimals = decimalCount32(val32);\n      out = changetype<String>(__new(decimals << 1, idof<String>()));\n      utoa32_dec_core(changetype<usize>(out), val32, decimals);\n    } else {\n      let decimals = decimalCount64High(value);\n      out = changetype<String>(__new(decimals << 1, idof<String>()));\n      utoa64_dec_core(changetype<usize>(out), value, decimals);\n    }\n  } else if (radix == 16) {\n    let decimals = (63 - u32(clz(value)) >> 2) + 1;\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\n    utoa64_hex_core(changetype<usize>(out), value, decimals);\n  } else {\n    let decimals = ulog_base(value, radix);\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\n    utoa64_any_core(changetype<usize>(out), value, decimals, radix);\n  }\n  return out;\n}\n\nexport function itoa64(value: i64, radix: i32): String {\n  if (radix < 2 || radix > 36) {\n    throw new RangeError(\"toString() radix argument must be between 2 and 36\");\n  }\n  if (!value) return \"0\";\n\n  let sign = u32(value >>> 63) << 1;\n  if (sign) value = -value;\n  let out: String;\n\n  if (radix == 10) {\n    if (<u64>value <= <u64>u32.MAX_VALUE) {\n      let val32    = <u32>value;\n      let decimals = decimalCount32(val32);\n      out = changetype<String>(__new((decimals << 1) + sign, idof<String>()));\n      utoa32_dec_core(changetype<usize>(out) + sign, val32, decimals);\n    } else {\n      let decimals = decimalCount64High(value);\n      out = changetype<String>(__new((decimals << 1) + sign, idof<String>()));\n      utoa64_dec_core(changetype<usize>(out) + sign, value, decimals);\n    }\n  } else if (radix == 16) {\n    let decimals = (63 - u32(clz(value)) >> 2) + 1;\n    out = changetype<String>(__new((decimals << 1) + sign, idof<String>()));\n    utoa64_hex_core(changetype<usize>(out) + sign, value, decimals);\n  } else {\n    let decimals = ulog_base(value, radix);\n    out = changetype<String>(__new((decimals << 1) + sign, idof<String>()));\n    utoa64_any_core(changetype<usize>(out) + sign, value, decimals, radix);\n  }\n  if (sign) store<u16>(changetype<usize>(out), CharCode.MINUS);\n  return out;\n}\n\n// @ts-ignore: decorator\n@lazy let _K: i32 = 0;\n\n// // @ts-ignore: decorator\n// @lazy\n// let _frc: u64 = 0;\n\n// @ts-ignore: decorator\n@lazy let _exp: i32 = 0;\n\n// @ts-ignore: decorator\n@lazy let _frc_minus: u64 = 0;\n\n// @ts-ignore: decorator\n@lazy let _frc_plus:  u64 = 0;\n\n// @ts-ignore: decorator\n@lazy let _frc_pow: u64 = 0;\n\n// @ts-ignore: decorator\n@lazy let _exp_pow: i32 = 0;\n\n// @ts-ignore: decorator\n@inline\nfunction umul64f(u: u64, v: u64): u64 {\n  let u0 = u & 0xFFFFFFFF;\n  let v0 = v & 0xFFFFFFFF;\n\n  let u1 = u >> 32;\n  let v1 = v >> 32;\n\n  let l = u0 * v0;\n  let t = u1 * v0 + (l >> 32);\n  let w = u0 * v1 + (t & 0xFFFFFFFF);\n\n  w += 0x7FFFFFFF; // rounding\n\n  t >>= 32;\n  w >>= 32;\n\n  return u1 * v1 + t + w;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction umul64e(e1: i32, e2: i32): i32 {\n  return e1 + e2 + 64; // where 64 is significand size\n}\n\n// @ts-ignore: decorator\n@inline\nfunction normalizedBoundaries(f: u64, e: i32): void {\n  let frc = (f << 1) + 1;\n  let exp = e - 1;\n  let off = <i32>clz<u64>(frc);\n  frc <<= off;\n  exp  -= off;\n\n  let m = 1 + i32(f == 0x0010000000000000);\n\n  _frc_plus  = frc;\n  _frc_minus = ((f << m) - 1) << e - m - exp;\n  _exp = exp;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction grisuRound(buffer: usize, len: i32, delta: u64, rest: u64, ten_kappa: u64, wp_w: u64): void {\n  let lastp = buffer + ((len - 1) << 1);\n  let digit = load<u16>(lastp);\n  while (\n    rest < wp_w &&\n    delta - rest >= ten_kappa && (\n      rest + ten_kappa < wp_w ||\n      wp_w - rest > rest + ten_kappa - wp_w\n    )\n  ) {\n    --digit;\n    rest += ten_kappa;\n  }\n  store<u16>(lastp, digit);\n}\n\n// @ts-ignore: decorator\n@inline\nfunction getCachedPower(minExp: i32): void {\n  const c = reinterpret<f64>(0x3FD34413509F79FE); // 1 / lg(10) = 0.30102999566398114\n  let dk = (-61 - minExp) * c + 347;\t            // dk must be positive, so can do ceiling in positive\n  let k = <i32>dk;\n  k += i32(k != dk); // conversion with ceil\n\n  let index = (k >> 3) + 1;\n  _K = 348 - (index << 3);\t// decimal exponent no need lookup table\n  _frc_pow = load<u64>(FRC_POWERS + (<usize>index << alignof<u64>()));\n  _exp_pow = load<i16>(EXP_POWERS + (<usize>index << alignof<i16>()));\n}\n\n// @ts-ignore: decorator\n@inline\nfunction grisu2(value: f64, buffer: usize, sign: i32): i32 {\n\n  // frexp routine\n  let uv  = reinterpret<u64>(value);\n  let exp = i32((uv & 0x7FF0000000000000) >>> 52);\n  let sid = uv & 0x000FFFFFFFFFFFFF;\n  let frc = (u64(exp != 0) << 52) + sid;\n  exp = select<i32>(exp, 1, exp) - (0x3FF + 52);\n\n  normalizedBoundaries(frc, exp);\n  getCachedPower(_exp);\n\n  // normalize\n  let off = <i32>clz<u64>(frc);\n  frc <<= off;\n  exp  -= off;\n\n  let frc_pow = _frc_pow;\n  let exp_pow = _exp_pow;\n\n  let w_frc = umul64f(frc, frc_pow);\n  let w_exp = umul64e(exp, exp_pow);\n\n  let wp_frc = umul64f(_frc_plus, frc_pow) - 1;\n  let wp_exp = umul64e(_exp, exp_pow);\n\n  let wm_frc = umul64f(_frc_minus, frc_pow) + 1;\n  let delta  = wp_frc - wm_frc;\n\n  return genDigits(buffer, w_frc, w_exp, wp_frc, wp_exp, delta, sign);\n}\n\nfunction genDigits(buffer: usize, w_frc: u64, w_exp: i32, mp_frc: u64, mp_exp: i32, delta: u64, sign: i32): i32 {\n  let one_exp = -mp_exp;\n  let one_frc = (<u64>1) << one_exp;\n  let mask    = one_frc - 1;\n\n  let wp_w_frc = mp_frc - w_frc;\n\n  let p1 = u32(mp_frc >> one_exp);\n  let p2 = mp_frc & mask;\n\n  let kappa = <i32>decimalCount32(p1);\n  let len = sign;\n\n  while (kappa > 0) {\n    let d: u32;\n    switch (kappa) {\n      case 10: { d = p1 / 1000000000; p1 %= 1000000000; break; }\n      case  9: { d = p1 /  100000000; p1 %=  100000000; break; }\n      case  8: { d = p1 /   10000000; p1 %=   10000000; break; }\n      case  7: { d = p1 /    1000000; p1 %=    1000000; break; }\n      case  6: { d = p1 /     100000; p1 %=     100000; break; }\n      case  5: { d = p1 /      10000; p1 %=      10000; break; }\n      case  4: { d = p1 /       1000; p1 %=       1000; break; }\n      case  3: { d = p1 /        100; p1 %=        100; break; }\n      case  2: { d = p1 /         10; p1 %=         10; break; }\n      case  1: { d = p1;              p1 =           0; break; }\n      default: { d = 0; break; }\n    }\n\n    if (d | len) store<u16>(buffer + (len++ << 1), CharCode._0 + <u16>d);\n\n    --kappa;\n    let tmp = ((<u64>p1) << one_exp) + p2;\n    if (tmp <= delta) {\n      _K += kappa;\n      grisuRound(buffer, len, delta, tmp, <u64>load<u32>(POWERS10 + (<usize>kappa << alignof<u32>())) << one_exp, wp_w_frc);\n      return len;\n    }\n  }\n\n  while (true) {\n    p2    *= 10;\n    delta *= 10;\n\n    let d = p2 >> one_exp;\n    if (d | len) store<u16>(buffer + (len++ << 1), CharCode._0 + <u16>d);\n\n    p2 &= mask;\n    --kappa;\n    if (p2 < delta) {\n      _K += kappa;\n      wp_w_frc *= <u64>load<u32>(POWERS10 + (<usize>-kappa << alignof<u32>()));\n      grisuRound(buffer, len, delta, p2, one_frc, wp_w_frc);\n      return len;\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction genExponent(buffer: usize, k: i32): i32 {\n  let sign = k < 0;\n  if (sign) k = -k;\n  let decimals = decimalCount32(k) + 1;\n  utoa32_dec_core(buffer, k, decimals);\n  store<u16>(buffer, <u16>select<u32>(CharCode.MINUS, CharCode.PLUS, sign));\n  return decimals;\n}\n\nfunction prettify(buffer: usize, length: i32, k: i32): i32 {\n  if (!k) {\n    store<u32>(buffer + (length << 1), CharCode.DOT | (CharCode._0 << 16));\n    return length + 2;\n  }\n\n  let kk = length + k;\n  if (length <= kk && kk <= 21) {\n    // 1234e7 -> 12340000000\n    for (let i = length; i < kk; ++i) {\n      store<u16>(buffer + (i << 1), CharCode._0);\n    }\n    store<u32>(buffer + (kk << 1), CharCode.DOT | (CharCode._0 << 16));\n    return kk + 2;\n  } else if (kk > 0 && kk <= 21) {\n    // 1234e-2 -> 12.34\n    let ptr = buffer + (kk << 1);\n    memory.copy(\n      ptr + 2,\n      ptr,\n      -k << 1\n    );\n    store<u16>(buffer + (kk << 1), CharCode.DOT);\n    return length + 1;\n  } else if (-6 < kk && kk <= 0) {\n    // 1234e-6 -> 0.001234\n    let offset = 2 - kk;\n    memory.copy(\n      buffer + (offset << 1),\n      buffer,\n      length << 1\n    );\n    store<u32>(buffer, CharCode._0 | (CharCode.DOT << 16));\n    for (let i = 2; i < offset; ++i) {\n      store<u16>(buffer + (i << 1), CharCode._0);\n    }\n    return length + offset;\n  } else if (length == 1) {\n    // 1e30\n    store<u16>(buffer, CharCode.e, 2);\n    length = genExponent(buffer + 4, kk - 1);\n    return length + 2;\n  } else {\n    let len = length << 1;\n    memory.copy(\n      buffer + 4,\n      buffer + 2,\n      len - 2\n    );\n    store<u16>(buffer,       CharCode.DOT, 2);\n    store<u16>(buffer + len, CharCode.e,   2);\n    length += genExponent(buffer + len + 4, kk - 1);\n    return length + 2;\n  }\n}\n\nfunction dtoa_core(buffer: usize, value: f64): i32 {\n  let sign = i32(value < 0);\n  if (sign) {\n    value = -value;\n    store<u16>(buffer, CharCode.MINUS);\n  }\n  // assert(value > 0 && value <= 1.7976931348623157e308);\n  let len = grisu2(value, buffer, sign);\n  len = prettify(buffer + (sign << 1), len - sign, _K);\n  return len + sign;\n}\n\n// @ts-ignore: decorator\n@lazy @inline const dtoa_buf = memory.data(MAX_DOUBLE_LENGTH << 1);\n\nexport function dtoa(value: f64): String {\n  if (value == 0) return \"0.0\";\n  if (!isFinite(value)) {\n    if (isNaN(value)) return \"NaN\";\n    return select<String>(\"-Infinity\", \"Infinity\", value < 0);\n  }\n  let size = dtoa_core(dtoa_buf, value) << 1;\n  let result = changetype<String>(__new(size, idof<String>()));\n  memory.copy(changetype<usize>(result), dtoa_buf, size);\n  return result;\n}\n\nexport function itoa_buffered<T extends number>(buffer: usize, value: T): u32 {\n  let sign: u32 = 0;\n  if (isSigned<T>()) {\n    sign = u32(value < 0);\n    if (sign) {\n      if (sizeof<T>() == 1) {\n        if (value == -0x80) {\n          // -0x80  ->  -128\n          store<u64>(buffer,\n            <u64>CharCode.MINUS |\n            <u64>(CharCode._0 + 1) << 16 |\n            <u64>(CharCode._0 + 2) << 32 |\n            <u64>(CharCode._0 + 8) << 48\n          );\n          return 4;\n        }\n      }\n      if (sizeof<T>() == 2) {\n        if (value == -0x8000) {\n          // -0x8000  ->  -32768\n          store<u64>(buffer,\n            <u64>CharCode.MINUS |\n            <u64>(CharCode._0 + 3) << 16 |\n            <u64>(CharCode._0 + 2) << 32 |\n            <u64>(CharCode._0 + 7) << 48\n          ); // -327\n          store<u32>(buffer + 8,\n            (CharCode._0 + 6) << 0 |\n            (CharCode._0 + 8) << 16\n          ); // 68\n          return 6;\n        }\n      }\n      store<u16>(buffer, CharCode.MINUS);\n      // @ts-ignore\n      value = -value;\n    }\n  }\n  let dest = buffer + (sign << 1);\n  if (ASC_SHRINK_LEVEL <= 1) {\n    if (isSigned<T>()) {\n      if (sizeof<T>() <= 4) {\n        if (<u32>value < 10) {\n          store<u16>(dest, value | CharCode._0);\n          return 1 + sign;\n        }\n      } else {\n        if (<u64>value < 10) {\n          store<u16>(dest, value | CharCode._0);\n          return 1 + sign;\n        }\n      }\n    } else {\n      if (value < 10) {\n        store<u16>(buffer, value | CharCode._0);\n        return 1;\n      }\n    }\n  }\n  let decimals: u32 = 0;\n  if (sizeof<T>() <= 4) {\n    let val32 = <u32>value;\n    decimals = decimalCount32(val32);\n    utoa32_dec_core(dest, val32, decimals);\n  } else {\n    if (<u64>value <= <u64>u32.MAX_VALUE) {\n      let val32 = <u32>value;\n      decimals = decimalCount32(val32);\n      utoa32_dec_core(dest, val32, decimals);\n    } else {\n      let val64 = <u64>value;\n      decimals = decimalCount64High(val64);\n      utoa64_dec_core(dest, val64, decimals);\n    }\n  }\n  return sign + decimals;\n}\n\nexport function dtoa_buffered(buffer: usize, value: f64): u32 {\n  if (value == 0) {\n    store<u16>(buffer, CharCode._0);\n    store<u16>(buffer, CharCode.DOT, 2);\n    store<u16>(buffer, CharCode._0,  4);\n    return 3;\n  }\n  if (!isFinite(value)) {\n    if (isNaN(value)) {\n      store<u16>(buffer, CharCode.N);\n      store<u16>(buffer, CharCode.a, 2);\n      store<u16>(buffer, CharCode.N, 4);\n      return 3;\n    } else {\n      let sign = value < 0;\n      if (sign) {\n        store<u16>(buffer, CharCode.MINUS); // -\n        buffer += 2;\n      }\n      store<u64>(buffer, 0x690066006E0049, 0); // ifnI\n      store<u64>(buffer, 0x7900740069006E, 8); // ytin\n      return 8 + u32(sign);\n    }\n  }\n  return dtoa_core(buffer, value);\n}\n","//\n// Lookup data for exp2f\n//\n\n// @ts-ignore: decorator\n@inline const EXP2F_TABLE_BITS = 5;\n\n// @ts-ignore: decorator\n@lazy @inline const EXP2F_DATA_TAB = memory.data<u64>([\n  // exp2f_data_tab[i] = uint(2^(i/N)) - (i << 52-BITS)\n  // used for computing 2^(k/N) for an int |k| < 150 N as\n  // double(tab[k%N] + (k << 52-BITS))\n  0x3FF0000000000000, 0x3FEFD9B0D3158574, 0x3FEFB5586CF9890F, 0x3FEF9301D0125B51,\n  0x3FEF72B83C7D517B, 0x3FEF54873168B9AA, 0x3FEF387A6E756238, 0x3FEF1E9DF51FDEE1,\n  0x3FEF06FE0A31B715, 0x3FEEF1A7373AA9CB, 0x3FEEDEA64C123422, 0x3FEECE086061892D,\n  0x3FEEBFDAD5362A27, 0x3FEEB42B569D4F82, 0x3FEEAB07DD485429, 0x3FEEA47EB03A5585,\n  0x3FEEA09E667F3BCD, 0x3FEE9F75E8EC5F74, 0x3FEEA11473EB0187, 0x3FEEA589994CCE13,\n  0x3FEEACE5422AA0DB, 0x3FEEB737B0CDC5E5, 0x3FEEC49182A3F090, 0x3FEED503B23E255D,\n  0x3FEEE89F995AD3AD, 0x3FEEFF76F2FB5E47, 0x3FEF199BDD85529C, 0x3FEF3720DCEF9069,\n  0x3FEF5818DCFBA487, 0x3FEF7C97337B9B5F, 0x3FEFA4AFA2A490DA, 0x3FEFD0765B6E4540\n]);\n\n// ULP error: 0.502 (nearest rounding.)\n// Relative error: 1.69 * 2^-34 in [-1/64, 1/64] (before rounding.)\n// Wrong count: 168353 (all nearest rounding wrong results with fma.)\n// @ts-ignore: decorator\n@inline\nexport function exp2f_lut(x: f32): f32 {\n  const\n    N      = 1 << EXP2F_TABLE_BITS,\n    N_MASK = N - 1,\n    shift  = reinterpret<f64>(0x4338000000000000) / N, // 0x1.8p+52\n    Ox127f = reinterpret<f32>(0x7F000000);\n\n  const\n    C0 = reinterpret<f64>(0x3FAC6AF84B912394), // 0x1.c6af84b912394p-5\n    C1 = reinterpret<f64>(0x3FCEBFCE50FAC4F3), // 0x1.ebfce50fac4f3p-3\n    C2 = reinterpret<f64>(0x3FE62E42FF0C52D6); // 0x1.62e42ff0c52d6p-1\n\n  let xd = <f64>x;\n  let ix = reinterpret<u32>(x);\n  let ux = ix >> 20 & 0x7FF;\n  if (ux >= 0x430) {\n    // |x| >= 128 or x is nan.\n    if (ix == 0xFF800000) return 0; // x == -Inf    -> 0\n    if (ux >= 0x7F8) return x + x;  // x == Inf/NaN -> Inf/NaN\n    if (x > 0) return x * Ox127f;   // x >     0    -> HugeVal (Owerflow)\n    if (x <= -150) return 0;        // x <= -150    -> 0 (Underflow)\n  }\n\n  // x = k/N + r with r in [-1/(2N), 1/(2N)] and int k.\n  let kd = xd + shift;\n  let ki = reinterpret<u64>(kd);\n  let r  = xd - (kd - shift);\n  let t: u64, y: f64, s: f64;\n\n  // exp2(x) = 2^(k/N) * 2^r ~= s * (C0*r^3 + C1*r^2 + C2*r + 1)\n  t  = load<u64>(EXP2F_DATA_TAB + ((<usize>ki & N_MASK) << alignof<u64>()));\n  t += ki << (52 - EXP2F_TABLE_BITS);\n  s  = reinterpret<f64>(t);\n  y  = C2 * r + 1;\n  y += (C0 * r + C1) * (r  * r);\n  y *= s;\n\n  return <f32>y;\n}\n\n// ULP error: 0.502 (nearest rounding.)\n// Relative error: 1.69 * 2^-34 in [-ln2/64, ln2/64] (before rounding.)\n// Wrong count: 170635 (all nearest rounding wrong results with fma.)\n// @ts-ignore: decorator\n@inline\nexport function expf_lut(x: f32): f32 {\n  const\n    N        = 1 << EXP2F_TABLE_BITS,\n    N_MASK   = N - 1,\n    shift    = reinterpret<f64>(0x4338000000000000),        // 0x1.8p+52\n    InvLn2N  = reinterpret<f64>(0x3FF71547652B82FE) * N,    // 0x1.71547652b82fep+0\n    Ox1p127f = reinterpret<f32>(0x7F000000);\n\n  const\n    C0 = reinterpret<f64>(0x3FAC6AF84B912394) / N / N / N, // 0x1.c6af84b912394p-5\n    C1 = reinterpret<f64>(0x3FCEBFCE50FAC4F3) / N / N,     // 0x1.ebfce50fac4f3p-3\n    C2 = reinterpret<f64>(0x3FE62E42FF0C52D6) / N;         // 0x1.62e42ff0c52d6p-1\n\n  let xd = <f64>x;\n  let ix = reinterpret<u32>(x);\n  let ux = ix >> 20 & 0x7FF;\n  if (ux >= 0x42B) {\n    // |x| >= 88 or x is nan.\n    if (ix == 0xFF800000) return 0;                            // x == -Inf    -> 0\n    if (ux >= 0x7F8) return x + x;                             // x == Inf/NaN -> Inf/NaN\n    if (x > reinterpret<f32>(0x42B17217)) return x * Ox1p127f; // x > log(0x1p128)  ~=  88.72 -> HugeVal (Owerflow)\n    if (x < reinterpret<f32>(0xC2CFF1B4)) return 0;            // x < log(0x1p-150) ~= -103.97 -> 0 (Underflow)\n  }\n\n  // x*N/Ln2 = k + r with r in [-1/2, 1/2] and int k.\n  let z = InvLn2N * xd;\n\n  // Round and convert z to int, the result is in [-150*N, 128*N] and\n  // ideally ties-to-even rule is used, otherwise the magnitude of r\n  // can be bigger which gives larger approximation error.\n  let kd = <f64>(z + shift);\n  let ki = reinterpret<u64>(kd);\n  let r  = z - (kd - shift);\n  let s: f64, y: f64, t: u64;\n\n  // exp(x) = 2^(k/N) * 2^(r/N) ~= s * (C0*r^3 + C1*r^2 + C2*r + 1)\n  t  = load<u64>(EXP2F_DATA_TAB + ((<usize>ki & N_MASK) << alignof<u64>()));\n  t += ki << (52 - EXP2F_TABLE_BITS);\n  s  = reinterpret<f64>(t);\n  z  = C0 * r + C1;\n  y  = C2 * r + 1;\n  y += z * (r * r);\n  y *= s;\n\n  return <f32>y;\n}\n\n//\n// Lookup data for log2f\n//\n\n// @ts-ignore: decorator\n@inline const LOG2F_TABLE_BITS = 4;\n\n// @ts-ignore: decorator\n@lazy @inline const LOG2F_DATA_TAB = memory.data<u64>([\n  0x3FF661EC79F8F3BE, 0xBFDEFEC65B963019, // 0x1.661ec79f8f3bep+0, -0x1.efec65b963019p-2,\n  0x3FF571ED4AAF883D, 0xBFDB0B6832D4FCA4, // 0x1.571ed4aaf883dp+0, -0x1.b0b6832d4fca4p-2,\n  0x3FF49539F0F010B0, 0xBFD7418B0A1FB77B, // 0x1.49539f0f010bp+0 , -0x1.7418b0a1fb77bp-2,\n  0x3FF3C995B0B80385, 0xBFD39DE91A6DCF7B, // 0x1.3c995b0b80385p+0, -0x1.39de91a6dcf7bp-2,\n  0x3FF30D190C8864A5, 0xBFD01D9BF3F2B631, // 0x1.30d190c8864a5p+0, -0x1.01d9bf3f2b631p-2,\n  0x3FF25E227B0B8EA0, 0xBFC97C1D1B3B7AF0, // 0x1.25e227b0b8eap+0 , -0x1.97c1d1b3b7afp-3 ,\n  0x3FF1BB4A4A1A343F, 0xBFC2F9E393AF3C9F, // 0x1.1bb4a4a1a343fp+0, -0x1.2f9e393af3c9fp-3,\n  0x3FF12358F08AE5BA, 0xBFB960CBBF788D5C, // 0x1.12358f08ae5bap+0, -0x1.960cbbf788d5cp-4,\n  0x3FF0953F419900A7, 0xBFAA6F9DB6475FCE, // 0x1.0953f419900a7p+0, -0x1.a6f9db6475fcep-5,\n  0x3FF0000000000000, 0,                  // 0x1p+0,                0x0,\n  0x3FEE608CFD9A47AC, 0x3FB338CA9F24F53D, // 0x1.e608cfd9a47acp-1,  0x1.338ca9f24f53dp-4,\n  0x3FECA4B31F026AA0, 0x3FC476A9543891BA, // 0x1.ca4b31f026aap-1 ,  0x1.476a9543891bap-3,\n  0x3FEB2036576AFCE6, 0x3FCE840B4AC4E4D2, // 0x1.b2036576afce6p-1,  0x1.e840b4ac4e4d2p-3,\n  0x3FE9C2D163A1AA2D, 0x3FD40645F0C6651C, // 0x1.9c2d163a1aa2dp-1,  0x1.40645f0c6651cp-2,\n  0x3FE886E6037841ED, 0x3FD88E9C2C1B9FF8, // 0x1.886e6037841edp-1,  0x1.88e9c2c1b9ff8p-2,\n  0x3FE767DCF5534862, 0x3FDCE0A44EB17BCC  // 0x1.767dcf5534862p-1,  0x1.ce0a44eb17bccp-2\n]);\n\n// ULP error: 0.752 (nearest rounding.)\n// Relative error: 1.9 * 2^-26 (before rounding.)\n// @ts-ignore: decorator\n@inline\nexport function log2f_lut(x: f32): f32 {\n  const\n    N_MASK  = (1 << LOG2F_TABLE_BITS) - 1,\n    Ox1p23f = reinterpret<f32>(0x4B000000); // 0x1p23f\n\n  const\n    A0 = reinterpret<f64>(0xBFD712B6F70A7E4D), // -0x1.712b6f70a7e4dp-2\n    A1 = reinterpret<f64>(0x3FDECABF496832E0), //  0x1.ecabf496832ep-2\n    A2 = reinterpret<f64>(0xBFE715479FFAE3DE), // -0x1.715479ffae3dep-1\n    A3 = reinterpret<f64>(0x3FF715475F35C8B8); //  0x1.715475f35c8b8p0\n\n  let ux = reinterpret<u32>(x);\n  // Fix sign of zero with downward rounding when x==1.\n  // if (WANT_ROUNDING && predict_false(ix == 0x3f800000)) return 0;\n  if (ux - 0x00800000 >= 0x7F800000 - 0x00800000) {\n    // x < 0x1p-126 or inf or nan.\n    if (ux * 2 == 0) return -Infinity;\n    if (ux == 0x7F800000) return x; // log2(inf) == inf.\n    if ((ux >> 31) || ux * 2 >= 0xFF000000) return (x - x) / (x - x);\n    // x is subnormal, normalize it.\n    ux = reinterpret<u32>(x * Ox1p23f);\n    ux -= 23 << 23;\n  }\n  // x = 2^k z; where z is in range [OFF,2*OFF] and exact.\n  // The range is split into N subintervals.\n  // The ith subinterval contains z and c is near its center.\n  let tmp  = ux - 0x3F330000;\n  let i    = (tmp >> (23 - LOG2F_TABLE_BITS)) & N_MASK;\n  let top  = tmp & 0xFF800000;\n  let iz   = ux - top;\n  let k    = <i32>tmp >> 23;\n\n  let invc = load<f64>(LOG2F_DATA_TAB + (i << (1 + alignof<f64>())), 0 << alignof<f64>());\n  let logc = load<f64>(LOG2F_DATA_TAB + (i << (1 + alignof<f64>())), 1 << alignof<f64>());\n  let z    = <f64>reinterpret<f32>(iz);\n\n  // log2(x) = log1p(z/c-1)/ln2 + log2(c) + k\n  let r  = z * invc - 1;\n  let y0 = logc + <f64>k;\n\n  // Pipelined polynomial evaluation to approximate log1p(r)/ln2.\n  let y  = A1 * r + A2;\n  let p  = A3 * r + y0;\n  let r2 = r * r;\n  y += A0 * r2;\n  y  = y * r2 + p;\n\n  return <f32>y;\n}\n\n//\n// Lookup data for logf. See: https://git.musl-libc.org/cgit/musl/tree/src/math/logf.c\n//\n\n// @ts-ignore: decorator\n@inline const LOGF_TABLE_BITS = 4;\n\n// @ts-ignore: decorator\n@lazy @inline const LOGF_DATA_TAB = memory.data<u64>([\n  0x3FF661EC79F8F3BE, 0xBFD57BF7808CAADE, // 0x1.661ec79f8f3bep+0, -0x1.57bf7808caadep-2,\n  0x3FF571ED4AAF883D, 0xBFD2BEF0A7C06DDB, // 0x1.571ed4aaf883dp+0, -0x1.2bef0a7c06ddbp-2,\n  0x3FF49539F0F010B0, 0xBFD01EAE7F513A67, // 0x1.49539f0f010bp+0 , -0x1.01eae7f513a67p-2,\n  0x3FF3C995B0B80385, 0xBFCB31D8A68224E9, // 0x1.3c995b0b80385p+0, -0x1.b31d8a68224e9p-3,\n  0x3FF30D190C8864A5, 0xBFC6574F0AC07758, // 0x1.30d190c8864a5p+0, -0x1.6574f0ac07758p-3,\n  0x3FF25E227B0B8EA0, 0xBFC1AA2BC79C8100, // 0x1.25e227b0b8eap+0 , -0x1.1aa2bc79c81p-3  ,\n  0x3FF1BB4A4A1A343F, 0xBFBA4E76CE8C0E5E, // 0x1.1bb4a4a1a343fp+0, -0x1.a4e76ce8c0e5ep-4,\n  0x3FF12358F08AE5BA, 0xBFB1973C5A611CCC, // 0x1.12358f08ae5bap+0, -0x1.1973c5a611cccp-4,\n  0x3FF0953F419900A7, 0xBFA252F438E10C1E, // 0x1.0953f419900a7p+0, -0x1.252f438e10c1ep-5,\n  0x3FF0000000000000, 0,                  // 0x1p+0,                0,\n  0x3FEE608CFD9A47AC, 0x3FAAA5AA5DF25984, // 0x1.e608cfd9a47acp-1,  0x1.aa5aa5df25984p-5,\n  0x3FECA4B31F026AA0, 0x3FBC5E53AA362EB4, // 0x1.ca4b31f026aap-1 ,  0x1.c5e53aa362eb4p-4,\n  0x3FEB2036576AFCE6, 0x3FC526E57720DB08, // 0x1.b2036576afce6p-1,  0x1.526e57720db08p-3,\n  0x3FE9C2D163A1AA2D, 0x3FCBC2860D224770, // 0x1.9c2d163a1aa2dp-1,  0x1.bc2860d22477p-3 ,\n  0x3FE886E6037841ED, 0x3FD1058BC8A07EE1, // 0x1.886e6037841edp-1,  0x1.1058bc8a07ee1p-2,\n  0x3FE767DCF5534862, 0x3FD4043057B6EE09  // 0x1.767dcf5534862p-1,  0x1.4043057b6ee09p-2\n]);\n\n// ULP error: 0.818 (nearest rounding.)\n// Relative error: 1.957 * 2^-26 (before rounding.)\n// @ts-ignore: decorator\n@inline\nexport function logf_lut(x: f32): f32 {\n  const\n    N_MASK  = (1 << LOGF_TABLE_BITS) - 1,\n    Ox1p23f = reinterpret<f32>(0x4B000000); // 0x1p23f\n\n  const\n    Ln2 = reinterpret<f64>(0x3FE62E42FEFA39EF), // 0x1.62e42fefa39efp-1;\n    A0  = reinterpret<f64>(0xBFD00EA348B88334), // -0x1.00ea348b88334p-2\n    A1  = reinterpret<f64>(0x3FD5575B0BE00B6A), //  0x1.5575b0be00b6ap-2\n    A2  = reinterpret<f64>(0xBFDFFFFEF20A4123); // -0x1.ffffef20a4123p-2\n\n  let ux = reinterpret<u32>(x);\n  // Fix sign of zero with downward rounding when x==1.\n  // if (WANT_ROUNDING && ux == 0x3f800000) return 0;\n  if (ux - 0x00800000 >= 0x7F800000 - 0x00800000) {\n    // x < 0x1p-126 or inf or nan.\n    if ((ux << 1) == 0) return -Infinity;\n    if (ux == 0x7F800000) return x; // log(inf) == inf.\n    if ((ux >> 31) || (ux << 1) >= 0xFF000000) return (x - x) / (x - x);\n    // x is subnormal, normalize it.\n    ux = reinterpret<u32>(x * Ox1p23f);\n    ux -= 23 << 23;\n  }\n  // x = 2^k z; where z is in range [OFF,2*OFF] and exact.\n  // The range is split into N subintervals.\n  // The ith subinterval contains z and c is near its center.\n  let tmp = ux - 0x3F330000;\n  let i   = (tmp >> (23 - LOGF_TABLE_BITS)) & N_MASK;\n  let k   = <i32>tmp >> 23;\n  let iz  = ux - (tmp & 0x1FF << 23);\n\n  let invc = load<f64>(LOGF_DATA_TAB + (i << (1 + alignof<f64>())), 0 << alignof<f64>());\n  let logc = load<f64>(LOGF_DATA_TAB + (i << (1 + alignof<f64>())), 1 << alignof<f64>());\n\n  let z = <f64>reinterpret<f32>(iz);\n\n  // log(x) = log1p(z/c-1) + log(c) + k*Ln2\n  let r = z * invc - 1;\n  let y0 = logc + <f64>k * Ln2;\n\n  // Pipelined polynomial evaluation to approximate log1p(r).\n  let r2 = r * r;\n  let y  = A1 * r + A2;\n  y += A0 * r2;\n  y = y * r2 + (y0 + r);\n\n  return <f32>y;\n}\n\n//\n// Lookup data for powf. See: https://git.musl-libc.org/cgit/musl/tree/src/math/powf.c\n//\n\n// @ts-ignore: decorator\n@inline\nfunction zeroinfnanf(ux: u32): bool {\n  return (ux << 1) - 1 >= (<u32>0x7f800000 << 1) - 1;\n}\n\n// Returns 0 if not int, 1 if odd int, 2 if even int. The argument is\n// the bit representation of a non-zero finite floating-point value.\n// @ts-ignore: decorator\n@inline\nfunction checkintf(iy: u32): i32 {\n  let e = iy >> 23 & 0xFF;\n  if (e < 0x7F     ) return 0;\n  if (e > 0x7F + 23) return 2;\n  e = 1 << (0x7F + 23 - e);\n  if (iy & (e - 1)) return 0;\n  if (iy &  e     ) return 1;\n  return 2;\n}\n\n// Subnormal input is normalized so ix has negative biased exponent.\n// Output is multiplied by N (POWF_SCALE) if TOINT_INTRINICS is set.\n// @ts-ignore: decorator\n@inline\nfunction log2f_inline(ux: u32): f64 {\n  const N_MASK = (1 << LOG2F_TABLE_BITS) - 1;\n\n  const\n    A0 = reinterpret<f64>(0x3FD27616C9496E0B), //  0x1.27616c9496e0bp-2\n    A1 = reinterpret<f64>(0xBFD71969A075C67A), // -0x1.71969a075c67ap-2\n    A2 = reinterpret<f64>(0x3FDEC70A6CA7BADD), //  0x1.ec70a6ca7baddp-2\n    A3 = reinterpret<f64>(0xBFE7154748BEF6C8), // -0x1.7154748bef6c8p-1\n    A4 = reinterpret<f64>(0x3FF71547652AB82B); //  0x1.71547652ab82bp+0\n\n  // x = 2^k z; where z is in range [OFF,2*OFF] and exact.\n  // The range is split into N subintervals.\n  // The ith subinterval contains z and c is near its center.\n  let tmp  = ux - 0x3F330000;\n  let i    = usize((tmp >> (23 - LOG2F_TABLE_BITS)) & N_MASK);\n  let top  = tmp & 0xFF800000;\n  let uz   = ux - top;\n  let k    = <i32>top >> 23;\n\n  let invc = load<f64>(LOG2F_DATA_TAB + (i << (1 + alignof<f64>())), 0 << alignof<f64>());\n  let logc = load<f64>(LOG2F_DATA_TAB + (i << (1 + alignof<f64>())), 1 << alignof<f64>());\n  let z    = <f64>reinterpret<f32>(uz);\n\n  // log2(x) = log1p(z/c-1)/ln2 + log2(c) + k\n  let r  = z * invc - 1;\n  let y0 = logc + <f64>k;\n\n  // Pipelined polynomial evaluation to approximate log1p(r)/ln2.\n  let y = A0 * r + A1;\n  let p = A2 * r + A3;\n  let q = A4 * r + y0;\n\n  r *= r;\n  q += p * r;\n  y  = y * (r * r) + q;\n\n  return y;\n}\n\n// The output of log2 and thus the input of exp2 is either scaled by N\n// (in case of fast toint intrinsics) or not.  The unscaled xd must be\n// in [-1021,1023], sign_bias sets the sign of the result.\n// @ts-ignore: decorator\n@inline\nfunction exp2f_inline(xd: f64, signBias: u32): f32 {\n  const\n    N      = 1 << EXP2F_TABLE_BITS,\n    N_MASK = N - 1,\n    shift  = reinterpret<f64>(0x4338000000000000) / N; // 0x1.8p+52\n\n  const\n    C0 = reinterpret<f64>(0x3FAC6AF84B912394), // 0x1.c6af84b912394p-5\n    C1 = reinterpret<f64>(0x3FCEBFCE50FAC4F3), // 0x1.ebfce50fac4f3p-3\n    C2 = reinterpret<f64>(0x3FE62E42FF0C52D6); // 0x1.62e42ff0c52d6p-1\n\n  // x = k/N + r with r in [-1/(2N), 1/(2N)]\n  let kd = <f64>(xd + shift);\n  let ki = reinterpret<u64>(kd);\n  let r  = xd - (kd - shift);\n  let t: u64, z: f64, y: f64, s: f64;\n\n  // exp2(x) = 2^(k/N) * 2^r ~= s * (C0*r^3 + C1*r^2 + C2*r + 1)\n  t  = load<u64>(EXP2F_DATA_TAB + ((<usize>ki & N_MASK) << alignof<u64>()));\n  t += (ki + signBias) << (52 - EXP2F_TABLE_BITS);\n  s  = reinterpret<f64>(t);\n  z  = C0 * r + C1;\n  y  = C2 * r + 1;\n  y += z * (r * r);\n  y *= s;\n  return <f32>y;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction xflowf(sign: u32, y: f32): f32 {\n  return select<f32>(-y, y, sign) * y;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction oflowf(sign: u32): f32 {\n  return xflowf(sign, reinterpret<f32>(0x70000000)); // 0x1p97f\n}\n\n// @ts-ignore: decorator\n@inline\nfunction uflowf(sign: u32): f32 {\n  return xflowf(sign, reinterpret<f32>(0x10000000)); // 0x1p-95f\n}\n\n// @ts-ignore: decorator\n@inline\nexport function powf_lut(x: f32, y: f32): f32 {\n  const\n    Ox1p23f     = reinterpret<f32>(0x4B000000), // 0x1p23f\n    UPPER_LIMIT = reinterpret<f64>(0x405FFFFFFFD1D571), // 0x1.fffffffd1d571p+6\n    LOWER_LIMIT = -150.0,\n    SIGN_BIAS   = 1 << (EXP2F_TABLE_BITS + 11);\n\n  let signBias: u32 = 0;\n  let ix = reinterpret<u32>(x);\n  let iy = reinterpret<u32>(y);\n  let ny = 0;\n\n  if (i32(ix - 0x00800000 >= 0x7f800000 - 0x00800000) | (ny = i32(zeroinfnanf(iy)))) {\n    // Either (x < 0x1p-126 or inf or nan) or (y is 0 or inf or nan).\n    if (ny) {\n      if ((iy << 1) == 0) return 1.0;\n      if (ix == 0x3F800000) return NaN; // original: 1.0\n      if ((ix << 1) > (<u32>0x7F800000 << 1) || (iy << 1) > (<u32>0x7F800000 << 1)) return x + y;\n      if ((ix << 1) == (0x3F800000 << 1)) return NaN; // original: 1.0\n      if (((ix << 1) < (0x3F800000 << 1)) == !(iy >> 31)) return 0; // |x| < 1 && y==inf or |x| > 1 && y==-inf.\n      return y * y;\n    }\n    if (zeroinfnanf(ix)) {\n      let x2 = x * x;\n      if ((ix >> 31) && checkintf(iy) == 1) x2 = -x2;\n      return <i32>iy < 0 ? 1 / x2 : x2;\n    }\n    // x and y are non-zero finite.\n    if (<i32>ix < 0) {\n      // Finite x < 0.\n      let yint = checkintf(iy);\n      if (yint == 0) return (x - x) / (x - x);\n      if (yint == 1) signBias = SIGN_BIAS;\n      ix &= 0x7FFFFFFF;\n    }\n    if (ix < 0x00800000) {\n      // Normalize subnormal x so exponent becomes negative.\n      ix = reinterpret<u32>(x * Ox1p23f);\n      ix &= 0x7FFFFFFF;\n      ix -= 23 << 23;\n    }\n  }\n  let logx = log2f_inline(ix);\n  let ylogx = y * logx; // cannot overflow, y is single prec.\n  if ((reinterpret<u64>(ylogx) >> 47 & 0xFFFF) >= 0x80BF) { // reinterpret<u64>(126.0) >> 47\n    // |y * log(x)| >= 126\n    if (ylogx  > UPPER_LIMIT) return oflowf(signBias); // overflow\n    if (ylogx <= LOWER_LIMIT) return uflowf(signBias); // underflow\n  }\n  return exp2f_inline(ylogx, signBias);\n}\n\n//\n// Lookup data for exp. See: https://git.musl-libc.org/cgit/musl/tree/src/math/exp.c\n//\n\n// @ts-ignore: decorator\n@inline const EXP_TABLE_BITS = 7;\n\n// @ts-ignore: decorator\n@lazy @inline const EXP_DATA_TAB = memory.data<u64>([\n  0x0000000000000000, 0x3FF0000000000000,\n  0x3C9B3B4F1A88BF6E, 0x3FEFF63DA9FB3335,\n  0xBC7160139CD8DC5D, 0x3FEFEC9A3E778061,\n  0xBC905E7A108766D1, 0x3FEFE315E86E7F85,\n  0x3C8CD2523567F613, 0x3FEFD9B0D3158574,\n  0xBC8BCE8023F98EFA, 0x3FEFD06B29DDF6DE,\n  0x3C60F74E61E6C861, 0x3FEFC74518759BC8,\n  0x3C90A3E45B33D399, 0x3FEFBE3ECAC6F383,\n  0x3C979AA65D837B6D, 0x3FEFB5586CF9890F,\n  0x3C8EB51A92FDEFFC, 0x3FEFAC922B7247F7,\n  0x3C3EBE3D702F9CD1, 0x3FEFA3EC32D3D1A2,\n  0xBC6A033489906E0B, 0x3FEF9B66AFFED31B,\n  0xBC9556522A2FBD0E, 0x3FEF9301D0125B51,\n  0xBC5080EF8C4EEA55, 0x3FEF8ABDC06C31CC,\n  0xBC91C923B9D5F416, 0x3FEF829AAEA92DE0,\n  0x3C80D3E3E95C55AF, 0x3FEF7A98C8A58E51,\n  0xBC801B15EAA59348, 0x3FEF72B83C7D517B,\n  0xBC8F1FF055DE323D, 0x3FEF6AF9388C8DEA,\n  0x3C8B898C3F1353BF, 0x3FEF635BEB6FCB75,\n  0xBC96D99C7611EB26, 0x3FEF5BE084045CD4,\n  0x3C9AECF73E3A2F60, 0x3FEF54873168B9AA,\n  0xBC8FE782CB86389D, 0x3FEF4D5022FCD91D,\n  0x3C8A6F4144A6C38D, 0x3FEF463B88628CD6,\n  0x3C807A05B0E4047D, 0x3FEF3F49917DDC96,\n  0x3C968EFDE3A8A894, 0x3FEF387A6E756238,\n  0x3C875E18F274487D, 0x3FEF31CE4FB2A63F,\n  0x3C80472B981FE7F2, 0x3FEF2B4565E27CDD,\n  0xBC96B87B3F71085E, 0x3FEF24DFE1F56381,\n  0x3C82F7E16D09AB31, 0x3FEF1E9DF51FDEE1,\n  0xBC3D219B1A6FBFFA, 0x3FEF187FD0DAD990,\n  0x3C8B3782720C0AB4, 0x3FEF1285A6E4030B,\n  0x3C6E149289CECB8F, 0x3FEF0CAFA93E2F56,\n  0x3C834D754DB0ABB6, 0x3FEF06FE0A31B715,\n  0x3C864201E2AC744C, 0x3FEF0170FC4CD831,\n  0x3C8FDD395DD3F84A, 0x3FEEFC08B26416FF,\n  0xBC86A3803B8E5B04, 0x3FEEF6C55F929FF1,\n  0xBC924AEDCC4B5068, 0x3FEEF1A7373AA9CB,\n  0xBC9907F81B512D8E, 0x3FEEECAE6D05D866,\n  0xBC71D1E83E9436D2, 0x3FEEE7DB34E59FF7,\n  0xBC991919B3CE1B15, 0x3FEEE32DC313A8E5,\n  0x3C859F48A72A4C6D, 0x3FEEDEA64C123422,\n  0xBC9312607A28698A, 0x3FEEDA4504AC801C,\n  0xBC58A78F4817895B, 0x3FEED60A21F72E2A,\n  0xBC7C2C9B67499A1B, 0x3FEED1F5D950A897,\n  0x3C4363ED60C2AC11, 0x3FEECE086061892D,\n  0x3C9666093B0664EF, 0x3FEECA41ED1D0057,\n  0x3C6ECCE1DAA10379, 0x3FEEC6A2B5C13CD0,\n  0x3C93FF8E3F0F1230, 0x3FEEC32AF0D7D3DE,\n  0x3C7690CEBB7AAFB0, 0x3FEEBFDAD5362A27,\n  0x3C931DBDEB54E077, 0x3FEEBCB299FDDD0D,\n  0xBC8F94340071A38E, 0x3FEEB9B2769D2CA7,\n  0xBC87DECCDC93A349, 0x3FEEB6DAA2CF6642,\n  0xBC78DEC6BD0F385F, 0x3FEEB42B569D4F82,\n  0xBC861246EC7B5CF6, 0x3FEEB1A4CA5D920F,\n  0x3C93350518FDD78E, 0x3FEEAF4736B527DA,\n  0x3C7B98B72F8A9B05, 0x3FEEAD12D497C7FD,\n  0x3C9063E1E21C5409, 0x3FEEAB07DD485429,\n  0x3C34C7855019C6EA, 0x3FEEA9268A5946B7,\n  0x3C9432E62B64C035, 0x3FEEA76F15AD2148,\n  0xBC8CE44A6199769F, 0x3FEEA5E1B976DC09,\n  0xBC8C33C53BEF4DA8, 0x3FEEA47EB03A5585,\n  0xBC845378892BE9AE, 0x3FEEA34634CCC320,\n  0xBC93CEDD78565858, 0x3FEEA23882552225,\n  0x3C5710AA807E1964, 0x3FEEA155D44CA973,\n  0xBC93B3EFBF5E2228, 0x3FEEA09E667F3BCD,\n  0xBC6A12AD8734B982, 0x3FEEA012750BDABF,\n  0xBC6367EFB86DA9EE, 0x3FEE9FB23C651A2F,\n  0xBC80DC3D54E08851, 0x3FEE9F7DF9519484,\n  0xBC781F647E5A3ECF, 0x3FEE9F75E8EC5F74,\n  0xBC86EE4AC08B7DB0, 0x3FEE9F9A48A58174,\n  0xBC8619321E55E68A, 0x3FEE9FEB564267C9,\n  0x3C909CCB5E09D4D3, 0x3FEEA0694FDE5D3F,\n  0xBC7B32DCB94DA51D, 0x3FEEA11473EB0187,\n  0x3C94ECFD5467C06B, 0x3FEEA1ED0130C132,\n  0x3C65EBE1ABD66C55, 0x3FEEA2F336CF4E62,\n  0xBC88A1C52FB3CF42, 0x3FEEA427543E1A12,\n  0xBC9369B6F13B3734, 0x3FEEA589994CCE13,\n  0xBC805E843A19FF1E, 0x3FEEA71A4623C7AD,\n  0xBC94D450D872576E, 0x3FEEA8D99B4492ED,\n  0x3C90AD675B0E8A00, 0x3FEEAAC7D98A6699,\n  0x3C8DB72FC1F0EAB4, 0x3FEEACE5422AA0DB,\n  0xBC65B6609CC5E7FF, 0x3FEEAF3216B5448C,\n  0x3C7BF68359F35F44, 0x3FEEB1AE99157736,\n  0xBC93091FA71E3D83, 0x3FEEB45B0B91FFC6,\n  0xBC5DA9B88B6C1E29, 0x3FEEB737B0CDC5E5,\n  0xBC6C23F97C90B959, 0x3FEEBA44CBC8520F,\n  0xBC92434322F4F9AA, 0x3FEEBD829FDE4E50,\n  0xBC85CA6CD7668E4B, 0x3FEEC0F170CA07BA,\n  0x3C71AFFC2B91CE27, 0x3FEEC49182A3F090,\n  0x3C6DD235E10A73BB, 0x3FEEC86319E32323,\n  0xBC87C50422622263, 0x3FEECC667B5DE565,\n  0x3C8B1C86E3E231D5, 0x3FEED09BEC4A2D33,\n  0xBC91BBD1D3BCBB15, 0x3FEED503B23E255D,\n  0x3C90CC319CEE31D2, 0x3FEED99E1330B358,\n  0x3C8469846E735AB3, 0x3FEEDE6B5579FDBF,\n  0xBC82DFCD978E9DB4, 0x3FEEE36BBFD3F37A,\n  0x3C8C1A7792CB3387, 0x3FEEE89F995AD3AD,\n  0xBC907B8F4AD1D9FA, 0x3FEEEE07298DB666,\n  0xBC55C3D956DCAEBA, 0x3FEEF3A2B84F15FB,\n  0xBC90A40E3DA6F640, 0x3FEEF9728DE5593A,\n  0xBC68D6F438AD9334, 0x3FEEFF76F2FB5E47,\n  0xBC91EEE26B588A35, 0x3FEF05B030A1064A,\n  0x3C74FFD70A5FDDCD, 0x3FEF0C1E904BC1D2,\n  0xBC91BDFBFA9298AC, 0x3FEF12C25BD71E09,\n  0x3C736EAE30AF0CB3, 0x3FEF199BDD85529C,\n  0x3C8EE3325C9FFD94, 0x3FEF20AB5FFFD07A,\n  0x3C84E08FD10959AC, 0x3FEF27F12E57D14B,\n  0x3C63CDAF384E1A67, 0x3FEF2F6D9406E7B5,\n  0x3C676B2C6C921968, 0x3FEF3720DCEF9069,\n  0xBC808A1883CCB5D2, 0x3FEF3F0B555DC3FA,\n  0xBC8FAD5D3FFFFA6F, 0x3FEF472D4A07897C,\n  0xBC900DAE3875A949, 0x3FEF4F87080D89F2,\n  0x3C74A385A63D07A7, 0x3FEF5818DCFBA487,\n  0xBC82919E2040220F, 0x3FEF60E316C98398,\n  0x3C8E5A50D5C192AC, 0x3FEF69E603DB3285,\n  0x3C843A59AC016B4B, 0x3FEF7321F301B460,\n  0xBC82D52107B43E1F, 0x3FEF7C97337B9B5F,\n  0xBC892AB93B470DC9, 0x3FEF864614F5A129,\n  0x3C74B604603A88D3, 0x3FEF902EE78B3FF6,\n  0x3C83C5EC519D7271, 0x3FEF9A51FBC74C83,\n  0xBC8FF7128FD391F0, 0x3FEFA4AFA2A490DA,\n  0xBC8DAE98E223747D, 0x3FEFAF482D8E67F1,\n  0x3C8EC3BC41AA2008, 0x3FEFBA1BEE615A27,\n  0x3C842B94C3A9EB32, 0x3FEFC52B376BBA97,\n  0x3C8A64A931D185EE, 0x3FEFD0765B6E4540,\n  0xBC8E37BAE43BE3ED, 0x3FEFDBFDAD9CBE14,\n  0x3C77893B4D91CD9D, 0x3FEFE7C1819E90D8,\n  0x3C5305C14160CC89, 0x3FEFF3C22B8F71F1\n]);\n\n// Handle cases that may overflow or underflow when computing the result that\n// is scale*(1+TMP) without intermediate rounding. The bit representation of\n// scale is in SBITS, however it has a computed exponent that may have\n// overflown into the sign bit so that needs to be adjusted before using it as\n// a double.  (int32_t)KI is the k used in the argument reduction and exponent\n// adjustment of scale, positive k here means the result may overflow and\n// negative k means the result may underflow.\n// @ts-ignore: decorator\n@inline\nfunction specialcase(tmp: f64, sbits: u64, ki: u64): f64 {\n  const\n    Ox1p_1022 = reinterpret<f64>(0x0010000000000000), // 0x1p-1022\n    Ox1p1009  = reinterpret<f64>(0x7F00000000000000); // 0x1p1009\n\n  let scale: f64;\n  if (!(ki & 0x80000000)) {\n    // k > 0, the exponent of scale might have overflowed by <= 460.\n    sbits -= u64(1009) << 52;\n    scale = reinterpret<f64>(sbits);\n    return Ox1p1009 * (scale + scale * tmp); // 0x1p1009\n  }\n  // k < 0, need special care in the subnormal range.\n  sbits += u64(1022) << 52;\n  // Note: sbits is signed scale.\n  scale = reinterpret<f64>(sbits);\n  let y = scale + scale * tmp;\n  if (abs(y) < 1.0) {\n    // Round y to the right precision before scaling it into the subnormal\n    // range to avoid double rounding that can cause 0.5+E/2 ulp error where\n    // E is the worst-case ulp error outside the subnormal range.  So this\n    // is only useful if the goal is better than 1 ulp worst-case error.\n    let one = copysign(1.0, y);\n    let lo = scale - y + scale * tmp;\n    let hi = one + y;\n    lo = one - hi + y + lo;\n    y  = (hi + lo) - one;\n    // Fix the sign of 0.\n    if (y == 0.0) y = reinterpret<f64>(sbits & 0x8000000000000000);\n  }\n  return y * Ox1p_1022;\n}\n\n// @ts-ignore: decorator\n@inline\nexport function exp_lut(x: f64): f64 {\n  const\n    N      = 1 << EXP_TABLE_BITS,\n    N_MASK = N - 1;\n\n  const\n    InvLn2N   = reinterpret<f64>(0x3FF71547652B82FE) * N, // 0x1.71547652b82fep0\n    NegLn2hiN = reinterpret<f64>(0xBF762E42FEFA0000),     // -0x1.62e42fefa0000p-8\n    NegLn2loN = reinterpret<f64>(0xBD0CF79ABC9E3B3A),     // -0x1.cf79abc9e3b3ap-47\n    shift     = reinterpret<f64>(0x4338000000000000);     // 0x1.8p52;\n\n  const\n    C2 = reinterpret<f64>(0x3FDFFFFFFFFFFDBD), // __exp_data.poly[0] (0x1.ffffffffffdbdp-2)\n    C3 = reinterpret<f64>(0x3FC555555555543C), // __exp_data.poly[1] (0x1.555555555543cp-3)\n    C4 = reinterpret<f64>(0x3FA55555CF172B91), // __exp_data.poly[2] (0x1.55555cf172b91p-5)\n    C5 = reinterpret<f64>(0x3F81111167A4D017); // __exp_data.poly[3] (0x1.1111167a4d017p-7)\n\n  let ux = reinterpret<u64>(x);\n  let abstop = u32(ux >> 52) & 0x7FF;\n  if (abstop - 0x3C9 >= 0x03F) {\n    if (abstop - 0x3C9 >= 0x80000000) return 1;\n    if (abstop >= 0x409) {\n      if (ux == 0xFFF0000000000000) return 0;\n      if (abstop >= 0x7FF) {\n        return 1.0 + x;\n      } else {\n        return select<f64>(0, Infinity, <i64>ux < 0);\n      }\n    }\n    // Large x is special cased below.\n    abstop = 0;\n  }\n\n  // exp(x) = 2^(k/N) * exp(r), with exp(r) in [2^(-1/2N),2^(1/2N)]\n  // x = ln2/N*k + r, with int k and r in [-ln2/2N, ln2/2N]\n  let z = InvLn2N * x;\n  // #if TOINT_INTRINSICS\n  // \tkd = roundtoint(z);\n  // \tki = converttoint(z);\n  // #elif EXP_USE_TOINT_NARROW\n  // \t// z - kd is in [-0.5-2^-16, 0.5] in all rounding modes.\n  // let kd = z + shift;\n  // let ki = reinterpret<u64>(kd) >> 16;\n  // let kd = <f64><i32>ki;\n  // #else\n  // z - kd is in [-1, 1] in non-nearest rounding modes.\n  let kd = z + shift;\n  let ki = reinterpret<u64>(kd);\n  kd -= shift;\n  // #endif\n  let r = x + kd * NegLn2hiN + kd * NegLn2loN;\n  // 2^(k/N) ~= scale * (1 + tail).\n  let idx = usize((ki & N_MASK) << 1);\n  let top = ki << (52 - EXP_TABLE_BITS);\n\n  let tail = reinterpret<f64>(load<u64>(EXP_DATA_TAB + (idx << alignof<u64>()))); // T[idx]\n  // This is only a valid scale when -1023*N < k < 1024*N\n  let sbits = load<u64>(EXP_DATA_TAB + (idx << alignof<u64>()), 1 << alignof<u64>()) + top; // T[idx + 1]\n  // exp(x) = 2^(k/N) * exp(r) ~= scale + scale * (tail + exp(r) - 1).\n  // Evaluation is optimized assuming superscalar pipelined execution.\n  let r2 = r * r;\n  // Without fma the worst case error is 0.25/N ulp larger.\n  // Worst case error is less than 0.5+1.11/N+(abs poly error * 2^53) ulp.\n  let tmp = tail + r + r2 * (C2 + r * C3) + r2 * r2 * (C4 + r * C5);\n  if (abstop == 0) return specialcase(tmp, sbits, ki);\n  let scale = reinterpret<f64>(sbits);\n  // Note: tmp == 0 or |tmp| > 2^-200 and scale > 2^-739, so there\n  // is no spurious underflow here even without fma.\n  return scale + scale * tmp;\n}\n\n//\n// Lookup data for exp2. See: https://git.musl-libc.org/cgit/musl/tree/src/math/exp2.c\n//\n\n// Handle cases that may overflow or underflow when computing the result that\n// is scale*(1+TMP) without intermediate rounding.  The bit representation of\n// scale is in SBITS, however it has a computed exponent that may have\n// overflown into the sign bit so that needs to be adjusted before using it as\n// a double.  (int32_t)KI is the k used in the argument reduction and exponent\n// adjustment of scale, positive k here means the result may overflow and\n// negative k means the result may underflow.\n// @ts-ignore: decorator\n@inline\nfunction specialcase2(tmp: f64, sbits: u64, ki: u64): f64 {\n  const Ox1p_1022 = reinterpret<f64>(0x10000000000000); // 0x1p-1022\n  let scale: f64;\n  if ((ki & 0x80000000) == 0) {\n    // k > 0, the exponent of scale might have overflowed by 1\n    sbits -= u64(1) << 52;\n    scale = reinterpret<f64>(sbits);\n    return 2 * (scale * tmp + scale);\n  }\n  // k < 0, need special care in the subnormal range\n  sbits += u64(1022) << 52;\n  scale = reinterpret<f64>(sbits);\n  let y = scale * tmp + scale;\n  if (y < 1.0) {\n    // Round y to the right precision before scaling it into the subnormal\n    // range to avoid double rounding that can cause 0.5+E/2 ulp error where\n    // E is the worst-case ulp error outside the subnormal range. So this\n    // is only useful if the goal is better than 1 ulp worst-case error.\n    let hi: f64, lo: f64;\n    lo = scale - y + scale * tmp;\n    hi = 1.0 + y;\n    lo = 1.0 - hi + y + lo;\n    y = (hi + lo) - 1.0;\n  }\n  return y * Ox1p_1022;\n}\n\n// @ts-ignore: decorator\n@inline\nexport function exp2_lut(x: f64): f64 {\n  const\n    N      = 1 << EXP_TABLE_BITS,\n    N_MASK = N - 1,\n    shift  = reinterpret<f64>(0x4338000000000000) / N; // 0x1.8p52\n\n  const\n    C1 = reinterpret<f64>(0x3FE62E42FEFA39EF), // 0x1.62e42fefa39efp-1\n    C2 = reinterpret<f64>(0x3FCEBFBDFF82C424), // 0x1.ebfbdff82c424p-3\n    C3 = reinterpret<f64>(0x3FAC6B08D70CF4B5), // 0x1.c6b08d70cf4b5p-5\n    C4 = reinterpret<f64>(0x3F83B2ABD24650CC), // 0x1.3b2abd24650ccp-7\n    C5 = reinterpret<f64>(0x3F55D7E09B4E3A84); // 0x1.5d7e09b4e3a84p-10\n\n  let ux = reinterpret<u64>(x);\n  let abstop = u32(ux >> 52) & 0x7ff;\n  if (abstop - 0x3C9 >= 0x03F) {\n    if (abstop - 0x3C9 >= 0x80000000) return 1.0;\n    if (abstop >= 0x409) {\n      if (ux == 0xFFF0000000000000) return 0;\n      if (abstop >= 0x7FF) return 1.0 + x;\n      if (<i64>ux >= 0) return Infinity;\n      else if (ux >= 0xC090CC0000000000) return 0;\n    }\n    if ((ux << 1) > 0x811A000000000000) abstop = 0; // Large x is special cased below.\n  }\n\n  // exp2(x) = 2^(k/N) * 2^r, with 2^r in [2^(-1/2N),2^(1/2N)].\n  // x = k/N + r, with int k and r in [-1/2N, 1/2N]\n  let kd = x + shift;\n  let ki = reinterpret<u64>(kd);\n  kd -= shift; // k/N for int k\n  let r = x - kd;\n  // 2^(k/N) ~= scale * (1 + tail)\n  let idx = usize((ki & N_MASK) << 1);\n  let top = ki << (52 - EXP_TABLE_BITS);\n\n  let tail = reinterpret<f64>(load<u64>(EXP_DATA_TAB + (idx << alignof<u64>()), 0 << alignof<u64>())); // T[idx])\n  // This is only a valid scale when -1023*N < k < 1024*N\n  let sbits = load<u64>(EXP_DATA_TAB + (idx << alignof<u64>()), 1 << alignof<u64>()) + top; // T[idx + 1]\n  // exp2(x) = 2^(k/N) * 2^r ~= scale + scale * (tail + 2^r - 1).\n  // Evaluation is optimized assuming superscalar pipelined execution\n  let r2 = r * r;\n  // Without fma the worst case error is 0.5/N ulp larger.\n  // Worst case error is less than 0.5+0.86/N+(abs poly error * 2^53) ulp.\n  let tmp = tail + r * C1 + r2 * (C2 + r * C3) + r2 * r2 * (C4 + r * C5);\n  if (abstop == 0) return specialcase2(tmp, sbits, ki);\n  let scale = reinterpret<f64>(sbits);\n  // Note: tmp == 0 or |tmp| > 2^-65 and scale > 2^-928, so there\n  // is no spurious underflow here even without fma.\n  return scale * tmp + scale;\n}\n\n//\n// Lookup data for log2. See: https://git.musl-libc.org/cgit/musl/tree/src/math/log2.c\n//\n\n// @ts-ignore: decorator\n@inline const LOG2_TABLE_BITS = 6;\n\n/* Algorithm:\n\n  x = 2^k z\n  log2(x) = k + log2(c) + log2(z/c)\n  log2(z/c) = poly(z/c - 1)\n\nwhere z is in [1.6p-1; 1.6p0] which is split into N subintervals and z falls\ninto the ith one, then table entries are computed as\n\n  tab[i].invc = 1/c\n  tab[i].logc = (double)log2(c)\n  tab2[i].chi = (double)c\n  tab2[i].clo = (double)(c - (double)c)\n\nwhere c is near the center of the subinterval and is chosen by trying +-2^29\nfloating point invc candidates around 1/center and selecting one for which\n\n  1) the rounding error in 0x1.8p10 + logc is 0,\n  2) the rounding error in z - chi - clo is < 0x1p-64 and\n  3) the rounding error in (double)log2(c) is minimized (< 0x1p-68).\n\nNote: 1) ensures that k + logc can be computed without rounding error, 2)\nensures that z/c - 1 can be computed as (z - chi - clo)*invc with close to a\nsingle rounding error when there is no fast fma for z*invc - 1, 3) ensures\nthat logc + poly(z/c - 1) has small error, however near x == 1 when\n|log2(x)| < 0x1p-4, this is not enough so that is special cased. */\n\n// @ts-ignore: decorator\n@lazy @inline const LOG2_DATA_TAB1 = memory.data<u64>([\n  //     invc       ,        logc\n  0x3FF724286BB1ACF8, 0xBFE1095FEECDB000,\n  0x3FF6E1F766D2CCA1, 0xBFE08494BD76D000,\n  0x3FF6A13D0E30D48A, 0xBFE00143AEE8F800,\n  0x3FF661EC32D06C85, 0xBFDEFEC5360B4000,\n  0x3FF623FA951198F8, 0xBFDDFDD91AB7E000,\n  0x3FF5E75BA4CF026C, 0xBFDCFFAE0CC79000,\n  0x3FF5AC055A214FB8, 0xBFDC043811FDA000,\n  0x3FF571ED0F166E1E, 0xBFDB0B67323AE000,\n  0x3FF53909590BF835, 0xBFDA152F5A2DB000,\n  0x3FF5014FED61ADDD, 0xBFD9217F5AF86000,\n  0x3FF4CAB88E487BD0, 0xBFD8304DB0719000,\n  0x3FF49539B4334FEE, 0xBFD74189F9A9E000,\n  0x3FF460CBDFAFD569, 0xBFD6552BB5199000,\n  0x3FF42D664EE4B953, 0xBFD56B23A29B1000,\n  0x3FF3FB01111DD8A6, 0xBFD483650F5FA000,\n  0x3FF3C995B70C5836, 0xBFD39DE937F6A000,\n  0x3FF3991C4AB6FD4A, 0xBFD2BAA1538D6000,\n  0x3FF3698E0CE099B5, 0xBFD1D98340CA4000,\n  0x3FF33AE48213E7B2, 0xBFD0FA853A40E000,\n  0x3FF30D191985BDB1, 0xBFD01D9C32E73000,\n  0x3FF2E025CAB271D7, 0xBFCE857DA2FA6000,\n  0x3FF2B404CF13CD82, 0xBFCCD3C8633D8000,\n  0x3FF288B02C7CCB50, 0xBFCB26034C14A000,\n  0x3FF25E2263944DE5, 0xBFC97C1C2F4FE000,\n  0x3FF234563D8615B1, 0xBFC7D6023F800000,\n  0x3FF20B46E33EAF38, 0xBFC633A71A05E000,\n  0x3FF1E2EEFDCDA3DD, 0xBFC494F5E9570000,\n  0x3FF1BB4A580B3930, 0xBFC2F9E424E0A000,\n  0x3FF19453847F2200, 0xBFC162595AFDC000,\n  0x3FF16E06C0D5D73C, 0xBFBF9C9A75BD8000,\n  0x3FF1485F47B7E4C2, 0xBFBC7B575BF9C000,\n  0x3FF12358AD0085D1, 0xBFB960C60FF48000,\n  0x3FF0FEF00F532227, 0xBFB64CE247B60000,\n  0x3FF0DB2077D03A8F, 0xBFB33F78B2014000,\n  0x3FF0B7E6D65980D9, 0xBFB0387D1A42C000,\n  0x3FF0953EFE7B408D, 0xBFAA6F9208B50000,\n  0x3FF07325CAC53B83, 0xBFA47A954F770000,\n  0x3FF05197E40D1B5C, 0xBF9D23A8C50C0000,\n  0x3FF03091C1208EA2, 0xBF916A2629780000,\n  0x3FF0101025B37E21, 0xBF7720F8D8E80000,\n  0x3FEFC07EF9CAA76B, 0x3F86FE53B1500000,\n  0x3FEF4465D3F6F184, 0x3FA11CCCE10F8000,\n  0x3FEECC079F84107F, 0x3FAC4DFC8C8B8000,\n  0x3FEE573A99975AE8, 0x3FB3AA321E574000,\n  0x3FEDE5D6F0BD3DE6, 0x3FB918A0D08B8000,\n  0x3FED77B681FF38B3, 0x3FBE72E9DA044000,\n  0x3FED0CB5724DE943, 0x3FC1DCD2507F6000,\n  0x3FECA4B2DC0E7563, 0x3FC476AB03DEA000,\n  0x3FEC3F8EE8D6CB51, 0x3FC7074377E22000,\n  0x3FEBDD2B4F020C4C, 0x3FC98EDE8BA94000,\n  0x3FEB7D6C006015CA, 0x3FCC0DB86AD2E000,\n  0x3FEB20366E2E338F, 0x3FCE840AAFCEE000,\n  0x3FEAC57026295039, 0x3FD0790AB4678000,\n  0x3FEA6D01BC2731DD, 0x3FD1AC056801C000,\n  0x3FEA16D3BC3FF18B, 0x3FD2DB11D4FEE000,\n  0x3FE9C2D14967FEAD, 0x3FD406464EC58000,\n  0x3FE970E4F47C9902, 0x3FD52DBE093AF000,\n  0x3FE920FB3982BCF2, 0x3FD651902050D000,\n  0x3FE8D30187F759F1, 0x3FD771D2CDEAF000,\n  0x3FE886E5EBB9F66D, 0x3FD88E9C857D9000,\n  0x3FE83C97B658B994, 0x3FD9A80155E16000,\n  0x3FE7F405FFC61022, 0x3FDABE186ED3D000,\n  0x3FE7AD22181415CA, 0x3FDBD0F2AEA0E000,\n  0x3FE767DCF99EFF8C, 0x3FDCE0A43DBF4000\n]);\n\n// @ts-ignore: decorator\n@lazy @inline const LOG2_DATA_TAB2 = memory.data<u64>([\n  //      chi       ,         clo\n  0x3FE6200012B90A8E, 0x3C8904AB0644B605,\n  0x3FE66000045734A6, 0x3C61FF9BEA62F7A9,\n  0x3FE69FFFC325F2C5, 0x3C827ECFCB3C90BA,\n  0x3FE6E00038B95A04, 0x3C88FF8856739326,\n  0x3FE71FFFE09994E3, 0x3C8AFD40275F82B1,\n  0x3FE7600015590E10, 0xBC72FD75B4238341,\n  0x3FE7A00012655BD5, 0x3C7808E67C242B76,\n  0x3FE7E0003259E9A6, 0xBC6208E426F622B7,\n  0x3FE81FFFEDB4B2D2, 0xBC8402461EA5C92F,\n  0x3FE860002DFAFCC3, 0x3C6DF7F4A2F29A1F,\n  0x3FE89FFFF78C6B50, 0xBC8E0453094995FD,\n  0x3FE8E00039671566, 0xBC8A04F3BEC77B45,\n  0x3FE91FFFE2BF1745, 0xBC77FA34400E203C,\n  0x3FE95FFFCC5C9FD1, 0xBC76FF8005A0695D,\n  0x3FE9A0003BBA4767, 0x3C70F8C4C4EC7E03,\n  0x3FE9DFFFE7B92DA5, 0x3C8E7FD9478C4602,\n  0x3FEA1FFFD72EFDAF, 0xBC6A0C554DCDAE7E,\n  0x3FEA5FFFDE04FF95, 0x3C867DA98CE9B26B,\n  0x3FEA9FFFCA5E8D2B, 0xBC8284C9B54C13DE,\n  0x3FEADFFFDDAD03EA, 0x3C5812C8EA602E3C,\n  0x3FEB1FFFF10D3D4D, 0xBC8EFADDAD27789C,\n  0x3FEB5FFFCE21165A, 0x3C53CB1719C61237,\n  0x3FEB9FFFD950E674, 0x3C73F7D94194CE00,\n  0x3FEBE000139CA8AF, 0x3C750AC4215D9BC0,\n  0x3FEC20005B46DF99, 0x3C6BEEA653E9C1C9,\n  0x3FEC600040B9F7AE, 0xBC7C079F274A70D6,\n  0x3FECA0006255FD8A, 0xBC7A0B4076E84C1F,\n  0x3FECDFFFD94C095D, 0x3C88F933F99AB5D7,\n  0x3FED1FFFF975D6CF, 0xBC582C08665FE1BE,\n  0x3FED5FFFA2561C93, 0xBC7B04289BD295F3,\n  0x3FED9FFF9D228B0C, 0x3C870251340FA236,\n  0x3FEDE00065BC7E16, 0xBC75011E16A4D80C,\n  0x3FEE200002F64791, 0x3C89802F09EF62E0,\n  0x3FEE600057D7A6D8, 0xBC7E0B75580CF7FA,\n  0x3FEEA00027EDC00C, 0xBC8C848309459811,\n  0x3FEEE0006CF5CB7C, 0xBC8F8027951576F4,\n  0x3FEF2000782B7DCC, 0xBC8F81D97274538F,\n  0x3FEF6000260C450A, 0xBC4071002727FFDC,\n  0x3FEF9FFFE88CD533, 0xBC581BDCE1FDA8B0,\n  0x3FEFDFFFD50F8689, 0x3C87F91ACB918E6E,\n  0x3FF0200004292367, 0x3C9B7FF365324681,\n  0x3FF05FFFE3E3D668, 0x3C86FA08DDAE957B,\n  0x3FF0A0000A85A757, 0xBC57E2DE80D3FB91,\n  0x3FF0E0001A5F3FCC, 0xBC91823305C5F014,\n  0x3FF11FFFF8AFBAF5, 0xBC8BFABB6680BAC2,\n  0x3FF15FFFE54D91AD, 0xBC9D7F121737E7EF,\n  0x3FF1A00011AC36E1, 0x3C9C000A0516F5FF,\n  0x3FF1E00019C84248, 0xBC9082FBE4DA5DA0,\n  0x3FF220000FFE5E6E, 0xBC88FDD04C9CFB43,\n  0x3FF26000269FD891, 0x3C8CFE2A7994D182,\n  0x3FF2A00029A6E6DA, 0xBC700273715E8BC5,\n  0x3FF2DFFFE0293E39, 0x3C9B7C39DAB2A6F9,\n  0x3FF31FFFF7DCF082, 0x3C7DF1336EDC5254,\n  0x3FF35FFFF05A8B60, 0xBC9E03564CCD31EB,\n  0x3FF3A0002E0EAECC, 0x3C75F0E74BD3A477,\n  0x3FF3E000043BB236, 0x3C9C7DCB149D8833,\n  0x3FF4200002D187FF, 0x3C7E08AFCF2D3D28,\n  0x3FF460000D387CB1, 0x3C820837856599A6,\n  0x3FF4A00004569F89, 0xBC89FA5C904FBCD2,\n  0x3FF4E000043543F3, 0xBC781125ED175329,\n  0x3FF51FFFCC027F0F, 0x3C9883D8847754DC,\n  0x3FF55FFFFD87B36F, 0xBC8709E731D02807,\n  0x3FF59FFFF21DF7BA, 0x3C87F79F68727B02,\n  0x3FF5DFFFEBFC3481, 0xBC9180902E30E93E\n]);\n\n// @ts-ignore: decorator\n@inline\nexport function log2_lut(x: f64): f64 {\n  const N_MASK = (1 << LOG2_TABLE_BITS) - 1;\n\n  const\n    LO: u64 = 0x3FEEA4AF00000000, // reinterpret<u64>(1.0 - 0x1.5b51p-5)\n    HI: u64 = 0x3FF0B55900000000; // reinterpret<u64>(1.0 + 0x1.6ab2p-5)\n\n  const\n    InvLn2hi = reinterpret<f64>(0x3FF7154765200000), // 0x1.7154765200000p+0\n    InvLn2lo = reinterpret<f64>(0x3DE705FC2EEFA200), // 0x1.705fc2eefa200p-33\n    Ox1p52   = reinterpret<f64>(0x4330000000000000); // 0x1p52\n\n  const\n    B0 = reinterpret<f64>(0xBFE71547652B82FE), // -0x1.71547652b82fep-1\n    B1 = reinterpret<f64>(0x3FDEC709DC3A03F7), //  0x1.ec709dc3a03f7p-2\n    B2 = reinterpret<f64>(0xBFD71547652B7C3F), // -0x1.71547652b7c3fp-2\n    B3 = reinterpret<f64>(0x3FD2776C50F05BE4), //  0x1.2776c50f05be4p-2\n    B4 = reinterpret<f64>(0xBFCEC709DD768FE5), // -0x1.ec709dd768fe5p-3\n    B5 = reinterpret<f64>(0x3FCA61761EC4E736), //  0x1.a61761ec4e736p-3\n    B6 = reinterpret<f64>(0xBFC7153FBC64A79B), // -0x1.7153fbc64a79bp-3\n    B7 = reinterpret<f64>(0x3FC484D154F01B4A), //  0x1.484d154f01b4ap-3\n    B8 = reinterpret<f64>(0xBFC289E4A72C383C), // -0x1.289e4a72c383cp-3\n    B9 = reinterpret<f64>(0x3FC0B32F285AEE66); //  0x1.0b32f285aee66p-3\n\n  const\n    A0 = reinterpret<f64>(0xBFE71547652B8339), // -0x1.71547652b8339p-1\n    A1 = reinterpret<f64>(0x3FDEC709DC3A04BE), //  0x1.ec709dc3a04bep-2\n    A2 = reinterpret<f64>(0xBFD7154764702FFB), // -0x1.7154764702ffbp-2\n    A3 = reinterpret<f64>(0x3FD2776C50034C48), //  0x1.2776c50034c48p-2\n    A4 = reinterpret<f64>(0xBFCEC7B328EA92BC), // -0x1.ec7b328ea92bcp-3\n    A5 = reinterpret<f64>(0x3FCA6225E117F92E); //  0x1.a6225e117f92ep-3\n\n  let ix = reinterpret<u64>(x);\n  if (ix - LO < HI - LO) {\n    let r = x - 1.0;\n    // #if __FP_FAST_FMA\n    //     hi = r * InvLn2hi;\n    //     lo = r * InvLn2lo + __builtin_fma(r, InvLn2hi, -hi);\n    // #else\n    let rhi = reinterpret<f64>(reinterpret<u64>(r) & 0xFFFFFFFF00000000);\n    let rlo = r - rhi;\n    let hi  = rhi * InvLn2hi;\n    let lo  = rlo * InvLn2hi + r * InvLn2lo;\n    // #endif\n    let r2 = r * r; // rounding error: 0x1p-62\n    let r4 = r2 * r2;\n    // Worst-case error is less than 0.54 ULP (0.55 ULP without fma)\n    let p = r2 * (B0 + r * B1);\n    let y = hi + p;\n    lo += hi - y + p;\n    lo += r4 * (B2 + r * B3 + r2 * (B4 + r * B5) +\n          r4 * (B6 + r * B7 + r2 * (B8 + r * B9)));\n    return y + lo;\n  }\n  let top = u32(ix >> 48);\n  if (top - 0x0010 >= 0x7ff0 - 0x0010) {\n    // x < 0x1p-1022 or inf or nan.\n    if ((ix << 1) == 0) return -1.0 / (x * x);\n    if (ix == 0x7FF0000000000000) return x; // log(inf) == inf\n    if ((top & 0x8000) || (top & 0x7FF0) == 0x7FF0) return (x - x) / (x - x);\n    // x is subnormal, normalize it.\n    ix = reinterpret<u64>(x * Ox1p52);\n    ix -= u64(52) << 52;\n  }\n\n  // x = 2^k z; where z is in range [OFF,2*OFF) and exact.\n  // The range is split into N subintervals.\n  // The ith subinterval contains z and c is near its center.\n  let tmp  = ix - 0x3FE6000000000000;\n  let i    = <usize>((tmp >> (52 - LOG2_TABLE_BITS)) & N_MASK);\n  let k    = <i64>tmp >> 52;\n  let iz   = ix - (tmp & 0xFFF0000000000000);\n\n  let invc = load<f64>(LOG2_DATA_TAB1  + (i << (1 + alignof<f64>())), 0 << alignof<f64>()); // T[i].invc;\n  let logc = load<f64>(LOG2_DATA_TAB1  + (i << (1 + alignof<f64>())), 1 << alignof<f64>()); // T[i].logc;\n  let z    = reinterpret<f64>(iz);\n  let kd   = <f64>k;\n\n  // log2(x) = log2(z/c) + log2(c) + k.\n  // r ~= z/c - 1, |r| < 1/(2*N).\n  // #if __FP_FAST_FMA\n  // \t// rounding error: 0x1p-55/N.\n  // \tr = __builtin_fma(z, invc, -1.0);\n  // \tt1 = r * InvLn2hi;\n  // \tt2 = r * InvLn2lo + __builtin_fma(r, InvLn2hi, -t1);\n  // #else\n  // rounding error: 0x1p-55/N + 0x1p-65.\n  let chi = load<f64>(LOG2_DATA_TAB2 + (i << (1 + alignof<f64>())), 0 << alignof<f64>()); // T[i].chi;\n  let clo = load<f64>(LOG2_DATA_TAB2 + (i << (1 + alignof<f64>())), 1 << alignof<f64>()); // T[i].clo;\n\n  let r   = (z - chi - clo) * invc;\n  let rhi = reinterpret<f64>(reinterpret<u64>(r) & 0xFFFFFFFF00000000);\n  let rlo = r - rhi;\n  let t1  = rhi * InvLn2hi;\n  let t2  = rlo * InvLn2hi + r * InvLn2lo;\n  // #endif\n\n  // hi + lo = r/ln2 + log2(c) + k\n  let t3 = kd + logc;\n  let hi = t3 + t1;\n  let lo = t3 - hi + t1 + t2;\n\n  // log2(r+1) = r/ln2 + r^2*poly(r)\n  // Evaluation is optimized assuming superscalar pipelined execution\n  let r2 = r * r; // rounding error: 0x1p-54/N^2\n  // Worst-case error if |y| > 0x1p-4: 0.547 ULP (0.550 ULP without fma).\n  // ~ 0.5 + 2/N/ln2 + abs-poly-error*0x1p56 ULP (+ 0.003 ULP without fma).\n  let p = A0 + r * A1 + r2 * (A2 + r * A3) + (r2 * r2) * (A4 + r * A5);\n  return lo + r2 * p + hi;\n}\n\n//\n// Lookup data for log. See: https://git.musl-libc.org/cgit/musl/tree/src/math/log.c\n//\n\n// @ts-ignore: decorator\n@inline const LOG_TABLE_BITS = 7;\n\n/* Algorithm:\n\n  x = 2^k z\n  log(x) = k ln2 + log(c) + log(z/c)\n  log(z/c) = poly(z/c - 1)\n\nwhere z is in [1.6p-1; 1.6p0] which is split into N subintervals and z falls\ninto the ith one, then table entries are computed as\n\n  tab[i].invc = 1/c\n  tab[i].logc = (double)log(c)\n  tab2[i].chi = (double)c\n  tab2[i].clo = (double)(c - (double)c)\n\nwhere c is near the center of the subinterval and is chosen by trying +-2^29\nfloating point invc candidates around 1/center and selecting one for which\n\n  1) the rounding error in 0x1.8p9 + logc is 0,\n  2) the rounding error in z - chi - clo is < 0x1p-66 and\n  3) the rounding error in (double)log(c) is minimized (< 0x1p-66).\n\nNote: 1) ensures that k*ln2hi + logc can be computed without rounding error,\n2) ensures that z/c - 1 can be computed as (z - chi - clo)*invc with close to\na single rounding error when there is no fast fma for z*invc - 1, 3) ensures\nthat logc + poly(z/c - 1) has small error, however near x == 1 when\n|log(x)| < 0x1p-4, this is not enough so that is special cased.*/\n\n// @ts-ignore: decorator\n@lazy @inline const LOG_DATA_TAB1 = memory.data<u64>([\n  //      invc      ,        logc\n  0x3FF734F0C3E0DE9F, 0xBFD7CC7F79E69000,\n  0x3FF713786A2CE91F, 0xBFD76FEEC20D0000,\n  0x3FF6F26008FAB5A0, 0xBFD713E31351E000,\n  0x3FF6D1A61F138C7D, 0xBFD6B85B38287800,\n  0x3FF6B1490BC5B4D1, 0xBFD65D5590807800,\n  0x3FF69147332F0CBA, 0xBFD602D076180000,\n  0x3FF6719F18224223, 0xBFD5A8CA86909000,\n  0x3FF6524F99A51ED9, 0xBFD54F4356035000,\n  0x3FF63356AA8F24C4, 0xBFD4F637C36B4000,\n  0x3FF614B36B9DDC14, 0xBFD49DA7FDA85000,\n  0x3FF5F66452C65C4C, 0xBFD445923989A800,\n  0x3FF5D867B5912C4F, 0xBFD3EDF439B0B800,\n  0x3FF5BABCCB5B90DE, 0xBFD396CE448F7000,\n  0x3FF59D61F2D91A78, 0xBFD3401E17BDA000,\n  0x3FF5805612465687, 0xBFD2E9E2EF468000,\n  0x3FF56397CEE76BD3, 0xBFD2941B3830E000,\n  0x3FF54725E2A77F93, 0xBFD23EC58CDA8800,\n  0x3FF52AFF42064583, 0xBFD1E9E129279000,\n  0x3FF50F22DBB2BDDF, 0xBFD1956D2B48F800,\n  0x3FF4F38F4734DED7, 0xBFD141679AB9F800,\n  0x3FF4D843CFDE2840, 0xBFD0EDD094EF9800,\n  0x3FF4BD3EC078A3C8, 0xBFD09AA518DB1000,\n  0x3FF4A27FC3E0258A, 0xBFD047E65263B800,\n  0x3FF4880524D48434, 0xBFCFEB224586F000,\n  0x3FF46DCE1B192D0B, 0xBFCF474A7517B000,\n  0x3FF453D9D3391854, 0xBFCEA4443D103000,\n  0x3FF43A2744B4845A, 0xBFCE020D44E9B000,\n  0x3FF420B54115F8FB, 0xBFCD60A22977F000,\n  0x3FF40782DA3EF4B1, 0xBFCCC00104959000,\n  0x3FF3EE8F5D57FE8F, 0xBFCC202956891000,\n  0x3FF3D5D9A00B4CE9, 0xBFCB81178D811000,\n  0x3FF3BD60C010C12B, 0xBFCAE2C9CCD3D000,\n  0x3FF3A5242B75DAB8, 0xBFCA45402E129000,\n  0x3FF38D22CD9FD002, 0xBFC9A877681DF000,\n  0x3FF3755BC5847A1C, 0xBFC90C6D69483000,\n  0x3FF35DCE49AD36E2, 0xBFC87120A645C000,\n  0x3FF34679984DD440, 0xBFC7D68FB4143000,\n  0x3FF32F5CCEFFCB24, 0xBFC73CB83C627000,\n  0x3FF3187775A10D49, 0xBFC6A39A9B376000,\n  0x3FF301C8373E3990, 0xBFC60B3154B7A000,\n  0x3FF2EB4EBB95F841, 0xBFC5737D76243000,\n  0x3FF2D50A0219A9D1, 0xBFC4DC7B8FC23000,\n  0x3FF2BEF9A8B7FD2A, 0xBFC4462C51D20000,\n  0x3FF2A91C7A0C1BAB, 0xBFC3B08ABC830000,\n  0x3FF293726014B530, 0xBFC31B996B490000,\n  0x3FF27DFA5757A1F5, 0xBFC2875490A44000,\n  0x3FF268B39B1D3BBF, 0xBFC1F3B9F879A000,\n  0x3FF2539D838FF5BD, 0xBFC160C8252CA000,\n  0x3FF23EB7AAC9083B, 0xBFC0CE7F57F72000,\n  0x3FF22A012BA940B6, 0xBFC03CDC49FEA000,\n  0x3FF2157996CC4132, 0xBFBF57BDBC4B8000,\n  0x3FF201201DD2FC9B, 0xBFBE370896404000,\n  0x3FF1ECF4494D480B, 0xBFBD17983EF94000,\n  0x3FF1D8F5528F6569, 0xBFBBF9674ED8A000,\n  0x3FF1C52311577E7C, 0xBFBADC79202F6000,\n  0x3FF1B17C74CB26E9, 0xBFB9C0C3E7288000,\n  0x3FF19E010C2C1AB6, 0xBFB8A646B372C000,\n  0x3FF18AB07BB670BD, 0xBFB78D01B3AC0000,\n  0x3FF1778A25EFBCB6, 0xBFB674F145380000,\n  0x3FF1648D354C31DA, 0xBFB55E0E6D878000,\n  0x3FF151B990275FDD, 0xBFB4485CDEA1E000,\n  0x3FF13F0EA432D24C, 0xBFB333D94D6AA000,\n  0x3FF12C8B7210F9DA, 0xBFB22079F8C56000,\n  0x3FF11A3028ECB531, 0xBFB10E4698622000,\n  0x3FF107FBDA8434AF, 0xBFAFFA6C6AD20000,\n  0x3FF0F5EE0F4E6BB3, 0xBFADDA8D4A774000,\n  0x3FF0E4065D2A9FCE, 0xBFABBCECE4850000,\n  0x3FF0D244632CA521, 0xBFA9A1894012C000,\n  0x3FF0C0A77CE2981A, 0xBFA788583302C000,\n  0x3FF0AF2F83C636D1, 0xBFA5715E67D68000,\n  0x3FF09DDB98A01339, 0xBFA35C8A49658000,\n  0x3FF08CABAF52E7DF, 0xBFA149E364154000,\n  0x3FF07B9F2F4E28FB, 0xBF9E72C082EB8000,\n  0x3FF06AB58C358F19, 0xBF9A55F152528000,\n  0x3FF059EEA5ECF92C, 0xBF963D62CF818000,\n  0x3FF04949CDD12C90, 0xBF9228FB8CAA0000,\n  0x3FF038C6C6F0ADA9, 0xBF8C317B20F90000,\n  0x3FF02865137932A9, 0xBF8419355DAA0000,\n  0x3FF0182427EA7348, 0xBF781203C2EC0000,\n  0x3FF008040614B195, 0xBF60040979240000,\n  0x3FEFE01FF726FA1A, 0x3F6FEFF384900000,\n  0x3FEFA11CC261EA74, 0x3F87DC41353D0000,\n  0x3FEF6310B081992E, 0x3F93CEA3C4C28000,\n  0x3FEF25F63CEEADCD, 0x3F9B9FC114890000,\n  0x3FEEE9C8039113E7, 0x3FA1B0D8CE110000,\n  0x3FEEAE8078CBB1AB, 0x3FA58A5BD001C000,\n  0x3FEE741AA29D0C9B, 0x3FA95C8340D88000,\n  0x3FEE3A91830A99B5, 0x3FAD276AEF578000,\n  0x3FEE01E009609A56, 0x3FB07598E598C000,\n  0x3FEDCA01E577BB98, 0x3FB253F5E30D2000,\n  0x3FED92F20B7C9103, 0x3FB42EDD8B380000,\n  0x3FED5CAC66FB5CCE, 0x3FB606598757C000,\n  0x3FED272CAA5EDE9D, 0x3FB7DA76356A0000,\n  0x3FECF26E3E6B2CCD, 0x3FB9AB434E1C6000,\n  0x3FECBE6DA2A77902, 0x3FBB78C7BB0D6000,\n  0x3FEC8B266D37086D, 0x3FBD431332E72000,\n  0x3FEC5894BD5D5804, 0x3FBF0A3171DE6000,\n  0x3FEC26B533BB9F8C, 0x3FC067152B914000,\n  0x3FEBF583EEECE73F, 0x3FC147858292B000,\n  0x3FEBC4FD75DB96C1, 0x3FC2266ECDCA3000,\n  0x3FEB951E0C864A28, 0x3FC303D7A6C55000,\n  0x3FEB65E2C5EF3E2C, 0x3FC3DFC33C331000,\n  0x3FEB374867C9888B, 0x3FC4BA366B7A8000,\n  0x3FEB094B211D304A, 0x3FC5933928D1F000,\n  0x3FEADBE885F2EF7E, 0x3FC66ACD2418F000,\n  0x3FEAAF1D31603DA2, 0x3FC740F8EC669000,\n  0x3FEA82E63FD358A7, 0x3FC815C0F51AF000,\n  0x3FEA5740EF09738B, 0x3FC8E92954F68000,\n  0x3FEA2C2A90AB4B27, 0x3FC9BB3602F84000,\n  0x3FEA01A01393F2D1, 0x3FCA8BED1C2C0000,\n  0x3FE9D79F24DB3C1B, 0x3FCB5B515C01D000,\n  0x3FE9AE2505C7B190, 0x3FCC2967CCBCC000,\n  0x3FE9852EF297CE2F, 0x3FCCF635D5486000,\n  0x3FE95CBAEEA44B75, 0x3FCDC1BD3446C000,\n  0x3FE934C69DE74838, 0x3FCE8C01B8CFE000,\n  0x3FE90D4F2F6752E6, 0x3FCF5509C0179000,\n  0x3FE8E6528EFFD79D, 0x3FD00E6C121FB800,\n  0x3FE8BFCE9FCC007C, 0x3FD071B80E93D000,\n  0x3FE899C0DABEC30E, 0x3FD0D46B9E867000,\n  0x3FE87427AA2317FB, 0x3FD13687334BD000,\n  0x3FE84F00ACB39A08, 0x3FD1980D67234800,\n  0x3FE82A49E8653E55, 0x3FD1F8FFE0CC8000,\n  0x3FE8060195F40260, 0x3FD2595FD7636800,\n  0x3FE7E22563E0A329, 0x3FD2B9300914A800,\n  0x3FE7BEB377DCB5AD, 0x3FD3187210436000,\n  0x3FE79BAA679725C2, 0x3FD377266DEC1800,\n  0x3FE77907F2170657, 0x3FD3D54FFBAF3000,\n  0x3FE756CADBD6130C, 0x3FD432EEE32FE000\n]);\n\n// @ts-ignore: decorator\n@lazy @inline const LOG_DATA_TAB2 = memory.data<u64>([\n  //      chi       ,         clo\n  0x3FE61000014FB66B, 0x3C7E026C91425B3C,\n  0x3FE63000034DB495, 0x3C8DBFEA48005D41,\n  0x3FE650000D94D478, 0x3C8E7FA786D6A5B7,\n  0x3FE67000074E6FAD, 0x3C61FCEA6B54254C,\n  0x3FE68FFFFEDF0FAE, 0xBC7C7E274C590EFD,\n  0x3FE6B0000763C5BC, 0xBC8AC16848DCDA01,\n  0x3FE6D0001E5CC1F6, 0x3C833F1C9D499311,\n  0x3FE6EFFFEB05F63E, 0xBC7E80041AE22D53,\n  0x3FE710000E869780, 0x3C7BFF6671097952,\n  0x3FE72FFFFC67E912, 0x3C8C00E226BD8724,\n  0x3FE74FFFDF81116A, 0xBC6E02916EF101D2,\n  0x3FE770000F679C90, 0xBC67FC71CD549C74,\n  0x3FE78FFFFA7EC835, 0x3C81BEC19EF50483,\n  0x3FE7AFFFFE20C2E6, 0xBC707E1729CC6465,\n  0x3FE7CFFFED3FC900, 0xBC808072087B8B1C,\n  0x3FE7EFFFE9261A76, 0x3C8DC0286D9DF9AE,\n  0x3FE81000049CA3E8, 0x3C897FD251E54C33,\n  0x3FE8300017932C8F, 0xBC8AFEE9B630F381,\n  0x3FE850000633739C, 0x3C89BFBF6B6535BC,\n  0x3FE87000204289C6, 0xBC8BBF65F3117B75,\n  0x3FE88FFFEBF57904, 0xBC89006EA23DCB57,\n  0x3FE8B00022BC04DF, 0xBC7D00DF38E04B0A,\n  0x3FE8CFFFE50C1B8A, 0xBC88007146FF9F05,\n  0x3FE8EFFFFC918E43, 0x3C83817BD07A7038,\n  0x3FE910001EFA5FC7, 0x3C893E9176DFB403,\n  0x3FE9300013467BB9, 0x3C7F804E4B980276,\n  0x3FE94FFFE6EE076F, 0xBC8F7EF0D9FF622E,\n  0x3FE96FFFDE3C12D1, 0xBC7082AA962638BA,\n  0x3FE98FFFF4458A0D, 0xBC87801B9164A8EF,\n  0x3FE9AFFFDD982E3E, 0xBC8740E08A5A9337,\n  0x3FE9CFFFED49FB66, 0x3C3FCE08C19BE000,\n  0x3FE9F00020F19C51, 0xBC8A3FAA27885B0A,\n  0x3FEA10001145B006, 0x3C74FF489958DA56,\n  0x3FEA300007BBF6FA, 0x3C8CBEAB8A2B6D18,\n  0x3FEA500010971D79, 0x3C88FECADD787930,\n  0x3FEA70001DF52E48, 0xBC8F41763DD8ABDB,\n  0x3FEA90001C593352, 0xBC8EBF0284C27612,\n  0x3FEAB0002A4F3E4B, 0xBC69FD043CFF3F5F,\n  0x3FEACFFFD7AE1ED1, 0xBC823EE7129070B4,\n  0x3FEAEFFFEE510478, 0x3C6A063EE00EDEA3,\n  0x3FEB0FFFDB650D5B, 0x3C5A06C8381F0AB9,\n  0x3FEB2FFFFEAACA57, 0xBC79011E74233C1D,\n  0x3FEB4FFFD995BADC, 0xBC79FF1068862A9F,\n  0x3FEB7000249E659C, 0x3C8AFF45D0864F3E,\n  0x3FEB8FFFF9871640, 0x3C7CFE7796C2C3F9,\n  0x3FEBAFFFD204CB4F, 0xBC63FF27EEF22BC4,\n  0x3FEBCFFFD2415C45, 0xBC6CFFB7EE3BEA21,\n  0x3FEBEFFFF86309DF, 0xBC814103972E0B5C,\n  0x3FEC0FFFE1B57653, 0x3C8BC16494B76A19,\n  0x3FEC2FFFF1FA57E3, 0xBC64FEEF8D30C6ED,\n  0x3FEC4FFFDCBFE424, 0xBC843F68BCEC4775,\n  0x3FEC6FFFED54B9F7, 0x3C847EA3F053E0EC,\n  0x3FEC8FFFEB998FD5, 0x3C7383068DF992F1,\n  0x3FECB0002125219A, 0xBC68FD8E64180E04,\n  0x3FECCFFFDD94469C, 0x3C8E7EBE1CC7EA72,\n  0x3FECEFFFEAFDC476, 0x3C8EBE39AD9F88FE,\n  0x3FED1000169AF82B, 0x3C757D91A8B95A71,\n  0x3FED30000D0FF71D, 0x3C89C1906970C7DA,\n  0x3FED4FFFEA790FC4, 0xBC580E37C558FE0C,\n  0x3FED70002EDC87E5, 0xBC7F80D64DC10F44,\n  0x3FED900021DC82AA, 0xBC747C8F94FD5C5C,\n  0x3FEDAFFFD86B0283, 0x3C8C7F1DC521617E,\n  0x3FEDD000296C4739, 0x3C88019EB2FFB153,\n  0x3FEDEFFFE54490F5, 0x3C6E00D2C652CC89,\n  0x3FEE0FFFCDABF694, 0xBC7F8340202D69D2,\n  0x3FEE2FFFDB52C8DD, 0x3C7B00C1CA1B0864,\n  0x3FEE4FFFF24216EF, 0x3C72FFA8B094AB51,\n  0x3FEE6FFFE88A5E11, 0xBC57F673B1EFBE59,\n  0x3FEE9000119EFF0D, 0xBC84808D5E0BC801,\n  0x3FEEAFFFDFA51744, 0x3C780006D54320B5,\n  0x3FEED0001A127FA1, 0xBC5002F860565C92,\n  0x3FEEF00007BABCC4, 0xBC8540445D35E611,\n  0x3FEF0FFFF57A8D02, 0xBC4FFB3139EF9105,\n  0x3FEF30001EE58AC7, 0x3C8A81ACF2731155,\n  0x3FEF4FFFF5823494, 0x3C8A3F41D4D7C743,\n  0x3FEF6FFFFCA94C6B, 0xBC6202F41C987875,\n  0x3FEF8FFFE1F9C441, 0x3C777DD1F477E74B,\n  0x3FEFAFFFD2E0E37E, 0xBC6F01199A7CA331,\n  0x3FEFD0001C77E49E, 0x3C7181EE4BCEACB1,\n  0x3FEFEFFFF7E0C331, 0xBC6E05370170875A,\n  0x3FF00FFFF465606E, 0xBC8A7EAD491C0ADA,\n  0x3FF02FFFF3867A58, 0xBC977F69C3FCB2E0,\n  0x3FF04FFFFDFC0D17, 0x3C97BFFE34CB945B,\n  0x3FF0700003CD4D82, 0x3C820083C0E456CB,\n  0x3FF08FFFF9F2CBE8, 0xBC6DFFDFBE37751A,\n  0x3FF0B000010CDA65, 0xBC913F7FAEE626EB,\n  0x3FF0D00001A4D338, 0x3C807DFA79489FF7,\n  0x3FF0EFFFFADAFDFD, 0xBC77040570D66BC0,\n  0x3FF110000BBAFD96, 0x3C8E80D4846D0B62,\n  0x3FF12FFFFAE5F45D, 0x3C9DBFFA64FD36EF,\n  0x3FF150000DD59AD9, 0x3C9A0077701250AE,\n  0x3FF170000F21559A, 0x3C8DFDF9E2E3DEEE,\n  0x3FF18FFFFC275426, 0x3C910030DC3B7273,\n  0x3FF1B000123D3C59, 0x3C997F7980030188,\n  0x3FF1CFFFF8299EB7, 0xBC65F932AB9F8C67,\n  0x3FF1EFFFF48AD400, 0x3C937FBF9DA75BEB,\n  0x3FF210000C8B86A4, 0x3C9F806B91FD5B22,\n  0x3FF2300003854303, 0x3C93FFC2EB9FBF33,\n  0x3FF24FFFFFBCF684, 0x3C7601E77E2E2E72,\n  0x3FF26FFFF52921D9, 0x3C7FFCBB767F0C61,\n  0x3FF2900014933A3C, 0xBC7202CA3C02412B,\n  0x3FF2B00014556313, 0xBC92808233F21F02,\n  0x3FF2CFFFEBFE523B, 0xBC88FF7E384FDCF2,\n  0x3FF2F0000BB8AD96, 0xBC85FF51503041C5,\n  0x3FF30FFFFB7AE2AF, 0xBC810071885E289D,\n  0x3FF32FFFFEAC5F7F, 0xBC91FF5D3FB7B715,\n  0x3FF350000CA66756, 0x3C957F82228B82BD,\n  0x3FF3700011FBF721, 0x3C8000BAC40DD5CC,\n  0x3FF38FFFF9592FB9, 0xBC943F9D2DB2A751,\n  0x3FF3B00004DDD242, 0x3C857F6B707638E1,\n  0x3FF3CFFFF5B2C957, 0x3C7A023A10BF1231,\n  0x3FF3EFFFEAB0B418, 0x3C987F6D66B152B0,\n  0x3FF410001532AFF4, 0x3C67F8375F198524,\n  0x3FF4300017478B29, 0x3C8301E672DC5143,\n  0x3FF44FFFE795B463, 0x3C89FF69B8B2895A,\n  0x3FF46FFFE80475E0, 0xBC95C0B19BC2F254,\n  0x3FF48FFFEF6FC1E7, 0x3C9B4009F23A2A72,\n  0x3FF4AFFFE5BEA704, 0xBC94FFB7BF0D7D45,\n  0x3FF4D000171027DE, 0xBC99C06471DC6A3D,\n  0x3FF4F0000FF03EE2, 0x3C977F890B85531C,\n  0x3FF5100012DC4BD1, 0x3C6004657166A436,\n  0x3FF530001605277A, 0xBC96BFCECE233209,\n  0x3FF54FFFECDB704C, 0xBC8902720505A1D7,\n  0x3FF56FFFEF5F54A9, 0x3C9BBFE60EC96412,\n  0x3FF5900017E61012, 0x3C887EC581AFEF90,\n  0x3FF5B00003C93E92, 0xBC9F41080ABF0CC0,\n  0x3FF5D0001D4919BC, 0xBC98812AFB254729,\n  0x3FF5EFFFE7B87A89, 0xBC947EB780ED6904\n]);\n\n// @ts-ignore: decorator\n@inline\nexport function log_lut(x: f64): f64 {\n  const N_MASK = (1 << LOG_TABLE_BITS) - 1;\n\n  const\n    B0  = reinterpret<f64>(0xBFE0000000000000), // -0x1p-1\n    B1  = reinterpret<f64>(0x3FD5555555555577), //  0x1.5555555555577p-2\n    B2  = reinterpret<f64>(0xBFCFFFFFFFFFFDCB), // -0x1.ffffffffffdcbp-3\n    B3  = reinterpret<f64>(0x3FC999999995DD0C), //  0x1.999999995dd0cp-3\n    B4  = reinterpret<f64>(0xBFC55555556745A7), // -0x1.55555556745a7p-3\n    B5  = reinterpret<f64>(0x3FC24924A344DE30), //  0x1.24924a344de3p-3\n    B6  = reinterpret<f64>(0xBFBFFFFFA4423D65), // -0x1.fffffa4423d65p-4\n    B7  = reinterpret<f64>(0x3FBC7184282AD6CA), //  0x1.c7184282ad6cap-4\n    B8  = reinterpret<f64>(0xBFB999EB43B068FF), // -0x1.999eb43b068ffp-4\n    B9  = reinterpret<f64>(0x3FB78182F7AFD085), //  0x1.78182f7afd085p-4\n    B10 = reinterpret<f64>(0xBFB5521375D145CD); // -0x1.5521375d145cdp-4\n\n  const\n    A0 = reinterpret<f64>(0xBFE0000000000001),  // -0x1.0000000000001p-1\n    A1 = reinterpret<f64>(0x3FD555555551305B),  //  0x1.555555551305bp-2\n    A2 = reinterpret<f64>(0xBFCFFFFFFFEB4590),  // -0x1.fffffffeb459p-3\n    A3 = reinterpret<f64>(0x3FC999B324F10111),  //  0x1.999b324f10111p-3\n    A4 = reinterpret<f64>(0xBFC55575E506C89F);  // -0x1.55575e506c89fp-3\n\n  const\n    LO: u64 = 0x3FEE000000000000,\n    HI: u64 = 0x3FF1090000000000;\n\n  const\n    Ln2hi  = reinterpret<f64>(0x3FE62E42FEFA3800), // 0x1.62e42fefa3800p-1\n    Ln2lo  = reinterpret<f64>(0x3D2EF35793C76730), // 0x1.ef35793c76730p-45\n    Ox1p27 = reinterpret<f64>(0x41A0000000000000), // 0x1p27\n    Ox1p52 = reinterpret<f64>(0x4330000000000000); // 0x1p52\n\n  let ix = reinterpret<u64>(x);\n  if (ix - LO < HI - LO) {\n    let r  = x - 1.0;\n    let r2 = r * r;\n    let r3 = r2 * r;\n    let y =\n      r3 * (B1 + r * B2 + r2 * B3 +\n      r3 * (B4 + r * B5 + r2 * B6 +\n      r3 * (B7 + r * B8 + r2 * B9 + r3 * B10)));\n    // Worst-case error is around 0.507 ULP\n    let w   = r * Ox1p27;\n    let rhi = r + w - w;\n    let rlo = r - rhi;\n    w = rhi * rhi * B0; // B[0] == -0.5\n    let hi = r + w;\n    let lo = r - hi + w;\n    lo += B0 * rlo * (rhi + r);\n    return y + lo + hi;\n  }\n  let top = u32(ix >> 48);\n  if (top - 0x0010 >= 0x7FF0 - 0x0010) {\n    // x < 0x1p-1022 or inf or nan\n    if ((ix << 1) == 0) return -1.0 / (x * x);\n    if (ix == reinterpret<u64>(Infinity)) return x; // log(inf) == inf\n    if ((top & 0x8000) || (top & 0x7FF0) == 0x7FF0) return (x - x) / (x - x);\n    // x is subnormal, normalize it\n    ix = reinterpret<u64>(x * Ox1p52);\n    ix -= u64(52) << 52;\n  }\n\n  // x = 2^k z; where z is in range [OFF,2*OFF) and exact.\n  // The range is split into N subintervals.\n  // The ith subinterval contains z and c is near its center.\n  let tmp  = ix - 0x3FE6000000000000;\n  let i    = <usize>((tmp >> (52 - LOG_TABLE_BITS)) & N_MASK);\n  let k    = <i64>tmp >> 52;\n  let iz   = ix - (tmp & (u64(0xFFF) << 52));\n\n  let invc = load<f64>(LOG_DATA_TAB1 + (i << (1 + alignof<f64>())), 0 << alignof<f64>()); // T[i].invc;\n  let logc = load<f64>(LOG_DATA_TAB1 + (i << (1 + alignof<f64>())), 1 << alignof<f64>()); // T[i].logc;\n  let z    = reinterpret<f64>(iz);\n\n  // log(x) = log1p(z/c-1) + log(c) + k*Ln2.\n  // r ~= z/c - 1, |r| < 1/(2*N)\n  // #if __FP_FAST_FMA\n  // \t// rounding error: 0x1p-55/N\n  // \tr = __builtin_fma(z, invc, -1.0);\n  // #else\n  // rounding error: 0x1p-55/N + 0x1p-66\n  const chi = load<f64>(LOG_DATA_TAB2 + (i << (1 + alignof<f64>())), 0 << alignof<f64>()); // T2[i].chi\n  const clo = load<f64>(LOG_DATA_TAB2 + (i << (1 + alignof<f64>())), 1 << alignof<f64>()); // T2[i].clo\n  let r = (z - chi - clo) * invc;\n  // #endif\n  let kd = <f64>k;\n\n  // hi + lo = r + log(c) + k*Ln2\n  let w  = kd * Ln2hi + logc;\n  let hi = w + r;\n  let lo = w - hi + r + kd * Ln2lo;\n\n  // log(x) = lo + (log1p(r) - r) + hi\n  let r2 = r * r; // rounding error: 0x1p-54/N^2\n  // Worst case error if |y| > 0x1p-5:\n  // 0.5 + 4.13/N + abs-poly-error*2^57 ULP (+ 0.002 ULP without fma)\n  // Worst case error if |y| > 0x1p-4:\n  // 0.5 + 2.06/N + abs-poly-error*2^56 ULP (+ 0.001 ULP without fma).\n  return lo + r2 * A0 + r * r2 * (A1 + r * A2 + r2 * (A3 + r * A4)) + hi;\n}\n\n//\n// Lookup data for pow. See: https://git.musl-libc.org/cgit/musl/tree/src/math/pow.c\n//\n\n// @ts-ignore: decorator\n@inline const POW_LOG_TABLE_BITS = 7;\n\n/* Algorithm:\n\n  x = 2^k z\n  log(x) = k ln2 + log(c) + log(z/c)\n  log(z/c) = poly(z/c - 1)\n\nwhere z is in [0x1.69555p-1; 0x1.69555p0] which is split into N subintervals\nand z falls into the ith one, then table entries are computed as\n\n  tab[i].invc = 1/c\n  tab[i].logc = round(0x1p43*log(c))/0x1p43\n  tab[i].logctail = (double)(log(c) - logc)\n\nwhere c is chosen near the center of the subinterval such that 1/c has only a\nfew precision bits so z/c - 1 is exactly representible as double:\n\n  1/c = center < 1 ? round(N/center)/N : round(2*N/center)/N/2\n\nNote: |z/c - 1| < 1/N for the chosen c, |log(c) - logc - logctail| < 0x1p-97,\nthe last few bits of logc are rounded away so k*ln2hi + logc has no rounding\nerror and the interval for z is selected such that near x == 1, where log(x)\nis tiny, large cancellation error is avoided in logc + poly(z/c - 1). */\n\n// @ts-ignore: decorator\n@lazy @inline const POW_LOG_DATA_TAB = memory.data<u64>([\n  //      invc      ,pad,       logc       ,       logctail\n  0x3FF6A00000000000, 0, 0xBFD62C82F2B9C800, 0x3CFAB42428375680,\n  0x3FF6800000000000, 0, 0xBFD5D1BDBF580800, 0xBD1CA508D8E0F720,\n  0x3FF6600000000000, 0, 0xBFD5767717455800, 0xBD2362A4D5B6506D,\n  0x3FF6400000000000, 0, 0xBFD51AAD872DF800, 0xBCE684E49EB067D5,\n  0x3FF6200000000000, 0, 0xBFD4BE5F95777800, 0xBD041B6993293EE0,\n  0x3FF6000000000000, 0, 0xBFD4618BC21C6000, 0x3D13D82F484C84CC,\n  0x3FF5E00000000000, 0, 0xBFD404308686A800, 0x3CDC42F3ED820B3A,\n  0x3FF5C00000000000, 0, 0xBFD3A64C55694800, 0x3D20B1C686519460,\n  0x3FF5A00000000000, 0, 0xBFD347DD9A988000, 0x3D25594DD4C58092,\n  0x3FF5800000000000, 0, 0xBFD2E8E2BAE12000, 0x3D267B1E99B72BD8,\n  0x3FF5600000000000, 0, 0xBFD2895A13DE8800, 0x3D15CA14B6CFB03F,\n  0x3FF5600000000000, 0, 0xBFD2895A13DE8800, 0x3D15CA14B6CFB03F,\n  0x3FF5400000000000, 0, 0xBFD22941FBCF7800, 0xBD165A242853DA76,\n  0x3FF5200000000000, 0, 0xBFD1C898C1699800, 0xBD1FAFBC68E75404,\n  0x3FF5000000000000, 0, 0xBFD1675CABABA800, 0x3D1F1FC63382A8F0,\n  0x3FF4E00000000000, 0, 0xBFD1058BF9AE4800, 0xBD26A8C4FD055A66,\n  0x3FF4C00000000000, 0, 0xBFD0A324E2739000, 0xBD0C6BEE7EF4030E,\n  0x3FF4A00000000000, 0, 0xBFD0402594B4D000, 0xBCF036B89EF42D7F,\n  0x3FF4A00000000000, 0, 0xBFD0402594B4D000, 0xBCF036B89EF42D7F,\n  0x3FF4800000000000, 0, 0xBFCFB9186D5E4000, 0x3D0D572AAB993C87,\n  0x3FF4600000000000, 0, 0xBFCEF0ADCBDC6000, 0x3D2B26B79C86AF24,\n  0x3FF4400000000000, 0, 0xBFCE27076E2AF000, 0xBD172F4F543FFF10,\n  0x3FF4200000000000, 0, 0xBFCD5C216B4FC000, 0x3D21BA91BBCA681B,\n  0x3FF4000000000000, 0, 0xBFCC8FF7C79AA000, 0x3D27794F689F8434,\n  0x3FF4000000000000, 0, 0xBFCC8FF7C79AA000, 0x3D27794F689F8434,\n  0x3FF3E00000000000, 0, 0xBFCBC286742D9000, 0x3D194EB0318BB78F,\n  0x3FF3C00000000000, 0, 0xBFCAF3C94E80C000, 0x3CBA4E633FCD9066,\n  0x3FF3A00000000000, 0, 0xBFCA23BC1FE2B000, 0xBD258C64DC46C1EA,\n  0x3FF3A00000000000, 0, 0xBFCA23BC1FE2B000, 0xBD258C64DC46C1EA,\n  0x3FF3800000000000, 0, 0xBFC9525A9CF45000, 0xBD2AD1D904C1D4E3,\n  0x3FF3600000000000, 0, 0xBFC87FA06520D000, 0x3D2BBDBF7FDBFA09,\n  0x3FF3400000000000, 0, 0xBFC7AB890210E000, 0x3D2BDB9072534A58,\n  0x3FF3400000000000, 0, 0xBFC7AB890210E000, 0x3D2BDB9072534A58,\n  0x3FF3200000000000, 0, 0xBFC6D60FE719D000, 0xBD10E46AA3B2E266,\n  0x3FF3000000000000, 0, 0xBFC5FF3070A79000, 0xBD1E9E439F105039,\n  0x3FF3000000000000, 0, 0xBFC5FF3070A79000, 0xBD1E9E439F105039,\n  0x3FF2E00000000000, 0, 0xBFC526E5E3A1B000, 0xBD20DE8B90075B8F,\n  0x3FF2C00000000000, 0, 0xBFC44D2B6CCB8000, 0x3D170CC16135783C,\n  0x3FF2C00000000000, 0, 0xBFC44D2B6CCB8000, 0x3D170CC16135783C,\n  0x3FF2A00000000000, 0, 0xBFC371FC201E9000, 0x3CF178864D27543A,\n  0x3FF2800000000000, 0, 0xBFC29552F81FF000, 0xBD248D301771C408,\n  0x3FF2600000000000, 0, 0xBFC1B72AD52F6000, 0xBD2E80A41811A396,\n  0x3FF2600000000000, 0, 0xBFC1B72AD52F6000, 0xBD2E80A41811A396,\n  0x3FF2400000000000, 0, 0xBFC0D77E7CD09000, 0x3D0A699688E85BF4,\n  0x3FF2400000000000, 0, 0xBFC0D77E7CD09000, 0x3D0A699688E85BF4,\n  0x3FF2200000000000, 0, 0xBFBFEC9131DBE000, 0xBD2575545CA333F2,\n  0x3FF2000000000000, 0, 0xBFBE27076E2B0000, 0x3D2A342C2AF0003C,\n  0x3FF2000000000000, 0, 0xBFBE27076E2B0000, 0x3D2A342C2AF0003C,\n  0x3FF1E00000000000, 0, 0xBFBC5E548F5BC000, 0xBD1D0C57585FBE06,\n  0x3FF1C00000000000, 0, 0xBFBA926D3A4AE000, 0x3D253935E85BAAC8,\n  0x3FF1C00000000000, 0, 0xBFBA926D3A4AE000, 0x3D253935E85BAAC8,\n  0x3FF1A00000000000, 0, 0xBFB8C345D631A000, 0x3D137C294D2F5668,\n  0x3FF1A00000000000, 0, 0xBFB8C345D631A000, 0x3D137C294D2F5668,\n  0x3FF1800000000000, 0, 0xBFB6F0D28AE56000, 0xBD269737C93373DA,\n  0x3FF1600000000000, 0, 0xBFB51B073F062000, 0x3D1F025B61C65E57,\n  0x3FF1600000000000, 0, 0xBFB51B073F062000, 0x3D1F025B61C65E57,\n  0x3FF1400000000000, 0, 0xBFB341D7961BE000, 0x3D2C5EDACCF913DF,\n  0x3FF1400000000000, 0, 0xBFB341D7961BE000, 0x3D2C5EDACCF913DF,\n  0x3FF1200000000000, 0, 0xBFB16536EEA38000, 0x3D147C5E768FA309,\n  0x3FF1000000000000, 0, 0xBFAF0A30C0118000, 0x3D2D599E83368E91,\n  0x3FF1000000000000, 0, 0xBFAF0A30C0118000, 0x3D2D599E83368E91,\n  0x3FF0E00000000000, 0, 0xBFAB42DD71198000, 0x3D1C827AE5D6704C,\n  0x3FF0E00000000000, 0, 0xBFAB42DD71198000, 0x3D1C827AE5D6704C,\n  0x3FF0C00000000000, 0, 0xBFA77458F632C000, 0xBD2CFC4634F2A1EE,\n  0x3FF0C00000000000, 0, 0xBFA77458F632C000, 0xBD2CFC4634F2A1EE,\n  0x3FF0A00000000000, 0, 0xBFA39E87B9FEC000, 0x3CF502B7F526FEAA,\n  0x3FF0A00000000000, 0, 0xBFA39E87B9FEC000, 0x3CF502B7F526FEAA,\n  0x3FF0800000000000, 0, 0xBF9F829B0E780000, 0xBD2980267C7E09E4,\n  0x3FF0800000000000, 0, 0xBF9F829B0E780000, 0xBD2980267C7E09E4,\n  0x3FF0600000000000, 0, 0xBF97B91B07D58000, 0xBD288D5493FAA639,\n  0x3FF0400000000000, 0, 0xBF8FC0A8B0FC0000, 0xBCDF1E7CF6D3A69C,\n  0x3FF0400000000000, 0, 0xBF8FC0A8B0FC0000, 0xBCDF1E7CF6D3A69C,\n  0x3FF0200000000000, 0, 0xBF7FE02A6B100000, 0xBD19E23F0DDA40E4,\n  0x3FF0200000000000, 0, 0xBF7FE02A6B100000, 0xBD19E23F0DDA40E4,\n  0x3FF0000000000000, 0, 0, 0,\n  0x3FF0000000000000, 0, 0, 0,\n  0x3FEFC00000000000, 0, 0x3F80101575890000, 0xBD10C76B999D2BE8,\n  0x3FEF800000000000, 0, 0x3F90205658938000, 0xBD23DC5B06E2F7D2,\n  0x3FEF400000000000, 0, 0x3F98492528C90000, 0xBD2AA0BA325A0C34,\n  0x3FEF000000000000, 0, 0x3FA0415D89E74000, 0x3D0111C05CF1D753,\n  0x3FEEC00000000000, 0, 0x3FA466AED42E0000, 0xBD2C167375BDFD28,\n  0x3FEE800000000000, 0, 0x3FA894AA149FC000, 0xBD197995D05A267D,\n  0x3FEE400000000000, 0, 0x3FACCB73CDDDC000, 0xBD1A68F247D82807,\n  0x3FEE200000000000, 0, 0x3FAEEA31C006C000, 0xBD0E113E4FC93B7B,\n  0x3FEDE00000000000, 0, 0x3FB1973BD1466000, 0xBD25325D560D9E9B,\n  0x3FEDA00000000000, 0, 0x3FB3BDF5A7D1E000, 0x3D2CC85EA5DB4ED7,\n  0x3FED600000000000, 0, 0x3FB5E95A4D97A000, 0xBD2C69063C5D1D1E,\n  0x3FED400000000000, 0, 0x3FB700D30AEAC000, 0x3CEC1E8DA99DED32,\n  0x3FED000000000000, 0, 0x3FB9335E5D594000, 0x3D23115C3ABD47DA,\n  0x3FECC00000000000, 0, 0x3FBB6AC88DAD6000, 0xBD1390802BF768E5,\n  0x3FECA00000000000, 0, 0x3FBC885801BC4000, 0x3D2646D1C65AACD3,\n  0x3FEC600000000000, 0, 0x3FBEC739830A2000, 0xBD2DC068AFE645E0,\n  0x3FEC400000000000, 0, 0x3FBFE89139DBE000, 0xBD2534D64FA10AFD,\n  0x3FEC000000000000, 0, 0x3FC1178E8227E000, 0x3D21EF78CE2D07F2,\n  0x3FEBE00000000000, 0, 0x3FC1AA2B7E23F000, 0x3D2CA78E44389934,\n  0x3FEBA00000000000, 0, 0x3FC2D1610C868000, 0x3D039D6CCB81B4A1,\n  0x3FEB800000000000, 0, 0x3FC365FCB0159000, 0x3CC62FA8234B7289,\n  0x3FEB400000000000, 0, 0x3FC4913D8333B000, 0x3D25837954FDB678,\n  0x3FEB200000000000, 0, 0x3FC527E5E4A1B000, 0x3D2633E8E5697DC7,\n  0x3FEAE00000000000, 0, 0x3FC6574EBE8C1000, 0x3D19CF8B2C3C2E78,\n  0x3FEAC00000000000, 0, 0x3FC6F0128B757000, 0xBD25118DE59C21E1,\n  0x3FEAA00000000000, 0, 0x3FC7898D85445000, 0xBD1C661070914305,\n  0x3FEA600000000000, 0, 0x3FC8BEAFEB390000, 0xBD073D54AAE92CD1,\n  0x3FEA400000000000, 0, 0x3FC95A5ADCF70000, 0x3D07F22858A0FF6F,\n  0x3FEA000000000000, 0, 0x3FCA93ED3C8AE000, 0xBD28724350562169,\n  0x3FE9E00000000000, 0, 0x3FCB31D8575BD000, 0xBD0C358D4EACE1AA,\n  0x3FE9C00000000000, 0, 0x3FCBD087383BE000, 0xBD2D4BC4595412B6,\n  0x3FE9A00000000000, 0, 0x3FCC6FFBC6F01000, 0xBCF1EC72C5962BD2,\n  0x3FE9600000000000, 0, 0x3FCDB13DB0D49000, 0xBD2AFF2AF715B035,\n  0x3FE9400000000000, 0, 0x3FCE530EFFE71000, 0x3CC212276041F430,\n  0x3FE9200000000000, 0, 0x3FCEF5ADE4DD0000, 0xBCCA211565BB8E11,\n  0x3FE9000000000000, 0, 0x3FCF991C6CB3B000, 0x3D1BCBECCA0CDF30,\n  0x3FE8C00000000000, 0, 0x3FD07138604D5800, 0x3CF89CDB16ED4E91,\n  0x3FE8A00000000000, 0, 0x3FD0C42D67616000, 0x3D27188B163CEAE9,\n  0x3FE8800000000000, 0, 0x3FD1178E8227E800, 0xBD2C210E63A5F01C,\n  0x3FE8600000000000, 0, 0x3FD16B5CCBACF800, 0x3D2B9ACDF7A51681,\n  0x3FE8400000000000, 0, 0x3FD1BF99635A6800, 0x3D2CA6ED5147BDB7,\n  0x3FE8200000000000, 0, 0x3FD214456D0EB800, 0x3D0A87DEBA46BAEA,\n  0x3FE7E00000000000, 0, 0x3FD2BEF07CDC9000, 0x3D2A9CFA4A5004F4,\n  0x3FE7C00000000000, 0, 0x3FD314F1E1D36000, 0xBD28E27AD3213CB8,\n  0x3FE7A00000000000, 0, 0x3FD36B6776BE1000, 0x3D116ECDB0F177C8,\n  0x3FE7800000000000, 0, 0x3FD3C25277333000, 0x3D183B54B606BD5C,\n  0x3FE7600000000000, 0, 0x3FD419B423D5E800, 0x3D08E436EC90E09D,\n  0x3FE7400000000000, 0, 0x3FD4718DC271C800, 0xBD2F27CE0967D675,\n  0x3FE7200000000000, 0, 0x3FD4C9E09E173000, 0xBD2E20891B0AD8A4,\n  0x3FE7000000000000, 0, 0x3FD522AE0738A000, 0x3D2EBE708164C759,\n  0x3FE6E00000000000, 0, 0x3FD57BF753C8D000, 0x3D1FADEDEE5D40EF,\n  0x3FE6C00000000000, 0, 0x3FD5D5BDDF596000, 0xBD0A0B2A08A465DC\n]);\n\n// Returns 0 if not int, 1 if odd int, 2 if even int. The argument is\n// the bit representation of a non-zero finite floating-point value.\n// @ts-ignore: decorator\n@inline\nfunction checkint(iy: u64): i32 {\n  let e = iy >> 52 & 0x7FF;\n  if (e < 0x3FF     ) return 0;\n  if (e > 0x3FF + 52) return 2;\n  e = u64(1) << (0x3FF + 52 - e);\n  if (iy & (e - 1)) return 0;\n  if (iy &  e     ) return 1;\n  return 2;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction xflow(sign: u32, y: f64): f64 {\n  return select(-y, y, sign) * y;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction uflow(sign: u32): f64 {\n  return xflow(sign, reinterpret<f64>(0x1000000000000000)); // 0x1p-767\n}\n\n// @ts-ignore: decorator\n@inline\nfunction oflow(sign: u32): f64 {\n  return xflow(sign, reinterpret<f64>(0x7000000000000000)); // 0x1p769\n}\n\n// Returns 1 if input is the bit representation of 0, infinity or nan.\n// @ts-ignore: decorator\n@inline\nfunction zeroinfnan(u: u64): bool {\n  return (u << 1) - 1 >= 0xFFE0000000000000 - 1;\n}\n\n// @ts-ignore: decorator\n@lazy let log_tail: f64 = 0;\n\n// Compute y+TAIL = log(x) where the rounded result is y and TAIL has about\n// additional 15 bits precision. IX is the bit representation of x, but\n// normalized in the subnormal range using the sign bit for the exponent.\n// @ts-ignore: decorator\n@inline\nfunction log_inline(ix: u64): f64 {\n  const N = 1 << POW_LOG_TABLE_BITS;\n  const N_MASK = N - 1;\n\n  const\n    Ln2hi = reinterpret<f64>(0x3FE62E42FEFA3800),\n    Ln2lo = reinterpret<f64>(0x3D2EF35793C76730);\n\n  const\n    A0 = reinterpret<f64>(0xBFE0000000000000),\n    A1 = reinterpret<f64>(0xBFE5555555555560),\n    A2 = reinterpret<f64>(0x3FE0000000000006),\n    A3 = reinterpret<f64>(0x3FE999999959554E),\n    A4 = reinterpret<f64>(0xBFE555555529A47A),\n    A5 = reinterpret<f64>(0xBFF2495B9B4845E9),\n    A6 = reinterpret<f64>(0x3FF0002B8B263FC3);\n\n  // x = 2^k z; where z is in range [OFF,2*OFF) and exact.\n  // The range is split into N subintervals.\n  // The ith subinterval contains z and c is near its center.\n  let tmp = ix - 0x3fE6955500000000;\n  let i   = usize((tmp >> (52 - POW_LOG_TABLE_BITS)) & N_MASK);\n  let k   = <i64>tmp >> 52;\n  let iz  = ix - (tmp & u64(0xFFF) << 52);\n  let z   = reinterpret<f64>(iz);\n  let kd  = <f64>k;\n\n  // log(x) = k*Ln2 + log(c) + log1p(z/c-1).\n  let invc     = load<f64>(POW_LOG_DATA_TAB + (i << (2 + alignof<f64>())), 0 << alignof<f64>()); // tab[i].invc\n  let logc     = load<f64>(POW_LOG_DATA_TAB + (i << (2 + alignof<f64>())), 2 << alignof<f64>()); // tab[i].logc\n  let logctail = load<f64>(POW_LOG_DATA_TAB + (i << (2 + alignof<f64>())), 3 << alignof<f64>()); // tab[i].logctail\n\n  // Note: 1/c is j/N or j/N/2 where j is an integer in [N,2N) and\n  // |z/c - 1| < 1/N, so r = z/c - 1 is exactly representible.\n  // Split z such that rhi, rlo and rhi*rhi are exact and |rlo| <= |r|.\n  let zhi = reinterpret<f64>((iz + u64(0x80000000)) & 0xFFFFFFFF00000000);\n  let zlo = z - zhi;\n  let rhi = zhi * invc - 1.0;\n  let rlo = zlo * invc;\n  let r   = rhi + rlo;\n\n  // k * Ln2 + log(c) + r.\n  let t1  = kd * Ln2hi + logc;\n  let t2  = t1 + r;\n  let lo1 = kd * Ln2lo + logctail;\n  let lo2 = t1 - t2 + r;\n\n  // Evaluation is optimized assuming superscalar pipelined execution.\n  let ar  = A0 * r; // A[0] = -0.5\n  let ar2 = r * ar;\n  let ar3 = r * ar2;\n  // k * Ln2 + log(c) + r + A[0] * r * r.\n  let arhi  = A0  * rhi;\n  let arhi2 = rhi * arhi;\n  let hi    = t2  + arhi2;\n  let lo3   = rlo * (ar + arhi);\n  let lo4   = t2 - hi + arhi2;\n\n  // p = log1p(r) - r - A[0] * r * r.\n  let p  = ar3 * (A1 + r * A2 + ar2 * (A3 + r * A4 + ar2 * (A5 + r * A6)));\n  let lo = lo1 + lo2 + lo3 + lo4 + p;\n  let y  = hi + lo;\n  log_tail = hi - y + lo;\n\n  return y;\n}\n\n// @ts-ignore: decorator\n@inline const SIGN_BIAS = 0x800 << EXP_TABLE_BITS;\n\n// Computes sign*exp(x+xtail) where |xtail| < 2^-8/N and |xtail| <= |x|.\n// The sign_bias argument is SIGN_BIAS or 0 and sets the sign to -1 or 1.\n// @ts-ignore: decorator\n@inline\nfunction exp_inline(x: f64, xtail: f64, sign_bias: u32): f64 {\n  const N      = 1 << EXP_TABLE_BITS;\n  const N_MASK = N - 1;\n\n  const\n    InvLn2N   = reinterpret<f64>(0x3FF71547652B82FE) * N, // 0x1.71547652b82fep0\n    NegLn2hiN = reinterpret<f64>(0xBF762E42FEFA0000),     // -0x1.62e42fefa0000p-8\n    NegLn2loN = reinterpret<f64>(0xBD0CF79ABC9E3B3A),     // -0x1.cf79abc9e3b3ap-47\n    shift     = reinterpret<f64>(0x4338000000000000);     // 0x1.8p52\n\n  const\n    C2 = reinterpret<f64>(0x3FDFFFFFFFFFFDBD), // __exp_data.poly[0] (0x1.ffffffffffdbdp-2)\n    C3 = reinterpret<f64>(0x3FC555555555543C), // __exp_data.poly[1] (0x1.555555555543cp-3)\n    C4 = reinterpret<f64>(0x3FA55555CF172B91), // __exp_data.poly[2] (0x1.55555cf172b91p-5)\n    C5 = reinterpret<f64>(0x3F81111167A4D017); // __exp_data.poly[3] (0x1.1111167a4d017p-7)\n\n  let abstop: u32;\n  let ki: u64, top: u64, sbits: u64;\n  let idx: usize;\n  // double_t for better performance on targets with FLT_EVAL_METHOD==2.\n  let kd: f64, z: f64, r: f64, r2: f64, scale: f64, tail: f64, tmp: f64;\n\n  let ux = reinterpret<u64>(x);\n  abstop = u32(ux >> 52) & 0x7FF;\n  if (abstop - 0x3C9 >= 0x03F) {\n    if (abstop - 0x3C9 >= 0x80000000) {\n      // Avoid spurious underflow for tiny x.\n      // Note: 0 is common input.\n      return select(-1.0, 1.0, sign_bias);\n    }\n    if (abstop >= 0x409) { // top12(1024.0)\n      // Note: inf and nan are already handled.\n      return <i64>ux < 0\n        ? uflow(sign_bias)\n        : oflow(sign_bias);\n    }\n    // Large x is special cased below.\n    abstop = 0;\n  }\n\n  // exp(x) = 2^(k/N) * exp(r), with exp(r) in [2^(-1/2N),2^(1/2N)].\n  // x = ln2/N*k + r, with int k and r in [-ln2/2N, ln2/2N].\n  z = InvLn2N * x;\n\n  // #if TOINT_INTRINSICS\n  //   kd = roundtoint(z);\n  //   ki = converttoint(z);\n  // #elif EXP_USE_TOINT_NARROW\n  //   // z - kd is in [-0.5-2^-16, 0.5] in all rounding modes.\n  //   kd = eval_as_double(z + shift);\n  //   ki = asuint64(kd) >> 16;\n  //   kd = (double_t)(int32_t)ki;\n  // #else\n  // z - kd is in [-1, 1] in non-nearest rounding modes\n  kd  = z + shift;\n  ki  = reinterpret<u64>(kd);\n  kd -= shift;\n  // #endif\n  r = x + kd * NegLn2hiN + kd * NegLn2loN;\n  // The code assumes 2^-200 < |xtail| < 2^-8/N\n  r += xtail;\n  // 2^(k/N) ~= scale * (1 + tail)\n  idx = usize((ki & N_MASK) << 1);\n  top = (ki + sign_bias) << (52 - EXP_TABLE_BITS);\n\n  tail = reinterpret<f64>(load<u64>(EXP_DATA_TAB + (idx << alignof<u64>())));\n  // This is only a valid scale when -1023*N < k < 1024*N\n  sbits = load<u64>(EXP_DATA_TAB + (idx << alignof<u64>()), 1 << alignof<u64>()) + top;\n  // exp(x) = 2^(k/N) * exp(r) ~= scale + scale * (tail + exp(r) - 1).\n  // Evaluation is optimized assuming superscalar pipelined execution.\n  r2 = r * r;\n  // Without fma the worst case error is 0.25/N ulp larger.\n  // Worst case error is less than 0.5+1.11/N+(abs poly error * 2^53) ulp\n  tmp = tail + r + r2 * (C2 + r * C3) + r2 * r2 * (C4 + r * C5);\n  if (abstop == 0) return specialcase(tmp, sbits, ki);\n  scale = reinterpret<f64>(sbits);\n  // Note: tmp == 0 or |tmp| > 2^-200 and scale > 2^-739, so there\n  // is no spurious underflow here even without fma.\n  return scale + scale * tmp;\n}\n\n// @ts-ignore: decorator\n@inline\nexport function pow_lut(x: f64, y: f64): f64 {\n  const Ox1p52 = reinterpret<f64>(0x4330000000000000); // 0x1p52\n\n  let sign_bias: u32 = 0;\n  let ix = reinterpret<u64>(x);\n  let iy = reinterpret<u64>(y);\n  let topx = ix >> 52;\n  let topy = iy >> 52;\n\n  if (topx - 0x001 >= 0x7FF - 0x001 || (topy & 0x7FF) - 0x3BE >= 0x43e - 0x3BE) {\n    // Note: if |y| > 1075 * ln2 * 2^53 ~= 0x1.749p62 then pow(x,y) = inf/0\n    // and if |y| < 2^-54 / 1075 ~= 0x1.e7b6p-65 then pow(x,y) = +-1.\n    // Special cases: (x < 0x1p-126 or inf or nan) or\n    // (|y| < 0x1p-65 or |y| >= 0x1p63 or nan).\n    if (zeroinfnan(iy)) {\n      if ((iy << 1) == 0) return 1.0;\n      if (ix == 0x3FF0000000000000) return NaN; // original: 1.0\n      if ((ix << 1) > 0xFFE0000000000000 || (iy << 1) > 0xFFE0000000000000) return x + y;\n      if ((ix << 1) == 0x7FE0000000000000) return NaN; // original: 1.0\n      if (((ix << 1) < 0x7FE0000000000000) == !(iy >> 63)) return 0; // |x|<1 && y==inf or |x|>1 && y==-inf.\n      return y * y;\n    }\n    if (zeroinfnan(ix)) {\n      let x2 = x * x;\n      if (i32(ix >> 63) && checkint(iy) == 1) x2 = -x2;\n      return <i64>iy < 0 ? 1 / x2 : x2;\n    }\n    // Here x and y are non-zero finite\n    if (<i64>ix < 0) {\n      // Finite x < 0\n      let yint = checkint(iy);\n      if (yint == 0) return (x - x) / (x - x);\n      if (yint == 1) sign_bias = SIGN_BIAS;\n      ix   &= 0x7FFFFFFFFFFFFFFF;\n      topx &= 0x7FF;\n    }\n    if ((topy & 0x7FF) - 0x3BE >= 0x43E - 0x3BE) {\n      // Note: sign_bias == 0 here because y is not odd.\n      if (ix == 0x3FF0000000000000) return 1;\n      if ((topy & 0x7FF) < 0x3BE)   return 1; // |y| < 2^-65, x^y ~= 1 + y*log(x).\n      return (ix > 0x3FF0000000000000) == (topy < 0x800) ? Infinity : 0;\n    }\n    if (topx == 0) {\n      // Normalize subnormal x so exponent becomes negative.\n      ix = reinterpret<u64>(x * Ox1p52);\n      ix &= 0x7FFFFFFFFFFFFFFF;\n      ix -= u64(52) << 52;\n    }\n  }\n\n  let hi = log_inline(ix);\n  let lo = log_tail;\n  let ehi: f64, elo: f64;\n  // #if __FP_FAST_FMA\n  //   ehi = y * hi;\n  //   elo = y * lo + __builtin_fma(y, hi, -ehi);\n  // #else\n  let yhi = reinterpret<f64>(iy & 0xFFFFFFFFF8000000);\n  let ylo = y - yhi;\n  let lhi = reinterpret<f64>(reinterpret<u64>(hi) & 0xFFFFFFFFF8000000);\n  let llo = hi - lhi + lo;\n  ehi = yhi * lhi;\n  elo = ylo * lhi + y * llo; // |elo| < |ehi| * 2^-25.\n  // #endif\n  return exp_inline(ehi, elo, sign_bias);\n}\n","import {\n  itoa32,\n  utoa32,\n  itoa64,\n  utoa64,\n  dtoa,\n  itoa_buffered,\n  dtoa_buffered,\n  MAX_DOUBLE_LENGTH\n} from \"./number\";\n\nimport {\n  ipow32\n} from \"../math\";\n\n// All tables are stored as two staged lookup tables (static tries)\n// because the full range of Unicode symbols can't be efficiently\n// represented as-is in memory (see Unicode spec ch 5, p.196):\n// https://www.unicode.org/versions/Unicode12.0.0/ch05.pdf\n// Tables have been generated using these forked musl tools:\n// https://github.com/MaxGraey/musl-chartable-tools/tree/case-ignorable\n\n// Lookup table to check if a character is alphanumeric or not\n// See: https://git.musl-libc.org/cgit/musl/tree/src/ctype/alpha.h\n// size: 3904 bytes\n// @ts-ignore\n@inline @lazy const ALPHA_TABLE = memory.data<u8>([\n  18,17,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,17,34,35,36,17,37,38,39,40,\n  41,42,43,44,17,45,46,47,16,16,48,16,16,16,16,16,16,16,49,50,51,16,52,53,16,16,\n  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,54,\n  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,\n  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,\n  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,\n  17,17,17,55,17,17,17,17,56,17,57,58,59,60,61,62,17,17,17,17,17,17,17,17,17,17,\n  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,\n  17,17,17,17,17,17,17,63,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,17,64,65,17,66,67,\n  68,69,70,71,72,73,74,17,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,\n  93,94,16,95,96,97,98,17,17,17,99,100,101,16,16,16,16,16,16,16,16,16,16,17,17,\n  17,17,102,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,17,17,103,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,17,17,104,105,16,16,106,107,17,17,17,17,17,17,17,17,17,17,17,17,17,\n  17,17,17,17,17,17,17,17,17,17,108,17,17,17,17,109,110,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  17,111,112,16,16,16,16,16,16,16,16,16,113,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,114,115,116,117,16,16,16,16,16,16,16,16,118,\n  119,120,16,16,16,16,16,121,122,16,16,16,16,123,16,16,124,16,16,16,16,16,16,16,\n  16,16,125,16,16,16,\n  16,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,0,0,0,0,0,0,0,0,254,255,255,7,254,\n  255,255,7,0,0,0,0,0,4,32,4,255,255,127,255,255,255,127,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,195,255,3,0,31,80,0,0,0,0,0,0,0,0,0,0,32,0,0,0,0,0,223,188,64,215,255,255,\n  251,255,255,255,255,255,255,255,255,255,191,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,3,252,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,254,255,255,255,127,2,255,255,255,\n  255,255,1,0,0,0,0,255,191,182,0,255,255,255,135,7,0,0,0,255,7,255,255,255,255,\n  255,255,255,254,255,195,255,255,255,255,255,255,255,255,255,255,255,255,239,\n  31,254,225,255,\n  159,0,0,255,255,255,255,255,255,0,224,255,255,255,255,255,255,255,255,255,255,\n  255,255,3,0,255,255,255,255,255,7,48,4,255,255,255,252,255,31,0,0,255,255,255,\n  1,255,7,0,0,0,0,0,0,255,255,223,255,255,0,240,255,248,3,255,255,255,255,255,\n  255,255,255,255,239,255,223,225,255,207,255,254,255,239,159,249,255,255,253,\n  197,227,159,89,128,176,207,255,3,16,238,135,249,255,255,253,109,195,135,25,2,\n  94,192,255,63,0,238,191,251,255,255,253,237,227,191,27,1,0,207,255,0,30,238,\n  159,249,255,255,253,237,227,159,25,192,176,207,255,2,0,236,199,61,214,24,199,\n  255,195,199,29,129,0,192,255,0,0,239,223,253,255,255,253,255,227,223,29,96,7,\n  207,255,0,0,239,223,253,255,255,253,239,227,223,29,96,64,207,255,6,0,255,223,\n  253,255,255,255,255,231,223,93,240,128,207,255,0,252,238,255,127,252,255,255,\n  251,47,127,128,95,255,192,255,12,0,254,255,255,255,255,127,255,7,63,32,255,3,\n  0,0,0,0,214,247,255,255,175,255,255,59,95,32,255,243,0,0,0,\n  0,1,0,0,0,255,3,0,0,255,254,255,255,255,31,254,255,3,255,255,254,255,255,255,\n  31,0,0,0,0,0,0,0,0,255,255,255,255,255,255,127,249,255,3,255,255,255,255,255,\n  255,255,255,255,63,255,255,255,255,191,32,255,255,255,255,255,247,255,255,255,\n  255,255,255,255,255,255,61,127,61,255,255,255,255,255,61,255,255,255,255,61,\n  127,61,255,127,255,255,255,255,255,255,255,61,255,255,255,255,255,255,255,255,\n  7,0,0,0,0,255,255,0,0,255,255,255,255,255,255,255,255,255,255,63,63,254,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,159,255,255,254,255,255,7,255,255,255,255,255,255,255,255,\n  255,199,255,1,255,223,15,0,255,255,15,0,255,255,15,0,255,223,13,0,255,255,255,\n  255,255,255,207,255,255,1,128,16,255,3,0,0,0,0,255,3,255,255,255,255,255,255,\n  255,255,255,255,255,1,255,255,255,255,255,7,255,255,255,255,255,255,255,255,\n  63,\n  0,255,255,255,127,255,15,255,1,192,255,255,255,255,63,31,0,255,255,255,255,\n  255,15,255,255,255,3,255,3,0,0,0,0,255,255,255,15,255,255,255,255,255,255,255,\n  127,254,255,31,0,255,3,255,3,128,0,0,128,1,0,0,0,0,0,0,0,255,255,255,255,255,\n  255,239,255,239,15,255,3,0,0,0,0,255,255,255,255,255,243,255,255,255,255,255,\n  255,191,255,3,0,255,255,255,255,255,255,127,0,255,227,255,255,255,255,255,63,\n  255,1,255,255,255,255,255,231,0,0,0,0,0,222,111,4,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,0,0,0,0,\n  128,255,31,0,255,255,63,63,255,255,255,255,63,63,255,170,255,255,255,63,255,\n  255,255,255,255,255,223,95,220,31,207,15,255,31,220,31,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,2,128,0,0,255,31,0,0,0,0,0,0,0,0,0,0,0,0,132,252,47,62,80,189,255,243,\n  224,67,0,0,255,255,255,255,255,1,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,192,255,255,255,255,255,255,3,0,\n  0,255,255,255,255,255,127,255,255,255,255,255,127,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,31,120,12,0,255,255,255,255,191,32,255,\n  255,255,255,255,255,255,128,0,0,255,255,127,0,127,127,127,127,127,127,127,127,\n  255,255,255,255,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,224,0,0,0,254,3,62,31,254,255,255,255,255,255,255,255,255,255,127,224,254,\n  255,255,255,255,255,255,255,255,255,255,247,224,255,255,255,255,255,254,255,\n  255,255,255,255,255,255,255,255,255,127,0,0,255,255,255,255,0,0,0,0,0,0,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,\n  31,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,31,0,0,\n  0,0,0,0,0,0,255,255,255,255,255,63,255,31,255,255,255,15,0,0,255,255,255,255,\n  255,127,240,143,255,255,255,255,255,255,255,255,255,255,255,255,255,255,0,0,0,\n  0,128,255,252,255,255,255,255,255,255,255,255,255,255,255,255,249,255,255,255,\n  255,255,255,252,7,0,0,0,0,224,255,191,255,255,255,255,0,0,0,255,255,255,255,\n  255,255,15,0,255,255,255,255,255,255,255,255,47,0,255,3,0,0,252,232,255,255,\n  255,255,255,7,255,255,255,255,7,0,255,255,255,31,255,255,255,255,255,255,247,\n  255,0,128,255,3,255,255,255,127,255,255,255,255,255,255,127,0,255,63,255,3,\n  255,255,127,252,255,255,255,255,255,255,255,127,5,0,0,56,255,255,60,0,126,126,\n  126,0,127,127,255,255,255,255,255,247,255,3,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,7,255,3,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,15,0,255,255,127,248,255,255,255,255,\n  255,\n  15,255,255,255,255,255,255,255,255,255,255,255,255,255,63,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,3,0,0,0,0,127,0,248,224,255,253,127,95,219,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,3,0,0,0,248,255,255,255,\n  255,255,255,255,255,255,255,255,255,63,0,0,255,255,255,255,255,255,255,255,\n  252,255,255,255,255,255,255,0,0,0,0,0,255,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,223,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,31,0,0,255,3,\n  254,255,255,7,254,255,255,7,192,255,255,255,255,255,255,255,255,255,255,127,\n  252,252,252,28,0,0,0,0,255,239,255,255,127,255,255,183,255,63,255,63,0,0,0,0,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,7,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,31,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,255,255,255,31,255,255,255,255,255,255,1,0,0,0,0,\n  0,255,255,255,255,0,224,255,255,255,7,255,255,255,255,255,7,255,255,255,63,\n  255,255,255,255,15,255,62,0,0,0,0,0,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,63,255,3,255,255,255,255,15,255,255,255,\n  255,15,255,255,255,255,255,0,255,255,255,255,255,255,15,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,255,255,255,255,255,255,127,0,255,255,63,0,255,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,63,253,255,255,255,255,191,145,255,255,63,0,255,255,\n  127,0,255,255,255,127,0,0,0,0,0,0,0,0,255,255,55,0,255,255,63,0,255,255,255,3,\n  0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,192,0,0,0,0,0,0,0,0,111,240,239,\n  254,255,255,63,0,0,0,0,0,255,255,255,31,255,255,255,31,0,0,0,0,255,254,255,\n  255,31,0,0,0,255,255,255,255,255,255,63,0,255,255,63,0,255,255,7,0,255,255,3,\n  0,0,0,0,0,0,0,0,0,0,0,0,\n  0,255,255,255,255,255,255,255,255,255,1,0,0,0,0,0,0,255,255,255,255,255,255,7,\n  0,255,255,255,255,255,255,7,0,255,255,255,255,255,0,255,3,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,\n  255,27,3,0,0,0,0,0,0,0,0,0,255,255,255,31,128,0,255,255,63,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,255,255,31,0,0,0,255,255,127,0,255,255,255,255,255,255,255,255,63,0,0,\n  0,192,255,0,0,252,255,255,255,255,255,255,1,0,0,255,255,255,1,255,3,255,255,\n  255,255,255,255,199,255,240,0,255,255,255,255,71,0,255,255,255,255,255,255,\n  255,255,30,192,255,23,0,0,0,0,255,255,251,255,255,255,159,64,0,0,0,0,0,0,0,0,\n  127,189,255,191,255,1,255,255,255,255,255,255,255,1,255,3,239,159,249,255,255,\n  253,237,227,159,25,129,224,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,255,255,255,255,255,255,255,255,187,7,255,131,3,0,0,0,255,255,255,255,255,\n  255,255,255,179,0,255,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,\n  255,255,255,63,127,0,0,0,63,0,0,0,0,255,255,255,255,255,255,255,127,17,0,255,\n  3,0,0,0,0,255,255,255,255,255,255,63,1,255,3,0,0,0,0,0,0,255,255,255,231,255,\n  7,255,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,\n  255,255,1,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,3,0,128,\n  127,242,111,255,255,255,191,153,7,0,255,3,0,0,0,0,0,0,0,0,255,252,255,255,255,\n  255,255,252,26,0,0,0,255,255,255,255,255,255,231,127,0,0,255,255,255,255,255,\n  255,255,255,255,32,0,0,0,0,255,255,255,255,255,255,255,1,255,253,255,255,255,\n  255,127,127,1,0,255,3,0,0,252,255,255,255,252,255,255,254,127,0,0,0,0,0,0,0,0,\n  0,127,251,255,255,255,255,127,180,203,0,255,3,191,253,255,255,255,127,123,1,\n  255,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,255,255,127,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,\n  0,0,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,3,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,127,0,0,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,255,255,255,255,255,127,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,255,255,255,255,255,255,255,255,127,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,\n  0,255,255,255,255,255,255,255,1,255,255,255,127,255,3,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,63,0,0,255,255,255,255,255,255,0,0,15,0,255,3,248,255,255,224,255,\n  255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,\n  255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,135,\n  255,255,255,255,255,255,255,128,255,255,0,0,0,0,0,0,0,0,11,0,3,0,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,0,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,63,0,0,0,0,0,\n  255,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,\n  127,0,0,0,0,0,0,7,0,240,0,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,15,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,7,255,31,255,1,255,67,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,255,255,255,255,223,255,255,255,255,255,255,255,255,\n  223,100,222,255,235,239,255,255,255,255,255,255,255,191,231,223,223,255,255,\n  255,123,95,252,253,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,63,255,255,255,253,255,255,247,255,255,255,\n  247,255,255,223,255,255,255,223,255,255,127,255,255,255,127,255,255,255,253,\n  255,255,255,253,255,255,247,207,255,255,255,255,255,255,127,255,255,249,219,7,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,31,\n  128,63,255,67,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,15,255,\n  3,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,31,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,143,8,\n  255,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,239,255,255,255,150,254,247,10,\n  132,234,150,170,150,247,247,94,255,251,255,15,238,251,255,15,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,255,255,255,3,255,255,255,3,255,255,255,3,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,3\n]);\n\n// size: 1568 bytes (compressed to ~1380 bytes after binaryen)\n// @ts-ignore: decorator\n@lazy @inline const CASED = memory.data<u8>([\n  18,19,20,21,22,23,16,16,16,16,16,16,16,16,16,16,\n  24,16,16,25,16,16,16,16,16,16,16,16,26,27,17,28,\n  29,30,16,16,31,16,16,16,16,16,16,16,32,33,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,34,35,16,16,16,36,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,37,16,16,16,38,\n  16,16,16,16,39,16,16,16,16,16,16,16,40,16,16,16,\n  16,16,16,16,16,16,16,16,41,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,42,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,43,44,45,46,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,47,16,16,16,16,16,16,\n  16,48,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  0,0,0,0,0,0,0,0,254,255,255,7,254,255,255,7,0,0,0,0,0,4,32,4,\n  255,255,127,255,255,255,127,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,247,240,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,239,255,255,255,255,1,3,0,0,0,31,0,0,0,\n  0,0,0,0,0,0,0,0,32,0,0,0,0,0,207,188,64,215,255,255,251,255,255,255,\n  255,255,255,255,255,255,191,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  3,252,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,254,255,\n  255,255,127,0,255,255,255,255,255,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,\n  191,32,255,255,255,255,255,231,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,255,255,255,255,255,255,255,255,255,255,63,63,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,255,1,255,255,255,255,255,231,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  0,0,0,0,0,0,0,0,255,255,63,63,255,255,255,255,63,63,255,170,255,255,255,63,\n  255,255,255,255,255,255,223,95,220,31,207,15,255,31,220,31,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,2,128,0,0,255,31,0,0,0,0,0,0,0,0,0,0,0,0,\n  132,252,47,62,80,189,31,242,224,67,0,0,255,255,255,255,24,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,192,255,255,255,255,255,255,3,0,0,255,255,255,255,255,127,255,255,\n  255,255,255,127,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,31,120,12,0,\n  255,255,255,255,191,32,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,63,0,0,\n  255,255,255,63,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,252,255,255,255,\n  255,255,255,255,255,255,255,255,255,120,255,255,255,255,255,255,252,7,0,0,0,0,96,7,\n  0,0,0,0,0,0,255,255,255,255,255,247,255,1,255,255,255,255,255,255,255,255,255,255,\n  0,0,0,0,0,0,0,0,127,0,248,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,254,255,255,7,\n  254,255,255,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,255,255,255,255,0,0,0,0,0,0,0,0,0,0,0,0,255,255,\n  255,255,15,255,255,255,255,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,7,0,255,255,255,255,255,255,7,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,0,0,0,0,\n  0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,255,223,255,255,255,255,255,\n  255,255,255,223,100,222,255,235,239,255,255,255,255,255,255,255,191,231,223,223,255,255,255,123,\n  95,252,253,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,63,255,255,255,\n  253,255,255,247,255,255,255,247,255,255,223,255,255,255,223,255,255,127,255,255,255,127,255,255,\n  255,253,255,255,255,253,255,255,247,15,0,0,0,0,0,0,255,255,255,255,255,255,255,255,\n  15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,255,255,255,3,255,255,255,3,255,255,255,3,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0\n]);\n\n// size: 2976 bytes (compressed to ~2050 bytes after binaryen)\n// @ts-ignore: decorator\n@lazy @inline const CASE_IGNORABLES = memory.data<u8>([\n  18,16,19,20,21,22,23,24,25,26,27,28,29,30,31,32,\n  33,16,16,34,16,16,16,35,36,37,38,39,40,41,16,42,\n  43,16,16,16,16,16,16,16,16,16,16,16,44,45,46,16,\n  47,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  48,16,16,16,49,16,50,51,52,53,54,55,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,56,16,16,57,58,\n  16,59,60,61,16,16,16,16,16,16,62,16,16,63,64,65,\n  66,67,68,69,70,71,72,73,74,75,76,16,77,78,79,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,80,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,81,82,16,16,16,83,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,84,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,85,86,16,16,16,16,16,16,16,87,16,16,16,16,16,\n  88,89,90,16,16,16,16,16,91,92,16,16,16,16,16,16,\n  16,16,16,93,16,16,16,16,16,16,16,16,16,16,16,16,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  0,0,0,0,128,64,0,4,0,0,0,64,1,0,0,0,0,0,0,0,0,161,144,1,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,48,4,176,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,248,3,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,130,0,0,0,0,\n  0,0,254,255,255,255,255,191,182,0,0,0,0,0,16,0,63,0,255,23,0,0,0,0,\n  1,248,255,255,0,0,1,0,0,0,0,0,0,0,0,0,0,0,192,191,255,61,0,0,\n  0,128,2,0,0,0,255,255,255,7,0,0,0,0,0,0,0,0,0,0,192,255,1,0,\n  0,0,0,0,0,248,63,36,0,0,192,255,255,63,0,0,0,0,0,14,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,248,255,255,255,255,255,7,0,0,0,0,0,0,20,\n  254,33,254,0,12,0,2,0,2,0,0,0,0,0,0,16,30,32,0,0,12,0,0,64,\n  6,0,0,0,0,0,0,16,134,57,2,0,0,0,35,0,6,0,0,0,0,0,0,16,\n  190,33,0,0,12,0,0,252,2,0,0,0,0,0,0,144,30,32,96,0,12,0,0,0,\n  4,0,0,0,0,0,0,0,1,32,0,0,0,0,0,0,17,0,0,0,0,0,0,192,\n  193,61,96,0,12,0,0,0,2,0,0,0,0,0,0,144,64,48,0,0,12,0,0,0,\n  3,0,0,0,0,0,0,24,30,32,0,0,12,0,0,0,2,0,0,0,0,0,0,0,\n  0,4,92,0,0,0,0,0,0,0,0,0,0,0,242,7,192,127,0,0,0,0,0,0,\n  0,0,0,0,0,0,242,31,64,63,0,0,0,0,0,0,0,0,0,3,0,0,160,2,\n  0,0,0,0,0,0,254,127,223,224,255,254,255,255,255,31,64,0,0,0,0,0,0,0,\n  0,0,0,0,0,224,253,102,0,0,0,195,1,0,30,0,100,32,0,32,0,0,0,0,\n  0,0,0,0,0,0,0,16,0,0,0,0,0,0,0,0,0,0,0,224,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,28,0,0,0,28,0,\n  0,0,12,0,0,0,12,0,0,0,0,0,0,0,176,63,64,254,143,32,0,0,0,0,\n  0,120,0,0,0,0,0,0,8,0,0,0,0,0,0,0,96,0,0,0,0,2,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,135,1,4,14,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,9,0,0,0,0,\n  0,0,64,127,229,31,248,159,0,0,0,0,128,0,255,255,1,0,0,0,0,0,0,0,\n  15,0,0,0,0,0,208,23,4,0,0,0,0,248,15,0,3,0,0,0,60,59,0,0,\n  0,0,0,0,64,163,3,0,0,0,0,0,0,240,207,0,0,0,0,0,0,0,0,63,\n  0,0,0,0,0,0,0,0,0,0,247,255,253,33,16,3,0,0,0,0,0,240,255,255,\n  255,255,255,255,255,7,0,1,0,0,0,248,255,255,255,255,255,255,255,255,255,255,255,251,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,160,\n  3,224,0,224,0,224,0,96,0,248,0,3,144,124,0,0,0,0,0,0,223,255,2,128,\n  0,0,255,31,0,0,0,0,0,0,255,255,255,255,1,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,48,0,0,0,0,0,0,0,0,0,0,0,0,0,128,3,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,128,0,0,0,0,0,0,0,0,\n  0,0,0,0,255,255,255,255,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,0,0,0,0,60,62,8,\n  0,0,0,0,0,0,0,0,0,0,0,126,0,0,0,0,0,0,0,0,0,0,0,112,\n  0,0,32,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,63,0,16,0,0,0,0,0,0,\n  0,0,0,0,0,128,247,191,0,0,0,240,0,0,0,0,0,0,0,0,0,0,3,0,\n  255,255,255,255,3,0,0,0,0,0,0,0,0,0,1,0,0,7,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,3,68,8,0,0,96,16,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,48,0,0,0,255,255,3,128,0,0,0,0,192,63,0,0,\n  128,255,3,0,0,0,0,0,7,0,0,0,0,0,200,51,0,128,0,0,96,0,0,0,\n  0,0,0,0,0,126,102,0,8,16,0,0,0,0,1,16,0,0,0,0,0,0,157,193,\n  2,0,0,32,0,48,88,0,0,0,0,0,0,0,0,0,0,0,0,248,0,14,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,32,33,0,0,0,0,0,64,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,252,255,3,0,0,0,0,0,0,0,\n  255,255,8,0,255,255,0,0,0,0,36,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,128,128,64,0,4,0,0,0,64,1,0,0,0,0,0,1,0,\n  0,0,0,192,0,0,0,0,0,0,0,0,8,0,0,14,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,192,7,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,110,240,0,0,0,0,0,135,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,96,0,0,0,\n  0,0,0,0,240,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,24,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  192,255,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  2,0,0,0,0,0,0,255,127,0,0,0,0,0,0,128,3,0,0,0,0,0,120,38,\n  0,32,0,0,0,0,0,0,7,0,0,0,128,239,31,0,0,0,0,0,0,0,8,0,\n  3,0,0,0,0,0,192,127,0,158,0,0,0,0,0,0,0,0,0,0,0,128,211,64,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,248,7,0,0,\n  3,0,0,0,0,0,0,24,1,0,0,0,192,31,31,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,92,0,0,64,0,0,0,0,\n  0,0,0,0,0,0,248,133,13,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,60,176,1,0,0,48,0,0,0,0,\n  0,0,0,0,0,0,248,167,1,0,0,0,0,0,0,0,0,0,0,0,0,40,191,0,\n  0,0,0,0,0,0,0,0,0,0,0,224,188,15,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,255,6,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,88,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,240,12,1,0,0,0,254,7,0,0,0,0,248,121,128,0,126,14,0,0,0,0,\n  0,252,127,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,127,191,\n  0,0,0,0,0,0,0,0,0,0,252,255,255,252,109,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,126,180,191,0,0,0,0,0,0,0,0,0,163,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,24,0,0,0,0,0,0,0,255,1,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,31,0,0,0,0,0,0,0,127,0,15,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,128,0,0,0,0,0,0,0,128,255,255,0,0,0,0,0,0,0,0,27,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,96,15,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,3,248,255,\n  231,15,0,0,0,60,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  28,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,127,248,255,255,255,255,255,31,32,0,16,0,0,248,254,255,0,0,\n  0,0,0,0,0,0,0,0,127,255,255,249,219,7,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,63,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,240,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,127,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  240,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,248\n]);\n\n// @ts-ignore: decorator\n@lazy @inline const LOWER127 = memory.data<u8>([\n  0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,\n  16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,\n  32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,\n  48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,\n  64,\n  97,98,99,100,101,102,103,104,105,106,107,108,109,\n  110,111,112,113,114,115,116,117,118,119,120,121,122,\n  91,92,93,94,95,96,\n  97,98,99,100,101,102,103,104,105,106,107,108,109,\n  110,111,112,113,114,115,116,117,118,119,120,121,122,\n  123,124,125,126,127\n]);\n\n// @ts-ignore: decorator\n@lazy @inline const UPPER127 = memory.data<u8>([\n  0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,\n  16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,\n  32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,\n  48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,\n  64,\n  65,66,67,68,69,70,71,72,73,74,75,76,77,\n  78,79,80,81,82,83,84,85,86,87,88,89,90,\n  91,92,93,94,95,96,\n  65,66,67,68,69,70,71,72,73,74,75,76,77,\n  78,79,80,81,82,83,84,85,86,87,88,89,90,\n  123,124,125,126,127\n]);\n\n// 23 * 8 = 184 bytes\n// @ts-ignore: decorator\n@lazy @inline const POWERS10 = memory.data<f64>([\n  1e00, 1e01, 1e02, 1e03, 1e04, 1e05, 1e06, 1e07, 1e08, 1e09,\n  1e10, 1e11, 1e12, 1e13, 1e14, 1e15, 1e16, 1e17, 1e18, 1e19,\n  1e20, 1e21, 1e22\n]);\n\n// @ts-ignore: decorator\n@inline\nexport const enum CharCode {\n  PERCENT = 0x25,\n  PLUS = 0x2B,\n  MINUS = 0x2D,\n  DOT = 0x2E,\n  _0 = 0x30,\n  _1 = 0x31,\n  _2 = 0x32,\n  _3 = 0x33,\n  _4 = 0x34,\n  _5 = 0x35,\n  _6 = 0x36,\n  _7 = 0x37,\n  _8 = 0x38,\n  _9 = 0x39,\n  A = 0x41,\n  B = 0x42,\n  E = 0x45,\n  I = 0x49,\n  N = 0x4E,\n  O = 0x4F,\n  X = 0x58,\n  Z = 0x5A,\n  a = 0x61,\n  b = 0x62,\n  e = 0x65,\n  n = 0x6E,\n  o = 0x6F,\n  u = 0x75,\n  x = 0x78,\n  z = 0x7A\n}\n\n// @ts-ignore: decorator\n@inline\nexport function isAscii(c: u32): bool {\n  return !(c >> 7);\n}\n\n// @ts-ignore: decorator\n@inline\nexport function isLower8(c: u32): bool {\n  return c - CharCode.a < 26;\n}\n\n// @ts-ignore: decorator\n@inline\nexport function isUpper8(c: u32): bool {\n  return c - CharCode.A < 26;\n}\n\nexport function isSpace(c: u32): bool {\n  if (c < 0x1680) { // < <LS> (1)\n    // <SP>, <TAB>, <LF>, <VT>, <FF>, <CR> and <NBSP>\n    // (c == 0x20 || c == 0xA0) was optimized to (c | 0x80) == 0xA0\n    return ((c | 0x80) == 0xA0) || (c - 0x09 <= 0x0D - 0x09);\n  }\n  if (c - 0x2000 <= 0x200A - 0x2000) return true;\n  switch (c) {\n    case 0x1680: // <LS> (1)\n    case 0x2028: // <LS> (2)\n    case 0x2029: // <PS>\n    case 0x202F: // <NNS>\n    case 0x205F: // <MMSP>\n    case 0x3000: // <IS>\n    case 0xFEFF: return true; // <ZWNBSP>\n  }\n  return false;\n}\n\nexport function isAlpha(c: u32): bool {\n  if (isAscii(c)) return (c | 32) - CharCode.a < 26;\n  if (c < 0x20000) {\n    // @ts-ignore: cast\n    return stagedBinaryLookup(ALPHA_TABLE, c);\n  }\n  return c < 0x2FFFE;\n}\n\n// @ts-ignore: decorator\n@inline\nexport function isCased(c: u32): bool {\n  // @ts-ignore: cast\n  return c < 0x1F18A && stagedBinaryLookup(CASED, c);\n}\n\n// @ts-ignore: decorator\n@inline\nexport function isCaseIgnorable(c: u32): bool {\n  // @ts-ignore: cast\n  return c < 0xE01F0 && stagedBinaryLookup(CASE_IGNORABLES, c);\n}\n\n// @ts-ignore: decorator\n@inline\nexport function isFinalSigma(buffer: usize, index: isize, len: isize): bool {\n  const lookaheadLimit = 30; // max lookahead limit\n  let found = false;\n  let pos = index;\n  let minPos = max(0, pos - lookaheadLimit);\n  while (pos > minPos) {\n    let c = codePointBefore(buffer, pos);\n    if (!isCaseIgnorable(c)) {\n      if (isCased(c)) {\n        found = true;\n      } else {\n        return false;\n      }\n    }\n    pos -= isize(c >= 0x10000) + 1;\n  }\n  if (!found) return false;\n  pos = index + 1;\n  let maxPos = min(pos + lookaheadLimit, len);\n  while (pos < maxPos) {\n    let c = <u32>load<u16>(buffer + (pos << 1));\n    if (u32((c & 0xFC00) == 0xD800) & u32(pos + 1 != len)) {\n      let c1 = <u32>load<u16>(buffer + (pos << 1), 2);\n      if ((c1 & 0xFC00) == 0xDC00) {\n        c = (c - 0xD800 << 10) + (c1 - 0xDC00) + 0x10000;\n      }\n    }\n    if (!isCaseIgnorable(c)) {\n      return !isCased(c);\n    }\n    pos += isize(c >= 0x10000) + 1;\n  }\n  return true;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction codePointBefore(buffer: usize, index: isize): i32 {\n  if (index <= 0) return -1;\n  let c = <u32>load<u16>(buffer + (index - 1 << 1));\n  if (u32((c & 0xFC00) == 0xDC00) & u32(index - 2 >= 0)) {\n    let c1 = <u32>load<u16>(buffer + (index - 2 << 1));\n    if ((c1 & 0xFC00) == 0xD800) {\n      return ((c1 & 0x3FF) << 10) + (c & 0x3FF) + 0x10000;\n    }\n  }\n  return (c & 0xF800) == 0xD800 ? 0xFFFD : c;\n}\n\n// Search routine for two-staged lookup tables\nfunction stagedBinaryLookup(table: usize, c: u32): bool {\n  return <bool>((load<u8>(table + (<u32>load<u8>(table + (c >>> 8)) << 5) + ((c & 255) >> 3)) >>> (c & 7)) & 1);\n}\n\nexport function compareImpl(str1: string, index1: usize, str2: string, index2: usize, len: usize): i32 {\n  let ptr1 = changetype<usize>(str1) + (index1 << 1);\n  let ptr2 = changetype<usize>(str2) + (index2 << 1);\n  if (ASC_SHRINK_LEVEL < 2) {\n    if (len >= 4 && !((ptr1 & 7) | (ptr2 & 7))) {\n      do {\n        if (load<u64>(ptr1) != load<u64>(ptr2)) break;\n        ptr1 += 8;\n        ptr2 += 8;\n        len  -= 4;\n      } while (len >= 4);\n    }\n  }\n  while (len--) {\n    let a = <i32>load<u16>(ptr1);\n    let b = <i32>load<u16>(ptr2);\n    if (a != b) return a - b;\n    ptr1 += 2;\n    ptr2 += 2;\n  }\n  return 0;\n}\n\n// @ts-ignore: decorator\n@inline\nexport function toLower8(c: u32): u32 {\n  if (ASC_SHRINK_LEVEL > 0) {\n    return c | u32(isUpper8(c)) << 5;\n  } else {\n    return <u32>load<u8>(LOWER127 + c);\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nexport function toUpper8(c: u32): u32 {\n  if (ASC_SHRINK_LEVEL > 0) {\n    return c & ~(u32(isLower8(c)) << 5);\n  } else {\n    return <u32>load<u8>(UPPER127 + c);\n  }\n}\n\n/** Parses a string to an integer (usually), using the specified radix. */\nexport function strtol<T>(str: string, radix: i32 = 0): T {\n  let len = str.length;\n  if (!len) {\n    if (isFloat<T>()) {\n      // @ts-ignore: cast\n      return <T>NaN;\n    } else {\n      // @ts-ignore: cast\n      return <T>0;\n    }\n  }\n\n  let ptr = changetype<usize>(str) /* + HEAD -> offset */;\n  let code = <u32>load<u16>(ptr);\n\n  // trim white spaces\n  while (isSpace(code)) {\n    code = <u32>load<u16>(ptr += 2);\n    --len;\n  }\n  // determine sign\n  // @ts-ignore\n  let sign: T = 1;\n  if (code == CharCode.MINUS || code == CharCode.PLUS) {\n    if (!--len) {\n      if (isFloat<T>()) {\n        // @ts-ignore: cast\n        return <T>NaN;\n      } else {\n        // @ts-ignore: cast\n        return <T>0;\n      }\n    }\n    if (code == CharCode.MINUS) {\n      // @ts-ignore: type\n      sign = -1;\n    }\n    code = <u32>load<u16>(ptr += 2);\n  }\n\n  // See https://tc39.es/ecma262/#sec-parseint-string-radix\n  if (radix) {\n    if (radix < 2 || radix > 36) {\n      if (isFloat<T>()) {\n        // @ts-ignore: cast\n        return <T>NaN;\n      } else {\n        // @ts-ignore: cast\n        return <T>0;\n      }\n    }\n    // handle case as parseInt(\"0xFF\", 16) by spec\n    if (radix == 16) {\n      if (\n        len > 2 &&\n        code == CharCode._0 &&\n        (<u32>load<u16>(ptr, 2) | 32) == CharCode.x\n      ) {\n        ptr += 4; len -= 2;\n      }\n    }\n  } else {\n    // determine radix by literal prefix\n    if (code == CharCode._0 && len > 2) {\n      switch (<u32>load<u16>(ptr, 2) | 32) {\n        case CharCode.b: {\n          ptr += 4; len -= 2;\n          radix = 2;\n          break;\n        }\n        case CharCode.o: {\n          ptr += 4; len -= 2;\n          radix = 8;\n          break;\n        }\n        case CharCode.x: {\n          ptr += 4; len -= 2;\n          radix = 16;\n          break;\n        }\n      }\n    }\n    if (!radix) radix = 10;\n  }\n\n  // calculate value\n  // @ts-ignore: type\n  let num: T = 0;\n  let initial = len - 1;\n  while (len--) {\n    code = <u32>load<u16>(ptr);\n    if (code - CharCode._0 < 10) {\n      code -= CharCode._0;\n    } else if (code - CharCode.A <= <u32>(CharCode.Z - CharCode.A)) {\n      code -= CharCode.A - 10;\n    } else if (code - CharCode.a <= <u32>(CharCode.z - CharCode.a)) {\n      code -= CharCode.a - 10;\n    }\n    if (code >= <u32>radix) {\n      if (initial == len) {\n        if (isFloat<T>()) {\n          // @ts-ignore: cast\n          return <T>NaN;\n        } else {\n          // @ts-ignore: cast\n          return <T>0;\n        }\n      }\n      break;\n    }\n    // @ts-ignore: type\n    num = num * radix + code;\n    ptr += 2;\n  }\n  // @ts-ignore: type\n  return sign * num;\n}\n\nexport function strtod(str: string): f64 {\n  let len = str.length;\n  if (!len) return NaN;\n\n  let ptr  = changetype<usize>(str);\n  let code = <u32>load<u16>(ptr);\n\n  let sign = 1.0;\n  // skip white spaces\n  while (len && isSpace(code)) {\n    code = <u32>load<u16>(ptr += 2);\n    --len;\n  }\n  if (!len) return NaN;\n\n  // try parse '-' or '+'\n  if (code == CharCode.MINUS) {\n    if (!--len) return NaN;\n    code = <u32>load<u16>(ptr += 2);\n    sign = -1;\n  } else if (code == CharCode.PLUS) {\n    if (!--len) return NaN;\n    code = <u32>load<u16>(ptr += 2);\n  }\n\n  // try parse Infinity\n  if (len >= 8 && code == CharCode.I) {\n    if (\n      load<u64>(ptr, 0) == 0x690066006E0049 && // ifnI\n      load<u64>(ptr, 8) == 0x7900740069006E    // ytin\n    ) {\n      return Infinity * sign;\n    }\n    return NaN;\n  }\n  // validate next symbol\n  if (code != CharCode.DOT && <u32>(code - CharCode._0) >= 10) {\n    return NaN;\n  }\n  let savedPtr = ptr;\n  // skip zeros\n  while (code == CharCode._0) {\n    code = <u32>load<u16>(ptr += 2);\n    --len;\n  }\n  if (len <= 0) return 0.0 * sign;\n  const capacity = 19; // int(64 * 0.3010)\n  let pointed = false;\n  let consumed = 0;\n  let position = 0;\n  let x: u64 = 0;\n  if (code == CharCode.DOT) {\n    let noDigits = !(savedPtr - ptr);\n    ptr += 2; --len;\n    if (!len && noDigits) return NaN;\n    for (pointed = true; (code = <u32>load<u16>(ptr)) == CharCode._0; --position, ptr += 2) --len;\n    if (len <= 0) return 0.0 * sign;\n    if (!position && noDigits && code - CharCode._0 >= 10) return NaN;\n  }\n  for (let digit = code - CharCode._0; digit < 10 || (code == CharCode.DOT && !pointed); digit = code - CharCode._0) {\n    if (digit < 10) {\n      x = consumed < capacity ? 10 * x + digit : x | u64(!!digit);\n      ++consumed;\n    } else {\n      position = consumed;\n      pointed = true;\n    }\n    if (!--len) break;\n    code = <u32>load<u16>(ptr += 2);\n  }\n\n  if (!pointed) position = consumed;\n  return copysign<f64>(scientific(x, position - min(capacity, consumed) + parseExp(ptr, len)), sign);\n}\n\nexport function strtob(str: string): bool {\n  let size: usize = str.length << 1;\n  let offset: usize = 0;\n  if (size > 8) {\n    // try trim end whitespaces first\n    while (size && isSpace(load<u16>(changetype<usize>(str) + size - 2))) size -= 2;\n    if (size > 8) {\n      // trim start whitespaces\n      while (offset < size && isSpace(load<u16>(changetype<usize>(str) + offset))) offset += 2;\n      size -= offset;\n    }\n  }\n  if (size != 8) return false;\n  // \"true\" represents as \\00\\e\\00\\u\\00\\e\\00\\t (00 65 00 75 00 72 00 74)\n  return load<u64>(changetype<usize>(str) + offset) == 0x0065_0075_0072_0074;\n}\n\nexport function joinBooleanArray(dataStart: usize, length: i32, separator: string): string {\n  let lastIndex = length - 1;\n  if (lastIndex < 0) return \"\";\n  if (!lastIndex) return select(\"true\", \"false\", load<bool>(dataStart));\n\n  let sepLen = separator.length;\n  let valueLen = 5; // max possible length of element len(\"false\")\n  let estLen = (valueLen + sepLen) * lastIndex + valueLen;\n  let result = changetype<string>(__new(estLen << 1, idof<string>()));\n  let offset = 0;\n  let value: bool;\n  for (let i = 0; i < lastIndex; ++i) {\n    value = load<bool>(dataStart + i);\n    valueLen = 4 + i32(!value);\n    memory.copy(\n      changetype<usize>(result) + (<usize>offset << 1),\n      changetype<usize>(select(\"true\", \"false\", value)),\n      <usize>valueLen << 1\n    );\n    offset += valueLen;\n    if (sepLen) {\n      memory.copy(\n        changetype<usize>(result) + (<usize>offset << 1),\n        changetype<usize>(separator),\n        <usize>sepLen << 1\n      );\n      offset += sepLen;\n    }\n  }\n  value = load<bool>(dataStart + <usize>lastIndex);\n  valueLen = 4 + i32(!value);\n  memory.copy(\n    changetype<usize>(result) + (<usize>offset << 1),\n    changetype<usize>(select(\"true\", \"false\", value)),\n    valueLen << 1\n  );\n  offset += valueLen;\n\n  if (estLen > offset) return result.substring(0, offset);\n  return result;\n}\n\nexport function joinIntegerArray<T>(dataStart: usize, length: i32, separator: string): string {\n  let lastIndex = length - 1;\n  if (lastIndex < 0) return \"\";\n  if (!lastIndex) {\n    let value = load<T>(dataStart);\n    if (isSigned<T>()) {\n      if (sizeof<T>() <= 4) {\n        // @ts-ignore: type\n        return changetype<string>(itoa32(<i32>value, 10));\n      } else {\n        // @ts-ignore: type\n        return changetype<string>(itoa64(<i32>value, 10));\n      }\n    } else {\n      if (sizeof<T>() <= 4) {\n        // @ts-ignore: type\n        return changetype<string>(utoa32(<u32>value, 10));\n      } else {\n        // @ts-ignore: type\n        return changetype<string>(utoa64(<u64>value, 10));\n      }\n    }\n  }\n\n  let sepLen = separator.length;\n  const valueLen = (sizeof<T>() <= 4 ? 10 : 20) + i32(isSigned<T>());\n  let estLen = (valueLen + sepLen) * lastIndex + valueLen;\n  let result = changetype<string>(__new(estLen << 1, idof<string>()));\n  let offset = 0;\n  let value: T;\n  for (let i = 0; i < lastIndex; ++i) {\n    value = load<T>(dataStart + (<usize>i << alignof<T>()));\n    // @ts-ignore: type\n    offset += itoa_buffered<T>(changetype<usize>(result) + (<usize>offset << 1), value);\n    if (sepLen) {\n      memory.copy(\n        changetype<usize>(result) + (<usize>offset << 1),\n        changetype<usize>(separator),\n        <usize>sepLen << 1\n      );\n      offset += sepLen;\n    }\n  }\n  value = load<T>(dataStart + (<usize>lastIndex << alignof<T>()));\n  // @ts-ignore: type\n  offset += itoa_buffered<T>(changetype<usize>(result) + (<usize>offset << 1), value);\n  if (estLen > offset) return result.substring(0, offset);\n  return result;\n}\n\nexport function joinFloatArray<T>(dataStart: usize, length: i32, separator: string): string {\n  let lastIndex = length - 1;\n  if (lastIndex < 0) return \"\";\n  if (!lastIndex) {\n    return changetype<string>(dtoa(\n      // @ts-ignore: type\n      load<T>(dataStart))\n    );\n  }\n\n  const valueLen = MAX_DOUBLE_LENGTH;\n  let sepLen = separator.length;\n  let estLen = (valueLen + sepLen) * lastIndex + valueLen;\n  let result = changetype<string>(__new(estLen << 1, idof<string>()));\n  let offset = 0;\n  let value: T;\n  for (let i = 0; i < lastIndex; ++i) {\n    value = load<T>(dataStart + (<usize>i << alignof<T>()));\n    // @ts-ignore: type\n    offset += dtoa_buffered(changetype<usize>(result) + (<usize>offset << 1), value);\n    if (sepLen) {\n      memory.copy(\n        changetype<usize>(result) + (<usize>offset << 1),\n        changetype<usize>(separator),\n        <usize>sepLen << 1\n      );\n      offset += sepLen;\n    }\n  }\n  value = load<T>(dataStart + (<usize>lastIndex << alignof<T>()));\n  // @ts-ignore: type\n  offset += dtoa_buffered(changetype<usize>(result) + (<usize>offset << 1), value);\n  if (estLen > offset) return result.substring(0, offset);\n  return result;\n}\n\nexport function joinStringArray(dataStart: usize, length: i32, separator: string): string {\n  let lastIndex = length - 1;\n  if (lastIndex < 0) return \"\";\n  if (!lastIndex) {\n    // @ts-ignore: type\n    return load<string>(dataStart) || \"\";\n  }\n  let estLen = 0;\n  let value: string;\n  for (let i = 0; i < length; ++i) {\n    value = load<string>(dataStart + (<usize>i << alignof<string>()));\n    if (changetype<usize>(value) != 0) estLen += value.length;\n  }\n  let offset = 0;\n  let sepLen = separator.length;\n  let result = changetype<string>(__new((estLen + sepLen * lastIndex) << 1, idof<string>()));\n  for (let i = 0; i < lastIndex; ++i) {\n    value = load<string>(dataStart + (<usize>i << alignof<string>()));\n    if (changetype<usize>(value) != 0) {\n      let valueLen = value.length;\n      memory.copy(\n        changetype<usize>(result) + (<usize>offset << 1),\n        changetype<usize>(value),\n        <usize>valueLen << 1\n      );\n      offset += valueLen;\n    }\n    if (sepLen) {\n      memory.copy(\n        changetype<usize>(result) + (<usize>offset << 1),\n        changetype<usize>(separator),\n        <usize>sepLen << 1\n      );\n      offset += sepLen;\n    }\n  }\n  value = load<string>(dataStart + (<usize>lastIndex << alignof<string>()));\n  if (changetype<usize>(value) != 0) {\n    memory.copy(\n      changetype<usize>(result) + (<usize>offset << 1),\n      changetype<usize>(value),\n      <usize>value.length << 1\n    );\n  }\n  return result;\n}\n\nexport function joinReferenceArray<T>(dataStart: usize, length: i32, separator: string): string {\n  let lastIndex = length - 1;\n  if (lastIndex < 0) return \"\";\n  let value: T;\n  if (!lastIndex) {\n    value = load<T>(dataStart);\n    // @ts-ignore: type\n    return value != null ? value.toString() : \"\";\n  }\n  let result = \"\";\n  let sepLen = separator.length;\n  for (let i = 0; i < lastIndex; ++i) {\n    value = load<T>(dataStart + (<usize>i << alignof<T>()));\n    // @ts-ignore: type\n    if (value != null) result += value.toString();\n    if (sepLen) result += separator;\n  }\n  value = load<T>(dataStart + (<usize>lastIndex << alignof<T>()));\n  // @ts-ignore: type\n  if (value != null) result += value.toString();\n  return result;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction scientific(significand: u64, exp: i32): f64 {\n  if (!significand || exp < -342) return 0;\n  if (exp > 308) return Infinity;\n  // Try use fast path\n  // Use fast path for string-to-double conversion if possible\n  // see http://www.exploringbinary.com/fast-path-decimal-to-floating-point-conversion\n  // Simple integer\n  let significandf = <f64>significand;\n  if (!exp) return significandf;\n  if (exp > 22 && exp <= 22 + 15) {\n    significandf *= pow10(exp - 22);\n    exp = 22;\n  }\n  if (significand <= 9007199254740991 && abs(exp) <= 22) {\n    if (exp > 0) return significandf * pow10(exp);\n    return significandf / pow10(-exp);\n  } else if (exp < 0) {\n    return scaledown(significand, exp);\n  } else {\n    return scaleup(significand, exp);\n  }\n}\n\n// Adopted from metallic lib:\n// https://github.com/jdh8/metallic/blob/master/src/stdlib/parse/scientific.h\n// @ts-ignore: decorator\n@inline\nfunction scaledown(significand: u64, exp: i32): f64 {\n  const denom: u64 = 6103515625; // 1e14 * 0x1p-14\n  const scale = reinterpret<f64>(0x3F06849B86A12B9B); // 1e-14 * 0x1p32\n\n  let shift = clz(significand);\n  significand <<= shift;\n  shift = exp - shift;\n\n  for (; exp <= -14; exp += 14) {\n    let q = significand / denom;\n    let r = significand % denom;\n    let s = clz(q);\n    significand = (q << s) + <u64>nearest(scale * <f64>(r << (s - 18)));\n    shift -= s;\n  }\n  let b = <u64>ipow32(5, -exp);\n  let q = significand / b;\n  let r = significand % b;\n  let s = clz(q);\n  significand = (q << s) + <u64>(reinterpret<f64>(reinterpret<u64>(<f64>r) + (s << 52)) / <f64>b);\n  shift -= s;\n\n  return NativeMath.scalbn(<f64>significand, <i32>shift);\n}\n\n// Adopted from metallic lib:\n// https://github.com/jdh8/metallic/blob/master/src/stdlib/parse/scientific.h\n// @ts-ignore: decorator\n@inline\nfunction scaleup(significand: u64, exp: i32): f64 {\n  const coeff: u32 = 1220703125; // 1e13 * 0x1p-13;\n  let shift = ctz(significand);\n  significand >>= shift;\n  shift += exp;\n\n  __fixmulShift = shift;\n  for (; exp >= 13; exp -= 13) {\n    significand = fixmul(significand, coeff);\n  }\n  significand = fixmul(significand, <u32>ipow32(5, exp));\n  shift = __fixmulShift;\n  return NativeMath.scalbn(<f64>significand, <i32>shift);\n}\n\n// Adopted from metallic lib:\n// https://github.com/jdh8/metallic/blob/master/src/stdlib/parse/scientific.h\n// @ts-ignore: decorator\n@inline\nfunction parseExp(ptr: usize, len: i32): i32 {\n  let sign = 1, magnitude = 0;\n  let code = <u32>load<u16>(ptr);\n  // check code is 'e' or 'E'\n  if ((code | 32) != CharCode.e) return 0;\n\n  if (!--len) return 0;\n  code = <u32>load<u16>(ptr += 2);\n  if (code == CharCode.MINUS) {\n    if (!--len) return 0;\n    code = <u32>load<u16>(ptr += 2);\n    sign = -1;\n  } else if (code == CharCode.PLUS) {\n    if (!--len) return 0;\n    code = <u32>load<u16>(ptr += 2);\n  }\n  // skip zeros\n  while (code == CharCode._0) {\n    if (!--len) return 0;\n    code = <u32>load<u16>(ptr += 2);\n  }\n  for (let digit: u32 = code - CharCode._0; len && digit < 10; digit = code - CharCode._0) {\n    if (magnitude >= 3200) return sign * 3200;\n    magnitude = 10 * magnitude + digit;\n    code = <u32>load<u16>(ptr += 2);\n    --len;\n  }\n  return sign * magnitude;\n}\n\n// @ts-ignore: decorator\n@lazy let __fixmulShift: u64 = 0;\n\n// Adopted from metallic lib:\n// https://github.com/jdh8/metallic/blob/master/src/stdlib/parse/scientific.h\n// @ts-ignore: decorator\n@inline\nfunction fixmul(a: u64, b: u32): u64 {\n  let low  = (a & 0xFFFFFFFF) * b;\n  let high = (a >> 32) * b + (low >> 32);\n  let overflow = <u32>(high >> 32);\n  let space = clz(overflow);\n  let revspace: u64 = 32 - space;\n  __fixmulShift += revspace;\n  return (high << space | (low & 0xFFFFFFFF) >> revspace) + (low << space >> 31 & 1);\n}\n\n// @ts-ignore: decorator\n@inline\nfunction pow10(n: i32): f64 {\n  // argument `n` should bounds in [0, 22] range\n  return load<f64>(POWERS10 + (n << alignof<f64>()));\n}\n","import { Typeinfo, TypeinfoFlags } from \"./shared/typeinfo\";\nimport { E_INDEXOUTOFRANGE } from \"./util/error\";\nimport { ArrayBufferView } from \"./arraybuffer\";\n\n// @ts-ignore: decorator\n@builtin\nexport declare const __rtti_base: usize;\n\n// @ts-ignore: decorator\n@builtin @unsafe\nexport declare function __visit_globals(cookie: u32): void;\n\n// @ts-ignore: decorator\n@builtin @unsafe\nexport declare function __visit_members(ref: usize, cookie: u32): void;\n\n// @ts-ignore: decorator\n@unsafe\nexport function __typeinfo(id: u32): TypeinfoFlags {\n  let ptr = __rtti_base;\n  if (id > load<u32>(ptr)) throw new Error(E_INDEXOUTOFRANGE);\n  return changetype<Typeinfo>(ptr + sizeof<u32>() + id * offsetof<Typeinfo>()).flags;\n}\n\n// @ts-ignore: decorator\n@unsafe\nexport function __newBuffer(size: usize, id: u32, data: usize = 0): usize {\n  let buffer = __new(size, id);\n  if (data) memory.copy(buffer, data, size);\n  return buffer;\n}\n\n// @ts-ignore: decorator\n@unsafe\nexport function __newArray(length: i32, alignLog2: usize, id: u32, data: usize = 0): usize {\n  let bufferSize = <usize>length << alignLog2;\n  // make sure `buffer` is tracked by the shadow stack\n  let buffer = changetype<ArrayBuffer>(__newBuffer(bufferSize, idof<ArrayBuffer>(), data));\n  // ...since allocating the array may trigger GC steps\n  let array = __new(offsetof<i32[]>(), id);\n  store<usize>(array, changetype<usize>(buffer), offsetof<ArrayBufferView>(\"buffer\"));\n  __link(array, changetype<usize>(buffer), false);\n  store<usize>(array, changetype<usize>(buffer), offsetof<ArrayBufferView>(\"dataStart\"));\n  store<i32>(array, bufferSize, offsetof<ArrayBufferView>(\"byteLength\"));\n  store<i32>(array, length, offsetof<i32[]>(\"length_\"));\n  return array;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nfunction __tostack(ptr: usize): usize { // eslint-disable-line\n  return ptr;\n}\n\n// These are provided by the respective implementation, included as another entry file by asc:\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __alloc(size: usize): usize;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __realloc(ptr: usize, size: usize): usize;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __free(ptr: usize): void;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __new(size: usize, id: u32): usize;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __renew(ptr: usize, size: usize): usize;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __link(parentPtr: usize, childPtr: usize, expectMultiple: bool): void;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __collect(): void;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __visit(ptr: usize, cookie: u32): void;\n","import { memcmp, memmove, memset } from \"./util/memory\";\nimport { E_NOTIMPLEMENTED } from \"./util/error\";\n\n/** Memory manager interface. */\nexport namespace memory {\n\n  /** Gets the size of the memory in pages. */\n  // @ts-ignore: decorator\n  @builtin\n  export declare function size(): i32;\n\n  /** Grows the memory by the given size in pages and returns the previous size in pages. */\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function grow(pages: i32): i32;\n\n  /** Fills a section in memory with the specified byte value. */\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export function fill(dst: usize, c: u8, n: usize): void {\n    memset(dst, c, n); // fallback if \"bulk-memory\" isn't enabled\n  }\n\n  /** Copies a section of memory to another. Has move semantics. */\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export function copy(dst: usize, src: usize, n: usize): void {\n    memmove(dst, src, n); // fallback if \"bulk-memory\" isn't enabled\n  }\n\n  export namespace atomic {\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function wait32(ptr: usize, expected: i32, timeout: i64): AtomicWaitResult;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function wait64(ptr: usize, expected: i64, timeout: i64): AtomicWaitResult;\n  }\n\n  /** Initializes a memory segment. */\n  // @ts-ignore: decorator\n  @unsafe\n  export function init(segmentIndex: u32, srcOffset: usize, dstOffset: usize, n: usize): void {\n    throw new Error(E_NOTIMPLEMENTED);\n  }\n\n  /** Drops a memory segment. */\n  // @ts-ignore: decorator\n  @unsafe\n  export function drop(segmentIndex: u32): void {\n    throw new Error(E_NOTIMPLEMENTED);\n  }\n\n  /** Repeats a section of memory at a specific address. */\n  // @ts-ignore: decorator\n  @unsafe\n  export function repeat(dst: usize, src: usize, srcLength: usize, count: usize): void {\n    let index: usize = 0;\n    let total = srcLength * count;\n    while (index < total) {\n      memory.copy(dst + index, src, srcLength);\n      index += srcLength;\n    }\n  }\n\n  /** Compares a section of memory to another. */\n  // @ts-ignore: decorator\n  @inline\n  export function compare(vl: usize, vr: usize, n: usize): i32 {\n    return memcmp(vl, vr, n);\n  }\n\n  /** Gets a pointer to a static chunk of memory of the given size. */\n  // @ts-ignore: decorator\n  @builtin\n  export declare function data<T>(size: T, align?: i32): usize;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare const __data_end: usize;\n\n// @ts-ignore: decorator\n@builtin\nexport declare let __stack_pointer: usize;\n\n// @ts-ignore: decorator\n@builtin\nexport declare const __heap_base: usize;\n\n/** Heap memory interface. */\nexport namespace heap {\n\n  /** Allocates a chunk of memory of at least the specified size. */\n  // @ts-ignore: decorator\n  @unsafe export function alloc(size: usize): usize {\n    return __alloc(size);\n  }\n\n  /** Reallocates a chunk of memory to have at least the specified size. */\n  // @ts-ignore: decorator\n  @unsafe export function realloc(ptr: usize, size: usize): usize {\n    return __realloc(ptr, size);\n  }\n\n  /** Frees a chunk of memory. Does hardly anything (most recent block only) with the stub runtime. */\n  // @ts-ignore: decorator\n  @unsafe export function free(ptr: usize): void {\n    __free(ptr);\n  }\n\n  /** Dangerously resets the entire heap. Specific to the stub runtime. */\n  // @ts-ignore: decorator\n  @unsafe export function reset(): void {\n    if (isDefined(__reset)) {\n      __reset();\n    } else {\n      throw new Error(E_NOTIMPLEMENTED);\n    }\n  }\n}\n","export function memcpy(dest: usize, src: usize, n: usize): void { // see: musl/src/string/memcpy.c\n  let w: u32, x: u32;\n\n  // copy 1 byte each until src is aligned to 4 bytes\n  while (n && (src & 3)) {\n    store<u8>(dest++, load<u8>(src++));\n    n--;\n  }\n\n  // if dst is aligned to 4 bytes as well, copy 4 bytes each\n  if ((dest & 3) == 0) {\n    while (n >= 16) {\n      store<u32>(dest     , load<u32>(src     ));\n      store<u32>(dest +  4, load<u32>(src +  4));\n      store<u32>(dest +  8, load<u32>(src +  8));\n      store<u32>(dest + 12, load<u32>(src + 12));\n      src += 16; dest += 16; n -= 16;\n    }\n    if (n & 8) {\n      store<u32>(dest    , load<u32>(src    ));\n      store<u32>(dest + 4, load<u32>(src + 4));\n      dest += 8; src += 8;\n    }\n    if (n & 4) {\n      store<u32>(dest, load<u32>(src));\n      dest += 4; src += 4;\n    }\n    if (n & 2) { // drop to 2 bytes each\n      store<u16>(dest, load<u16>(src));\n      dest += 2; src += 2;\n    }\n    if (n & 1) { // drop to 1 byte\n      store<u8>(dest++, load<u8>(src++));\n    }\n    return;\n  }\n\n  // if dst is not aligned to 4 bytes, use alternating shifts to copy 4 bytes each\n  // doing shifts if faster when copying enough bytes (here: 32 or more)\n  if (n >= 32) {\n    switch (<u32>dest & 3) {\n      // known to be != 0\n      case 1: {\n        w = load<u32>(src);\n        store<u8>(dest++, load<u8>(src++));\n        store<u8>(dest++, load<u8>(src++));\n        store<u8>(dest++, load<u8>(src++));\n        n -= 3;\n        while (n >= 17) {\n          x = load<u32>(src + 1);\n          store<u32>(dest, w >> 24 | x << 8);\n          w = load<u32>(src + 5);\n          store<u32>(dest + 4, x >> 24 | w << 8);\n          x = load<u32>(src + 9);\n          store<u32>(dest + 8, w >> 24 | x << 8);\n          w = load<u32>(src + 13);\n          store<u32>(dest + 12, x >> 24 | w << 8);\n          src += 16; dest += 16; n -= 16;\n        }\n        break;\n      }\n      case 2: {\n        w = load<u32>(src);\n        store<u8>(dest++, load<u8>(src++));\n        store<u8>(dest++, load<u8>(src++));\n        n -= 2;\n        while (n >= 18) {\n          x = load<u32>(src + 2);\n          store<u32>(dest, w >> 16 | x << 16);\n          w = load<u32>(src + 6);\n          store<u32>(dest + 4, x >> 16 | w << 16);\n          x = load<u32>(src + 10);\n          store<u32>(dest + 8, w >> 16 | x << 16);\n          w = load<u32>(src + 14);\n          store<u32>(dest + 12, x >> 16 | w << 16);\n          src += 16; dest += 16; n -= 16;\n        }\n        break;\n      }\n      case 3: {\n        w = load<u32>(src);\n        store<u8>(dest++, load<u8>(src++));\n        n -= 1;\n        while (n >= 19) {\n          x = load<u32>(src + 3);\n          store<u32>(dest, w >> 8 | x << 24);\n          w = load<u32>(src + 7);\n          store<u32>(dest + 4, x >> 8 | w << 24);\n          x = load<u32>(src + 11);\n          store<u32>(dest + 8, w >> 8 | x << 24);\n          w = load<u32>(src + 15);\n          store<u32>(dest + 12, x >> 8 | w << 24);\n          src += 16; dest += 16; n -= 16;\n        }\n        break;\n      }\n    }\n  }\n\n  // copy remaining bytes one by one\n  if (n & 16) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 8) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 4) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 2) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 1) {\n    store<u8>(dest++, load<u8>(src++));\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nexport function memmove(dest: usize, src: usize, n: usize): void { // see: musl/src/string/memmove.c\n  if (dest == src) return;\n  if (ASC_SHRINK_LEVEL < 1) {\n    if (src - dest - n <= -(n << 1)) {\n      memcpy(dest, src, n);\n      return;\n    }\n  }\n  if (dest < src) {\n    if (ASC_SHRINK_LEVEL < 2) {\n      if ((src & 7) == (dest & 7)) {\n        while (dest & 7) {\n          if (!n) return;\n          --n;\n          store<u8>(dest++, load<u8>(src++));\n        }\n        while (n >= 8) {\n          store<u64>(dest, load<u64>(src));\n          n    -= 8;\n          dest += 8;\n          src  += 8;\n        }\n      }\n    }\n    while (n) {\n      store<u8>(dest++, load<u8>(src++));\n      --n;\n    }\n  } else {\n    if (ASC_SHRINK_LEVEL < 2) {\n      if ((src & 7) == (dest & 7)) {\n        while ((dest + n) & 7) {\n          if (!n) return;\n          store<u8>(dest + --n, load<u8>(src + n));\n        }\n        while (n >= 8) {\n          n -= 8;\n          store<u64>(dest + n, load<u64>(src + n));\n        }\n      }\n    }\n    while (n) {\n      store<u8>(dest + --n, load<u8>(src + n));\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nexport function memset(dest: usize, c: u8, n: usize): void { // see: musl/src/string/memset\n  if (ASC_SHRINK_LEVEL > 1) {\n    while (n) {\n      store<u8>(dest++, c);\n      --n;\n    }\n  } else {\n    // fill head and tail with minimal branching\n    if (!n) return;\n    let dend = dest + n;\n    store<u8>(dest, c);\n    store<u8>(dend - 1, c);\n    if (n <= 2) return;\n    store<u8>(dest, c, 1);\n    store<u8>(dest, c, 2);\n    store<u8>(dend - 2, c);\n    store<u8>(dend - 3, c);\n    if (n <= 6) return;\n    store<u8>(dest, c, 3);\n    store<u8>(dend - 4, c);\n    if (n <= 8) return;\n\n    // advance pointer to align it at 4-byte boundary\n    let k: usize = -dest & 3;\n    dest += k;\n    n -= k;\n    n &= -4;\n\n    let c32: u32 = <u32>-1 / 255 * c;\n\n    // fill head/tail up to 28 bytes each in preparation\n    dend = dest + n;\n    store<u32>(dest, c32);\n    store<u32>(dend - 4, c32);\n    if (n <= 8) return;\n    store<u32>(dest, c32, 4);\n    store<u32>(dest, c32, 8);\n    store<u32>(dend - 12, c32);\n    store<u32>(dend - 8, c32);\n    if (n <= 24) return;\n    store<u32>(dest, c32, 12);\n    store<u32>(dest, c32, 16);\n    store<u32>(dest, c32, 20);\n    store<u32>(dest, c32, 24);\n    store<u32>(dend - 28, c32);\n    store<u32>(dend - 24, c32);\n    store<u32>(dend - 20, c32);\n    store<u32>(dend - 16, c32);\n\n    // align to a multiple of 8\n    k = 24 + (dest & 4);\n    dest += k;\n    n -= k;\n\n    // copy 32 bytes each\n    let c64: u64 = <u64>c32 | (<u64>c32 << 32);\n    while (n >= 32) {\n      store<u64>(dest, c64);\n      store<u64>(dest, c64, 8);\n      store<u64>(dest, c64, 16);\n      store<u64>(dest, c64, 24);\n      n -= 32;\n      dest += 32;\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nexport function memcmp(vl: usize, vr: usize, n: usize): i32 {\n  if (vl == vr) return 0;\n  if (ASC_SHRINK_LEVEL < 2) {\n    if ((vl & 7) == (vr & 7)) {\n      while (vl & 7) {\n        if (!n) return 0;\n        let a = <i32>load<u8>(vl);\n        let b = <i32>load<u8>(vr);\n        if (a != b) return a - b;\n        n--; vl++; vr++;\n      }\n      while (n >= 8) {\n        if (load<u64>(vl) != load<u64>(vr)) break;\n        vl += 8;\n        vr += 8;\n        n  -= 8;\n      }\n    }\n  }\n  while (n--) {\n    let a = <i32>load<u8>(vl);\n    let b = <i32>load<u8>(vr);\n    if (a != b) return a - b;\n    vl++; vr++;\n  }\n  return 0;\n}\n","import { Canvas } from '../dom';\nimport { BaseGPU, Device, GPU, MipmapHint, Texture } from '../gpu';\nimport { generateMipmap } from '../mugl';\nimport { WebGL2Device } from './resource';\nimport { WebGLContextAttributes, WebGL2Feature } from './type';\n\n/**\n * WebGL2 implementation of the GPU interface.\n */\nexport class WebGL2GPU extends BaseGPU implements GPU {\n  /**\n   * Requests a WebGL2 {@link Device}.\n   * @param canvas the canvas to be used\n   * @param desc WebGL context initialization options\n   * @param features WebGL features to be enabled\n   * @returns WebGL2 GPU device instance, or null if WebGL2 is not supported\n   */\n  public requestWebGL2Device(\n    canvas: Canvas,\n    desc: WebGLContextAttributes = {} as WebGLContextAttributes,\n    features: WebGL2Feature = 0 as WebGL2Feature\n  ): WebGL2Device | null {\n    const device = new WebGL2Device(canvas, desc, features);\n    return device.id ? device : null;\n  }\n\n  /**\n   * Generates mipmap for a texture.\n   * @param device the GPU device\n   * @param texture the texture\n   * @param hint mipmap quality hint\n   */\n  public generateMipmap(device: Device, texture: Texture, hint: MipmapHint = MipmapHint.Fast): void {\n    generateMipmap(device.id, texture.id, hint);\n  }\n}\n\n/*\n * WebGL implementation of the GPU interface.\n */\nexport const WebGL = new WebGL2GPU();\n","import { TextureFormat } from '../gpu';\n\nconst depth32float_stencil8 = 0x1;\nconst shader_f16 = 0x2;\nconst rg11b10ufloat_renderable = 0x4;\nconst float32_filterable = 0x8;\n\n/** Supported WebGPU features. */\nexport enum WebGPUFeature {\n  Depth32FStencil8 = depth32float_stencil8,\n  ShaderF16 = shader_f16,\n  RG11B10FRenderable = rg11b10ufloat_renderable,\n  F32Filterable = float32_filterable,\n}\n\n/** Descriptor for a WebGPU context. */\nexport class WebGPUContextAttributes {\n  powerPreference: string = 'high-performance';\n  forceFallbackAdapter: boolean = false;\n  premultipliedAlpha: boolean = false;\n  depthStencilFormat: TextureFormat = TextureFormat.Depth24Stencil8;\n  sampleCount: u32 = 1;\n}\n\n/** Attribute flags for a WebGPU context. */\nexport enum WebGPUContextAttributeFlag {\n  Depth = 0x0001,\n  Depth32F = 0x0002,\n  ForceFallbackAdapter = 0x0004,\n  HighPerformance = 0x0008,\n  Multisampled = 0x0010,\n  PremultipliedAlpha = 0x0020,\n  Stencil = 0x0040,\n}\n","import { BaseGPU } from '../gpu/base-gpu';\nimport { Canvas } from '../dom';\nimport { GPU, Texture } from '../gpu';\nimport { WebGPUContextAttributes, WebGPUFeature } from './type';\nimport { WebGPUDevice, WebGPUDeviceFuture } from './resource';\nimport { createWebGPUSurfaceDepthTexture, createWebGPUSurfaceTexture } from '../mugl';\nimport { toWebGPUContextAttributeFlag } from './serialize';\n\n/**\n * WebGPU implementation of the GPU interface.\n */\nexport class WebGPUGPU extends BaseGPU implements GPU {\n  /**\n   * Requests a WebGPU device.\n   * @param canvas the canvas to be used\n   * @param desc WebGPU context initialization options\n   * @param features WebGPU features to be enabled\n   * @returns future to WebGPU device instance, or null if WebGPU is not supported\n   */\n  public requestWebGPUDevice(\n    canvas: Canvas,\n    desc: WebGPUContextAttributes = {} as WebGPUContextAttributes,\n    features: WebGPUFeature = 0 as WebGPUFeature\n  ): WebGPUDeviceFuture {\n    return new WebGPUDeviceFuture(canvas, desc, features);\n  }\n\n  /**\n   * Creates a new texture object from a canvas surface.\n   * @param device the GPU device\n   * @param canvas the canvas to be used. Defaults to the device default canvas.\n   * @param desc WebGPU canvas surface options\n   * @returns new texture object\n   */\n  public createSurfaceTexture(\n    device: WebGPUDevice,\n    canvas: Canvas | null = null,\n    desc: WebGPUContextAttributes = {} as WebGPUContextAttributes\n  ): Texture {\n    return new Texture(createWebGPUSurfaceTexture(\n      device.id,\n      canvas ? canvas.id : 0,\n      toWebGPUContextAttributeFlag(desc)\n    ));\n  }\n\n  /**\n   * Creates a new depth-stencil texture object from a canvas surface.\n   * @param device the GPU device\n   * @param canvas the canvas to be used. Defaults to the device default canvas.\n   * @param desc WebGPU canvas surface options\n   * @returns new texture object\n   */\n  public createSurfaceDepthTexture(\n    device: WebGPUDevice,\n    canvas: Canvas | null = null,\n    desc: WebGPUContextAttributes = {} as WebGPUContextAttributes\n  ): Texture {\n    return new Texture(createWebGPUSurfaceDepthTexture(\n      device.id,\n      canvas ? canvas.id : 0,\n      toWebGPUContextAttributeFlag(desc)\n    ));\n  }\n}\n\n/*\n * WebGPU implementation of the GPU interface.\n */\nexport const WebGPU = new WebGPUGPU();\n","export const APP_CONTEXT_ID = 1337; // This can be anything\nexport const TEX_SIZE = 512;\n","import { Float, UInt } from '../interop/mugl';\n\nexport class Model {\n  public readonly indices: Float[][] | null = null;\n  public readonly positions: Float[][] | null = null;\n  public readonly uvs: Float[][] | null = null;\n  public readonly normals: Float[][] | null = null;\n  public readonly colors: Float[][] | null = null;\n}\n\nexport function toVertices(model: Model): Float32Array {\n  const positions = model.positions;\n  const uvs = model.uvs;\n  const normals = model.normals;\n  const colors = model.colors;\n\n  let countPerVertex = 0;\n  let length = 0;\n  if (positions) {\n    length = positions.length;\n    countPerVertex += 3;\n  }\n  if (uvs) {\n    countPerVertex += 2;\n  }\n  if (normals) {\n    countPerVertex += 3;\n  }\n  if (colors) {\n    countPerVertex += 4;\n  }\n\n  const out = new Float32Array(countPerVertex * length);\n  for (let i = 0; i < length; ++i) {\n    let j = 0;\n    if (positions) {\n      out[i * countPerVertex + j++] = positions[i][0];\n      out[i * countPerVertex + j++] = positions[i][1];\n      out[i * countPerVertex + j++] = positions[i][2];\n    }\n    if (uvs) {\n      out[i * countPerVertex + j++] = uvs[i][0];\n      out[i * countPerVertex + j++] = uvs[i][1];\n    }\n    if (normals) {\n      out[i * countPerVertex + j++] = normals[i][0];\n      out[i * countPerVertex + j++] = normals[i][1];\n      out[i * countPerVertex + j++] = normals[i][2];\n    }\n    if (colors) {\n      out[i * countPerVertex + j++] = colors[i][0];\n      out[i * countPerVertex + j++] = colors[i][1];\n      out[i * countPerVertex + j++] = colors[i][2];\n      out[i * countPerVertex + j++] = colors[i][3];\n    }\n  }\n  return out;\n}\n\nexport function toIndices(model: Model): Uint16Array {\n  const indices = model.indices;\n  if (!indices) {\n    return new Uint16Array(0);\n  }\n  const out = new Uint16Array(indices.length * 3);\n  for (let i = 0; i < indices.length; ++i) {\n    out[i * 3] = indices[i][0] as UInt;\n    out[i * 3 + 1] = indices[i][1] as UInt;\n    out[i * 3 + 2] = indices[i][2] as UInt;\n  }\n  return out;\n}\n\nexport const Triangle: Model = {\n  positions: [\n    [0.0, 0.5, 0.0],\n    [0.5, -0.5, 0.0],\n    [-0.5, -0.5, 0.0]\n  ],\n  colors: [\n    [1.0, 0.0, 0.0, 1.0],\n    [0.0, 1.0, 0.0, 1.0],\n    [0.0, 0.0, 1.0, 1.0],\n  ]\n} as Model;\n\nexport const Quad: Model = {\n  positions: [\n    [-1.0, -1.0, 1.0], [+1.0, -1.0, 1.0], [+1.0, +1.0, 1.0], // first triangle\n    [-1.0, -1.0, 1.0], [+1.0, +1.0, 1.0], [-1.0, +1.0, 1.0]  // second triangle\n  ],\n  uvs: [\n    [0.0, 0.0], [1.0, 0.0], [1.0, 1.0],\n    [0.0, 0.0], [1.0, 1.0], [0.0, 1.0]\n  ]\n} as Model;\n\nexport const Cube: Model = {\n  indices: [\n    [2, 1, 0], [2, 0, 3],       // positive z face\n    [6, 5, 4], [6, 4, 7],       // negative z face\n    [10, 9, 8], [10, 8, 11],    // positive x face\n    [14, 13, 12], [14, 12, 15], // negative x face\n    [18, 17, 16], [18, 16, 19], // positive y face\n    [20, 21, 22], [23, 20, 22]  // negative y face\n  ],\n  positions: [\n    [-1.0, +1.0, +1.0], [+1.0, +1.0, +1.0], [+1.0, -1.0, +1.0], [-1.0, -1.0, +1.0], // positive z face\n    [+1.0, +1.0, -1.0], [-1.0, +1.0, -1.0], [-1.0, -1.0, -1.0], [+1.0, -1.0, -1.0], // negative z face\n    [+1.0, +1.0, +1.0], [+1.0, +1.0, -1.0], [+1.0, -1.0, -1.0], [+1.0, -1.0, +1.0], // positive x face\n    [-1.0, +1.0, -1.0], [-1.0, +1.0, +1.0], [-1.0, -1.0, +1.0], [-1.0, -1.0, -1.0], // negative x face\n    [-1.0, +1.0, -1.0], [+1.0, +1.0, -1.0], [+1.0, +1.0, +1.0], [-1.0, +1.0, +1.0], // positive y face\n    [-1.0, -1.0, -1.0], [+1.0, -1.0, -1.0], [+1.0, -1.0, +1.0], [-1.0, -1.0, +1.0]  // negative y face\n  ],\n  uvs: [\n    [0.0, 0.0], [1.0, 0.0], [1.0, 1.0], [0.0, 1.0],\n    [0.0, 0.0], [1.0, 0.0], [1.0, 1.0], [0.0, 1.0],\n    [0.0, 0.0], [1.0, 0.0], [1.0, 1.0], [0.0, 1.0],\n    [0.0, 0.0], [1.0, 0.0], [1.0, 1.0], [0.0, 1.0],\n    [0.0, 0.0], [1.0, 0.0], [1.0, 1.0], [0.0, 1.0],\n    [0.0, 0.0], [1.0, 0.0], [1.0, 1.0], [0.0, 1.0]\n  ],\n  normals: [\n    [0, 0, +1.0], [0, 0, +1.0], [0, 0, +1.0], [0, 0, +1.0],\n    [0, 0, -1.0], [0, 0, -1.0], [0, 0, -1.0], [0, 0, -1.0],\n    [+1.0, 0, 0], [+1.0, 0, 0], [+1.0, 0, 0], [+1.0, 0, 0],\n    [-1.0, 0, 0], [-1.0, 0, 0], [-1.0, 0, 0], [-1.0, 0, 0],\n    [0, +1.0, 0], [0, +1.0, 0], [0, +1.0, 0], [0, +1.0, 0],\n    [0, -1.0, 0], [0, -1.0, 0], [0, -1.0, 0], [0, -1.0, 0]\n  ],\n  colors: [\n    [1.0, 0.0, 0.0, 1.0], [1.0, 0.0, 0.0, 1.0], [1.0, 0.0, 0.0, 1.0], [1.0, 0.0, 0.0, 1.0],\n    [0.0, 1.0, 0.0, 1.0], [0.0, 1.0, 0.0, 1.0], [0.0, 1.0, 0.0, 1.0], [0.0, 1.0, 0.0, 1.0],\n    [0.0, 0.0, 1.0, 1.0], [0.0, 0.0, 1.0, 1.0], [0.0, 0.0, 1.0, 1.0], [0.0, 0.0, 1.0, 1.0],\n    [1.0, 1.0, 0.0, 1.0], [1.0, 1.0, 0.0, 1.0], [1.0, 1.0, 0.0, 1.0], [1.0, 1.0, 0.0, 1.0],\n    [0.0, 1.0, 1.0, 1.0], [0.0, 1.0, 1.0, 1.0], [0.0, 1.0, 1.0, 1.0], [0.0, 1.0, 1.0, 1.0],\n    [1.0, 0.0, 1.0, 1.0], [1.0, 0.0, 1.0, 1.0], [1.0, 0.0, 1.0, 1.0], [1.0, 0.0, 1.0, 1.0]\n  ]\n} as Model;\n","import { compareImpl } from \"./string\";\n\ntype Comparator<T> = (a: T, b: T) => i32;\n\n// @ts-ignore: decorator\n@lazy @inline const EMPTY = u32.MAX_VALUE;\n// @ts-ignore: decorator\n@inline const INSERTION_SORT_THRESHOLD = 48;\n// @ts-ignore: decorator\n@inline const MIN_RUN_LENGTH = 32;\n\n// @ts-ignore: decorator\n@inline\nfunction log2u(n: u32): u32 {\n  return 31 - clz(n);\n}\n\n// @ts-ignore: decorator\n@inline\nexport function COMPARATOR<T>(): Comparator<T> {\n  if (isInteger<T>()) {\n    if (isSigned<T>() && sizeof<T>() <= 4) {\n      return (a, b) => i32(a) - i32(b);\n    } else {\n      return (a, b) => i32(a > b) - i32(a < b);\n    }\n  } else if (isFloat<T>()) {\n    if (sizeof<T>() == 4) {\n      return (a, b) => {\n        let ia = reinterpret<i32>(f32(a));\n        let ib = reinterpret<i32>(f32(b));\n        ia ^= ia >> 31 >>> 1;\n        ib ^= ib >> 31 >>> 1;\n        return i32(ia > ib) - i32(ia < ib);\n      };\n    } else {\n      return (a, b) => {\n        let ia = reinterpret<i64>(f64(a));\n        let ib = reinterpret<i64>(f64(b));\n        ia ^= ia >> 63 >>> 1;\n        ib ^= ib >> 63 >>> 1;\n        return i32(ia > ib) - i32(ia < ib);\n      };\n    }\n  } else if (isString<T>()) {\n    return (a, b) => {\n      if (\n        changetype<usize>(a) == changetype<usize>(b) ||\n        changetype<usize>(a) == 0 ||\n        changetype<usize>(b) == 0\n      ) return 0;\n      let alen = changetype<string>(a).length;\n      let blen = changetype<string>(b).length;\n      if (!(alen | blen)) return 0;\n      if (!alen) return -1;\n      if (!blen) return  1;\n      let res = compareImpl(\n        changetype<string>(a), 0,\n        changetype<string>(b), 0,\n        <usize>min(alen, blen)\n      );\n      return res ? res : alen - blen;\n    };\n  } else {\n    return (a, b) => i32(a > b) - i32(a < b);\n  }\n}\n\n// Power Sort implementation (stable) from paper \"Nearly-Optimal Mergesorts\"\n// https://arxiv.org/pdf/1805.04154.pdf\n// This method usually outperform TimSort.\n// TODO: refactor c >>> 31 to c < 0 when binaryen will support this opt\nexport function SORT<T>(\n  ptr: usize,\n  len: i32,\n  comparator: Comparator<T>\n): void {\n  if (len <= INSERTION_SORT_THRESHOLD) {\n    if (len <= 1) return;\n    if (ASC_SHRINK_LEVEL < 1) {\n      switch (len) {\n        case 3: {\n          let a = load<T>(ptr, 0);\n          let b = load<T>(ptr, 1 << alignof<T>());\n          let c = comparator(a, b) > 0;\n          store<T>(ptr, select<T>(b, a, c), 0);\n          a = select<T>(a, b, c);\n          b = load<T>(ptr, 2 << alignof<T>());\n          c = comparator(a, b) > 0;\n          store<T>(ptr, select<T>(b, a, c), 1 << alignof<T>());\n          store<T>(ptr, select<T>(a, b, c), 2 << alignof<T>());\n        }\n        case 2: {\n          let a = load<T>(ptr, 0);\n          let b = load<T>(ptr, 1 << alignof<T>());\n          let c = comparator(a, b) > 0;\n          store<T>(ptr, select<T>(b, a, c), 0);\n          store<T>(ptr, select<T>(a, b, c), 1 << alignof<T>());\n          return;\n        }\n      }\n    }\n    insertionSort<T>(ptr, 0, len - 1, 0, comparator);\n    return;\n  }\n\n  let lgPlus2         = log2u(len) + 2;\n  let lgPlus2Size     = lgPlus2 << alignof<u32>();\n  let leftRunStartBuf = __alloc(lgPlus2Size << 1);\n  let leftRunEndBuf   = leftRunStartBuf + lgPlus2Size;\n\n  for (let i: u32 = 0; i < lgPlus2; ++i) {\n    store<u32>(leftRunStartBuf + (<usize>i << alignof<u32>()), EMPTY);\n  }\n\n  let buffer = __alloc(len << alignof<T>());\n\n  let hi   = len - 1;\n  let endA = extendRunRight<T>(ptr, 0, hi, comparator);\n  let lenA = endA + 1;\n\n  if (lenA < MIN_RUN_LENGTH) {\n    endA = min(hi, MIN_RUN_LENGTH - 1);\n    insertionSort<T>(ptr, 0, endA, lenA, comparator);\n  }\n\n  let top: u32 = 0, startA = 0;\n  while (endA < hi) {\n    let startB = endA + 1;\n    let endB = extendRunRight<T>(ptr, startB, hi, comparator);\n    let lenB = endB - startB + 1;\n\n    if (lenB < MIN_RUN_LENGTH) {\n      endB = min(hi, startB + MIN_RUN_LENGTH - 1);\n      insertionSort<T>(ptr, startB, endB, lenB, comparator);\n    }\n\n    let k = nodePower(0, hi, startA, startB, endB);\n\n    for (let i = top; i > k; --i) {\n      let start = load<u32>(leftRunStartBuf + (<usize>i << alignof<u32>()));\n      if (start != EMPTY) {\n        mergeRuns<T>(\n          ptr,\n          start,\n          load<u32>(leftRunEndBuf + (<usize>i << alignof<u32>())) + 1,\n          endA,\n          buffer,\n          comparator\n        );\n        startA = start;\n        store<u32>(leftRunStartBuf + (<usize>i << alignof<u32>()), EMPTY);\n      }\n    }\n\n    store<u32>(leftRunStartBuf + (<usize>k << alignof<u32>()), startA);\n    store<u32>(leftRunEndBuf   + (<usize>k << alignof<u32>()), endA);\n    startA = startB;\n    endA = endB;\n    top = k;\n  }\n\n  for (let i = top; i != 0; --i) {\n    let start = load<u32>(leftRunStartBuf + (<usize>i << alignof<u32>()));\n    if (start != EMPTY) {\n      mergeRuns<T>(\n        ptr,\n        start,\n        load<u32>(leftRunEndBuf + (<usize>i << alignof<u32>())) + 1,\n        hi,\n        buffer,\n        comparator\n      );\n    }\n  }\n  // dealloc aux buffers\n  __free(buffer);\n  __free(leftRunStartBuf);\n}\n\nfunction insertionSort<T>(\n  ptr: usize,\n  left: i32,\n  right: i32,\n  presorted: i32,\n  comparator: Comparator<T>\n): void {\n  if (ASC_SHRINK_LEVEL >= 1) {\n    // slightly improved original insertion sort\n    for (let i = left + presorted; i <= right; ++i) {\n      let j = i - 1;\n      let a = load<T>(ptr + (<usize>i << alignof<T>()));\n      while (j >= left) {\n        let b = load<T>(ptr + (<usize>j << alignof<T>()));\n        if (comparator(a, b) < 0) {\n          store<T>(ptr + (<usize>j << alignof<T>()), b, 1 << alignof<T>()); --j;\n        } else break;\n      }\n      store<T>(ptr + (<usize>j << alignof<T>()), a, 1 << alignof<T>());\n    }\n  } else {\n    // even-odd two-way insertion sort which allow increase minRunLen\n    let range = right - left + 1;\n    let i = left + select(range & 1, presorted - ((range - presorted) & 1), presorted == 0);\n    for (; i <= right; i += 2) {\n      let a = load<T>(ptr + (<usize>i << alignof<T>()), 0);\n      let b = load<T>(ptr + (<usize>i << alignof<T>()), 1 << alignof<T>());\n      let min = b, max = a;\n      if (comparator(a, b) <= 0) {\n        min = a, max = b;\n      }\n      let j = i - 1;\n      while (j >= left) {\n        a = load<T>(ptr + (<usize>j << alignof<T>()));\n        if (comparator(a, max) > 0) {\n          store<T>(ptr + (<usize>j << alignof<T>()), a, 2 << alignof<T>()); --j;\n        } else break;\n      }\n      store<T>(ptr + (<usize>j << alignof<T>()), max, 2 << alignof<T>());\n      while (j >= left) {\n        a = load<T>(ptr + (<usize>j << alignof<T>()));\n        if (comparator(a, min) > 0) {\n          store<T>(ptr + (<usize>j << alignof<T>()), a, 1 << alignof<T>()); --j;\n        } else break;\n      }\n      store<T>(ptr + (<usize>j << alignof<T>()), min, 1 << alignof<T>());\n    }\n  }\n}\n\nfunction nodePower(left: u32, right: u32, startA: u32, startB: u32, endB: u32): u32 {\n  let n: u64 = right - left + 1;\n  let s = startB - (left << 1);\n  let l = startA + s;\n  let r = endB   + s + 1;\n  let a = (<u64>l << 30) / n;\n  let b = (<u64>r << 30) / n;\n  return clz(<u32>(a ^ b));\n}\n\nfunction extendRunRight<T>(\n  ptr: usize,\n  i: i32,\n  right: i32,\n  comparator: Comparator<T>\n): i32 {\n  if (i == right) return i;\n  let j = i;\n  if (comparator(\n    load<T>(ptr + (<usize>  j << alignof<T>())),\n    load<T>(ptr + (<usize>++j << alignof<T>()))\n  ) > 0) {\n    while (\n      j < right &&\n      (comparator(\n        load<T>(ptr + (<usize>j << alignof<T>()), 1 << alignof<T>()),\n        load<T>(ptr + (<usize>j << alignof<T>()))\n      ) >>> 31) // < 0\n    ) ++j;\n    // reverse\n    let k = j;\n    while (i < k) {\n      let tmp = load<T>(ptr + (<usize>i << alignof<T>()));\n      store<T>(ptr + (<usize>i << alignof<T>()), load<T>(ptr + (<usize>k << alignof<T>()))); ++i;\n      store<T>(ptr + (<usize>k << alignof<T>()), tmp); --k;\n    }\n  } else {\n    while (\n      j < right &&\n      comparator(\n        load<T>(ptr + (<usize>j << alignof<T>()), 1 << alignof<T>()),\n        load<T>(ptr + (<usize>j << alignof<T>()))\n      ) >= 0\n    ) ++j;\n  }\n  return j;\n}\n\n// Merges arr[l..m - 1] and arr[m..r]\nfunction mergeRuns<T>(\n  ptr: usize,\n  l: i32,\n  m: i32,\n  r: i32,\n  buffer: usize,\n  comparator: Comparator<T>\n): void {\n  --m;\n  let i: i32, j: i32, t = r + m;\n  for (i = m + 1; i > l; --i) {\n    store<T>(\n      buffer + (<usize>(i - 1) << alignof<T>()),\n      load<T>(ptr + (<usize>(i - 1) << alignof<T>()))\n    );\n  }\n  for (j = m; j < r; ++j) {\n    store<T>(\n      buffer + (<usize>(t - j) << alignof<T>()),\n      load<T>(ptr + (<usize>j << alignof<T>()), 1 << alignof<T>())\n    );\n  }\n  for (let k = l; k <= r; ++k) {\n    let a = load<T>(buffer + (<usize>j << alignof<T>()));\n    let b = load<T>(buffer + (<usize>i << alignof<T>()));\n    if (comparator(a, b) < 0) {\n      store<T>(ptr + (<usize>k << alignof<T>()), a);\n      --j;\n    } else {\n      store<T>(ptr + (<usize>k << alignof<T>()), b);\n      ++i;\n    }\n  }\n}\n","/// <reference path=\"./rt/index.d.ts\" />\n\nimport { BLOCK_MAXSIZE } from \"./rt/common\";\nimport { Runtime } from \"shared/runtime\";\nimport { COMPARATOR, SORT } from \"./util/sort\";\nimport { REVERSE, FILL } from \"./util/bytes\";\nimport { joinBooleanArray, joinIntegerArray, joinFloatArray, joinStringArray, joinReferenceArray } from \"./util/string\";\nimport { idof, isArray as builtin_isArray } from \"./builtins\";\nimport { E_INDEXOUTOFRANGE, E_INVALIDLENGTH, E_EMPTYARRAY, E_HOLEYARRAY } from \"./util/error\";\n\n// @ts-ignore: decorator\n@inline @lazy const MIN_SIZE: usize = 8;\n\n/** Ensures that the given array has _at least_ the specified backing size. */\nfunction ensureCapacity(array: usize, newSize: usize, alignLog2: u32, canGrow: bool = true): void {\n  // Depends on the fact that Arrays mimic ArrayBufferView\n  let oldCapacity = <usize>changetype<ArrayBufferView>(array).byteLength;\n  if (newSize > oldCapacity >>> alignLog2) {\n    if (newSize > BLOCK_MAXSIZE >>> alignLog2) throw new RangeError(E_INVALIDLENGTH);\n    let oldData = changetype<usize>(changetype<ArrayBufferView>(array).buffer);\n    // Grows old capacity by factor of two.\n    // Make sure we don't reach BLOCK_MAXSIZE for new growed capacity.\n    let newCapacity = max(newSize, MIN_SIZE) << alignLog2;\n    if (canGrow) newCapacity = max(min(oldCapacity << 1, BLOCK_MAXSIZE), newCapacity);\n    let newData = __renew(oldData, newCapacity);\n    // __new / __renew already init memory range as zeros in Incremental runtime.\n    // So try to avoid this.\n    if (ASC_RUNTIME != Runtime.Incremental) {\n      memory.fill(newData + oldCapacity, 0, newCapacity - oldCapacity);\n    }\n    if (newData != oldData) { // oldData has been free'd\n      store<usize>(array, newData, offsetof<ArrayBufferView>(\"buffer\"));\n      store<usize>(array, newData, offsetof<ArrayBufferView>(\"dataStart\"));\n      __link(array, changetype<usize>(newData), false);\n    }\n    store<u32>(array, <u32>newCapacity, offsetof<ArrayBufferView>(\"byteLength\"));\n  }\n}\n\nexport class Array<T> {\n  [key: number]: T;\n\n  // Mimicking ArrayBufferView isn't strictly necessary here but is done to allow glue code\n  // to work with typed and normal arrays interchangeably. Technically, normal arrays do not need\n  // `dataStart` (equals `buffer`) and `byteLength` (equals computed `buffer.byteLength`), but the\n  // block is 16 bytes anyway so it's fine to have a couple extra fields in there.\n\n  private buffer: ArrayBuffer;\n  @unsafe readonly dataStart: usize;\n  private byteLength: i32; // Uses here as capacity\n\n  // Also note that Array<T> with non-nullable T must guard against uninitialized null values\n  // whenever an element is accessed. Otherwise, the compiler wouldn't be able to guarantee\n  // type-safety anymore. For lack of a better word, such an array is \"holey\".\n\n  private length_: i32;\n\n  static isArray<U>(value: U): bool {\n    return isReference<U>() ? changetype<usize>(value) != 0 && builtin_isArray(value) : false;\n  }\n\n  static create<T>(capacity: i32 = 0): Array<T> {\n    WARNING(\"'Array.create' is deprecated. Use 'new Array' instead, making sure initial elements are initialized.\");\n    let array = new Array<T>(capacity);\n    array.length = 0;\n    return array;\n  }\n\n  constructor(length: i32 = 0) {\n    if (<u32>length > <u32>BLOCK_MAXSIZE >>> alignof<T>()) throw new RangeError(E_INVALIDLENGTH);\n    // reserve capacity for at least MIN_SIZE elements\n    let bufferSize = max(<usize>length, MIN_SIZE) << alignof<T>();\n    let buffer = changetype<ArrayBuffer>(__new(bufferSize, idof<ArrayBuffer>()));\n    if (ASC_RUNTIME != Runtime.Incremental) {\n      memory.fill(changetype<usize>(buffer), 0, bufferSize);\n    }\n    this.buffer = buffer; // links\n    this.dataStart = changetype<usize>(buffer);\n    this.byteLength = <i32>bufferSize;\n    this.length_ = length;\n  }\n\n  get length(): i32 {\n    return this.length_;\n  }\n\n  set length(newLength: i32) {\n    ensureCapacity(changetype<usize>(this), newLength, alignof<T>(), false);\n    this.length_ = newLength;\n  }\n\n  every(fn: (value: T, index: i32, array: Array<T>) => bool): bool {\n    for (let i = 0, len = this.length_; i < min(len, this.length_); ++i) {\n      if (!fn(load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this)) return false;\n    }\n    return true;\n  }\n\n  findIndex(fn: (value: T, index: i32, array: Array<T>) => bool): i32 {\n    for (let i = 0, len = this.length_; i < min(len, this.length_); ++i) {\n      if (fn(load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this)) return i;\n    }\n    return -1;\n  }\n\n  findLastIndex(fn: (value: T, index: i32, array: Array<T>) => bool): i32 {\n    for (let i = this.length_ - 1; i >= 0; --i) {\n      if (fn(load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this)) return i;\n    }\n    return -1;\n  }\n\n  @operator(\"[]\") private __get(index: i32): T {\n    if (<u32>index >= <u32>this.length_) throw new RangeError(E_INDEXOUTOFRANGE);\n    let value = load<T>(this.dataStart + (<usize>index << alignof<T>()));\n    if (isReference<T>()) {\n      if (!isNullable<T>()) {\n        if (!changetype<usize>(value)) throw new Error(E_HOLEYARRAY);\n      }\n    }\n    return value;\n  }\n\n  @unsafe @operator(\"{}\") private __uget(index: i32): T {\n    return load<T>(this.dataStart + (<usize>index << alignof<T>()));\n  }\n\n  @operator(\"[]=\") private __set(index: i32, value: T): void {\n    if (<u32>index >= <u32>this.length_) {\n      if (index < 0) throw new RangeError(E_INDEXOUTOFRANGE);\n      ensureCapacity(changetype<usize>(this), index + 1, alignof<T>());\n      this.length_ = index + 1;\n    }\n    store<T>(this.dataStart + (<usize>index << alignof<T>()), value);\n    if (isManaged<T>()) {\n      __link(changetype<usize>(this), changetype<usize>(value), true);\n    }\n  }\n\n  at(index: i32): T {\n    let len = this.length_;\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    let value = load<T>(this.dataStart + (<usize>index << alignof<T>()));\n    if (isReference<T>()) {\n      if (!isNullable<T>()) {\n        if (!changetype<usize>(value)) throw new Error(E_HOLEYARRAY);\n      }\n    }\n    return value;\n  }\n\n  fill(value: T, start: i32 = 0, end: i32 = i32.MAX_VALUE): Array<T> {\n    if (isManaged<T>()) {\n      FILL<usize>(this.dataStart, this.length_, changetype<usize>(value), start, end);\n      __link(changetype<usize>(this), changetype<usize>(value), false);\n    } else {\n      FILL<T>(this.dataStart, this.length_, value, start, end);\n    }\n    return this;\n  }\n\n  includes(value: T, fromIndex: i32 = 0): bool {\n    if (isFloat<T>()) {\n      let len = this.length_;\n      if (len == 0 || fromIndex >= len) return false;\n      if (fromIndex < 0) fromIndex = max(len + fromIndex, 0);\n      let ptr = this.dataStart;\n      while (fromIndex < len) {\n        let elem = load<T>(ptr + (<usize>fromIndex << alignof<T>()));\n        // @ts-ignore\n        if (elem == value || isNaN(elem) & isNaN(value)) return true;\n        ++fromIndex;\n      }\n      return false;\n    } else {\n      return this.indexOf(value, fromIndex) >= 0;\n    }\n  }\n\n  indexOf(value: T, fromIndex: i32 = 0): i32 {\n    let len = this.length_;\n    if (len == 0 || fromIndex >= len) return -1;\n    if (fromIndex < 0) fromIndex = max(len + fromIndex, 0);\n    let ptr = this.dataStart;\n    while (fromIndex < len) {\n      if (load<T>(ptr + (<usize>fromIndex << alignof<T>())) == value) return fromIndex;\n      ++fromIndex;\n    }\n    return -1;\n  }\n\n  lastIndexOf(value: T, fromIndex: i32 = this.length_): i32 {\n    let len = this.length_;\n    if (len == 0) return -1;\n    if (fromIndex < 0) fromIndex = len + fromIndex;\n    else if (fromIndex >= len) fromIndex = len - 1;\n    let ptr = this.dataStart;\n    while (fromIndex >= 0) {\n      if (load<T>(ptr + (<usize>fromIndex << alignof<T>())) == value) return fromIndex;\n      --fromIndex;\n    }\n    return -1;\n  }\n\n  push(value: T): i32 {\n    let oldLen = this.length_;\n    let len = oldLen + 1;\n    ensureCapacity(changetype<usize>(this), len, alignof<T>());\n    if (isManaged<T>()) {\n      store<usize>(this.dataStart + (<usize>oldLen << alignof<T>()), changetype<usize>(value));\n      __link(changetype<usize>(this), changetype<usize>(value), true);\n    } else {\n      store<T>(this.dataStart + (<usize>oldLen << alignof<T>()), value);\n    }\n    this.length_ = len;\n    return len;\n  }\n\n  concat(other: Array<T>): Array<T> {\n    let thisLen = this.length_;\n    let otherLen = other.length_;\n    let outLen = thisLen + otherLen;\n    if (<u32>outLen > <u32>BLOCK_MAXSIZE >>> alignof<T>()) throw new Error(E_INVALIDLENGTH);\n    let out = changetype<Array<T>>(__newArray(outLen, alignof<T>(), idof<Array<T>>()));\n    let outStart = out.dataStart;\n    let thisSize = <usize>thisLen << alignof<T>();\n    if (isManaged<T>()) {\n      let thisStart = this.dataStart;\n      for (let offset: usize = 0; offset < thisSize; offset += sizeof<T>()) {\n        let ref = load<usize>(thisStart + offset);\n        store<usize>(outStart + offset, ref);\n        __link(changetype<usize>(out), ref, true);\n      }\n      outStart += thisSize;\n      let otherStart = other.dataStart;\n      let otherSize = <usize>otherLen << alignof<T>();\n      for (let offset: usize = 0; offset < otherSize; offset += sizeof<T>()) {\n        let ref = load<usize>(otherStart + offset);\n        store<usize>(outStart + offset, ref);\n        __link(changetype<usize>(out), ref, true);\n      }\n    } else {\n      memory.copy(outStart, this.dataStart, thisSize);\n      memory.copy(outStart + thisSize, other.dataStart, <usize>otherLen << alignof<T>());\n    }\n    return out;\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Array<T> {\n    let ptr = this.dataStart;\n    let len = this.length_;\n\n    end = min<i32>(end, len);\n\n    let to    = target < 0 ? max(len + target, 0) : min(target, len);\n    let from  = start < 0 ? max(len + start, 0) : min(start, len);\n    let last  = end < 0 ? max(len + end, 0) : min(end, len);\n    let count = min(last - from, len - to);\n\n    memory.copy( // is memmove\n      ptr + (<usize>to << alignof<T>()),\n      ptr + (<usize>from << alignof<T>()),\n      <usize>count << alignof<T>()\n    );\n    return this;\n  }\n\n  pop(): T {\n    let len = this.length_;\n    if (len < 1) throw new RangeError(E_EMPTYARRAY);\n    let val = load<T>(this.dataStart + (<usize>(--len) << alignof<T>()));\n    this.length_ = len;\n    return val;\n  }\n\n  forEach(fn: (value: T, index: i32, array: Array<T>) => void): void {\n    for (let i = 0, len = this.length_; i < min(len, this.length_); ++i) {\n      fn(load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this);\n    }\n  }\n\n  map<U>(fn: (value: T, index: i32, array: Array<T>) => U): Array<U> {\n    let len = this.length_;\n    let out = changetype<Array<U>>(__newArray(len, alignof<U>(), idof<Array<U>>()));\n    let outStart = out.dataStart;\n    for (let i = 0; i < min(len, this.length_); ++i) {\n      let result = fn(load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this);\n      store<U>(outStart + (<usize>i << alignof<U>()), result);\n      if (isManaged<U>()) {\n        __link(changetype<usize>(out), changetype<usize>(result), true);\n      }\n    }\n    return out;\n  }\n\n  filter(fn: (value: T, index: i32, array: Array<T>) => bool): Array<T> {\n    let result = changetype<Array<T>>(__newArray(0, alignof<T>(), idof<Array<T>>()));\n    for (let i = 0, len = this.length_; i < min(len, this.length_); ++i) {\n      let value = load<T>(this.dataStart + (<usize>i << alignof<T>()));\n      if (fn(value, i, this)) result.push(value);\n    }\n    return result;\n  }\n\n  reduce<U>(\n    fn: (previousValue: U, currentValue: T, currentIndex: i32, array: Array<T>) => U,\n    initialValue: U\n  ): U {\n    let acc = initialValue;\n    for (let i = 0, len = this.length_; i < min(len, this.length_); ++i) {\n      acc = fn(acc, load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this);\n    }\n    return acc;\n  }\n\n  reduceRight<U>(\n    fn: (previousValue: U, currentValue: T, currentIndex: i32, array: Array<T>) => U,\n    initialValue: U\n  ): U {\n    let acc = initialValue;\n    for (let i = this.length_ - 1; i >= 0; --i) {\n      acc = fn(acc, load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this);\n    }\n    return acc;\n  }\n\n  shift(): T {\n    let len = this.length_;\n    if (len < 1) throw new RangeError(E_EMPTYARRAY);\n    let base = this.dataStart;\n    let element = load<T>(base);\n    let lastIndex = len - 1;\n    memory.copy(\n      base,\n      base + sizeof<T>(),\n      <usize>lastIndex << alignof<T>()\n    );\n    if (isReference<T>()) {\n      store<usize>(base + (<usize>lastIndex << alignof<T>()), 0);\n    } else {\n      // @ts-ignore\n      store<T>(base + (<usize>lastIndex << alignof<T>()), <T>0);\n    }\n    this.length_ = lastIndex;\n    return element;\n  }\n\n  some(fn: (value: T, index: i32, array: Array<T>) => bool): bool {\n    for (let i = 0, len = this.length_; i < min(len, this.length_); ++i) {\n      if (fn(load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this)) return true;\n    }\n    return false;\n  }\n\n  unshift(value: T): i32 {\n    let len = this.length_ + 1;\n    ensureCapacity(changetype<usize>(this), len, alignof<T>());\n    let ptr = this.dataStart;\n    memory.copy(\n      ptr + sizeof<T>(),\n      ptr,\n      <usize>(len - 1) << alignof<T>()\n    );\n    store<T>(ptr, value);\n    if (isManaged<T>()) {\n      __link(changetype<usize>(this), changetype<usize>(value), true);\n    }\n    this.length_ = len;\n    return len;\n  }\n\n  slice(start: i32 = 0, end: i32 = i32.MAX_VALUE): Array<T> {\n    let len = this.length_;\n    start = start < 0 ? max(start + len, 0) : min(start, len);\n    end   = end   < 0 ? max(end   + len, 0) : min(end  , len);\n    len = max(end - start, 0);\n    let slice = changetype<Array<T>>(__newArray(len, alignof<T>(), idof<Array<T>>()));\n    let sliceBase = slice.dataStart;\n    let thisBase = this.dataStart + (<usize>start << alignof<T>());\n    if (isManaged<T>()) {\n      let off = <usize>0;\n      let end = <usize>len << alignof<usize>();\n      while (off < end) {\n        let ref = load<usize>(thisBase + off);\n        store<usize>(sliceBase + off, ref);\n        __link(changetype<usize>(slice), ref, true);\n        off += sizeof<usize>();\n      }\n    } else {\n      memory.copy(sliceBase, thisBase, len << alignof<T>());\n    }\n    return slice;\n  }\n\n  splice(start: i32, deleteCount: i32 = i32.MAX_VALUE): Array<T> {\n    let len = this.length_;\n    start       = start < 0 ? max<i32>(len + start, 0) : min<i32>(start, len);\n    deleteCount = max<i32>(min<i32>(deleteCount, len - start), 0);\n    let result  = changetype<Array<T>>(__newArray(deleteCount, alignof<T>(), idof<Array<T>>()));\n    let resultStart = result.dataStart;\n    let thisStart = this.dataStart;\n    let thisBase  = thisStart + (<usize>start << alignof<T>());\n    memory.copy(\n      resultStart,\n      thisBase,\n      <usize>deleteCount << alignof<T>()\n    );\n    let offset = start + deleteCount;\n    if (len != offset) {\n      memory.copy(\n        thisBase,\n        thisStart + (<usize>offset << alignof<T>()),\n        <usize>(len - offset) << alignof<T>()\n      );\n    }\n    this.length_ = len - deleteCount;\n    return result;\n  }\n\n  reverse(): Array<T> {\n    REVERSE<T>(this.dataStart, this.length_);\n    return this;\n  }\n\n  sort(comparator: (a: T, b: T) => i32 = COMPARATOR<T>()): Array<T> {\n    SORT<T>(this.dataStart, this.length_, comparator);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    let ptr = this.dataStart;\n    let len = this.length_;\n    if (isBoolean<T>())   return joinBooleanArray(ptr, len, separator);\n    if (isInteger<T>())   return joinIntegerArray<T>(ptr, len, separator);\n    if (isFloat<T>())     return joinFloatArray<T>(ptr, len, separator);\n\n    if (ASC_SHRINK_LEVEL < 1) {\n      if (isString<T>())  return joinStringArray(ptr, len, separator);\n    }\n    // For rest objects and arrays use general join routine\n    if (isReference<T>()) return joinReferenceArray<T>(ptr, len, separator);\n    ERROR(\"unspported element type\");\n    return <string>unreachable();\n  }\n\n  flat(): T {\n    if (!isArray<T>()) {\n      ERROR(\"Cannot call flat() on Array<T> where T is not an Array.\");\n    }\n    // Get the length and data start values\n    let ptr = this.dataStart;\n    let len = this.length_;\n\n    // calculate the end size with an initial pass\n    let size = 0;\n    for (let i = 0; i < len; ++i) {\n      let child = load<usize>(ptr + (i << alignof<T>()));\n      size += child == 0 ? 0 : load<i32>(child, offsetof<T>(\"length_\"));\n    }\n\n    // calculate the byteLength of the resulting backing ArrayBuffer\n    const align = alignof<valueof<T>>();\n    let byteLength = <usize>size << align;\n    let outBuffer = changetype<ArrayBuffer>(__new(byteLength, idof<ArrayBuffer>()));\n\n    // create the return value and initialize it\n    let outArray = changetype<T>(__new(offsetof<T>(), idof<T>()));\n    store<i32>(changetype<usize>(outArray), size, offsetof<T>(\"length_\"));\n\n    // byteLength, dataStart, and buffer are all readonly\n    store<i32>(changetype<usize>(outArray), byteLength, offsetof<T>(\"byteLength\"));\n    store<usize>(changetype<usize>(outArray), changetype<usize>(outBuffer), offsetof<T>(\"dataStart\"));\n    store<usize>(changetype<usize>(outArray), changetype<usize>(outBuffer), offsetof<T>(\"buffer\"));\n    __link(changetype<usize>(outArray), changetype<usize>(outBuffer), false);\n\n    // set the elements\n    let resultOffset: usize = 0;\n    for (let i = 0; i < len; ++i) { // for each child\n      let child = load<usize>(ptr + (<usize>i << alignof<T>()));\n\n      // ignore null arrays\n      if (!child) continue;\n\n      // copy the underlying buffer data to the result buffer\n      let childDataLength = <usize>load<i32>(child, offsetof<T>(\"length_\")) << align;\n      memory.copy(\n        changetype<usize>(outBuffer) + resultOffset,\n        load<usize>(child, offsetof<T>(\"dataStart\")),\n        childDataLength\n      );\n\n      // advance the result length\n      resultOffset += childDataLength;\n    }\n\n    // if the `valueof<T>` type is managed, we must link each reference\n    if (isManaged<valueof<T>>()) {\n      for (let i = 0; i < size; ++i) {\n        let ref = load<usize>(changetype<usize>(outBuffer) + (<usize>i << usize(alignof<valueof<T>>())));\n        __link(changetype<usize>(outBuffer), ref, true);\n      }\n    }\n\n    return outArray;\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  // RT integration\n\n  @unsafe private __visit(cookie: u32): void {\n    if (isManaged<T>()) {\n      let cur = this.dataStart;\n      let end = cur + (<usize>this.length_ << alignof<T>());\n      while (cur < end) {\n        let val = load<usize>(cur);\n        if (val) __visit(val, cookie);\n        cur += sizeof<usize>();\n      }\n    }\n    __visit(changetype<usize>(this.buffer), cookie);\n  }\n}\n","import { Buffer, Device, Float, RenderPass, RenderPipeline, Shader, ShaderStage, TextureFormat, VertexFormat, vertexBufferLayouts } from '../interop/mugl';\nimport { BaseExample, createBuffer, toVertices, Triangle } from '../common';\n\nconst code = `\nstruct VertexInput {\n  @location(0) position: vec3<f32>,\n  @location(1) color: vec4<f32>,\n};\n\nstruct VertexOutput {\n  @builtin(position) clip_position: vec4<f32>,\n  @location(0) color: vec4<f32>,\n};\n\n@vertex\nfn vs_main(\n  model: VertexInput,\n) -> VertexOutput {\n  var out: VertexOutput;\n  out.color = model.color;\n  out.clip_position = vec4<f32>(model.position, 1.0);\n  return out;\n}\n\n@fragment\nfn fs_main(in: VertexOutput) -> @location(0) vec4<f32> {\n  return in.color;\n}\n`;\n\nconst vert = `#version 300 es\nlayout (location=0) in vec3 position;\nlayout (location=1) in vec4 color;\nout vec4 vColor;\nvoid main () {\n  gl_Position = vec4(position, 1);\n  vColor = color;\n}\n`;\n\nconst frag = `#version 300 es\nprecision mediump float;\nin vec4 vColor;\nout vec4 outColor;\nvoid main () {\n  outColor = vColor;\n}\n`;\n\nconst position = toVertices(Triangle);\n\nexport class BasicExample extends BaseExample {\n  buffer: Buffer | null = null;\n  pipeline: RenderPipeline | null = null;\n  pass: RenderPass | null = null;\n\n  constructor(\n    private readonly device: Device,\n    useWebGPU: boolean\n  ) {\n    super(useWebGPU);\n  }\n\n  init(): void {\n    let vs: Shader, fs: Shader;\n    if (this.useWebGPU) {\n      vs = fs = this.gpu.createShader(this.device, { code, usage: ShaderStage.Vertex | ShaderStage.Fragment });\n    } else {\n      vs = this.gpu.createShader(this.device, { code: vert, usage: ShaderStage.Vertex });\n      fs = this.gpu.createShader(this.device, { code: frag, usage: ShaderStage.Fragment });\n    }\n\n    this.buffer = createBuffer(this.gpu, this.device, position);\n\n    this.pipeline = this.gpu.createRenderPipeline(this.device, {\n      vertex: vs,\n      fragment: fs,\n      buffers: vertexBufferLayouts([\n        // must match shader vertex inputs\n        { attributes: [/* position */ VertexFormat.F32x3, /* color */ VertexFormat.F32x4] }\n      ]),\n      depthStencil: {\n        // must match surface depth format\n        format: TextureFormat.Depth24Stencil8\n      },\n    });\n\n    this.pass = this.gpu.createRenderPass(this.device, { clearColor: [0.1, 0.2, 0.3, 1.0] });\n\n    this.register([this.buffer!, this.pipeline!, this.pass!, vs, fs]);\n  }\n\n  render(_: Float): boolean {\n    this.gpu.beginRenderPass(this.device, this.pass!);\n    this.gpu.setRenderPipeline(this.device, this.pipeline!);\n    this.gpu.setVertex(this.device, 0, this.buffer!);\n    this.gpu.draw(this.device, 3);\n    this.gpu.submitRenderPass(this.device);\n\n    return false;\n  }\n}\n","/// <reference path=\"./rt/index.d.ts\" />\n\nimport { OBJECT, BLOCK_MAXSIZE, TOTAL_OVERHEAD } from \"./rt/common\";\nimport { Runtime } from \"shared/runtime\";\nimport { idof } from \"./builtins\";\nimport { E_INVALIDLENGTH } from \"./util/error\";\n\nexport abstract class ArrayBufferView {\n\n  readonly buffer: ArrayBuffer;\n  @unsafe readonly dataStart: usize;\n  readonly byteLength: i32;\n\n  get byteOffset(): i32 {\n    return <i32>(this.dataStart - changetype<usize>(this.buffer));\n  }\n\n  protected constructor(length: i32, alignLog2: i32) {\n    if (<u32>length > <u32>BLOCK_MAXSIZE >>> alignLog2) throw new RangeError(E_INVALIDLENGTH);\n    let buffer = changetype<ArrayBuffer>(__new(length = length << alignLog2, idof<ArrayBuffer>()));\n    if (ASC_RUNTIME != Runtime.Incremental) {\n      memory.fill(changetype<usize>(buffer), 0, <usize>length);\n    }\n    this.buffer = buffer; // links\n    this.dataStart = changetype<usize>(buffer);\n    this.byteLength = length;\n  }\n}\n\n@final export class ArrayBuffer {\n\n  static isView<T>(value: T): bool {\n    if (isNullable<T>()) {\n      if (changetype<usize>(value) == 0) return false;\n    }\n    if (value instanceof Int8Array) return true;\n    if (value instanceof Uint8Array) return true;\n    if (value instanceof Uint8ClampedArray) return true;\n    if (value instanceof Int16Array) return true;\n    if (value instanceof Uint16Array) return true;\n    if (value instanceof Int32Array) return true;\n    if (value instanceof Uint32Array) return true;\n    if (value instanceof Int64Array) return true;\n    if (value instanceof Uint64Array) return true;\n    if (value instanceof Float32Array) return true;\n    if (value instanceof Float64Array) return true;\n    if (value instanceof DataView) return true;\n    return false;\n  }\n\n  constructor(length: i32) {\n    if (<u32>length > <u32>BLOCK_MAXSIZE) throw new RangeError(E_INVALIDLENGTH);\n    let buffer = changetype<ArrayBuffer>(__new(<usize>length, idof<ArrayBuffer>()));\n    if (ASC_RUNTIME != Runtime.Incremental) {\n      memory.fill(changetype<usize>(buffer), 0, <usize>length);\n    }\n    return buffer;\n  }\n\n  get byteLength(): i32 {\n    return changetype<OBJECT>(changetype<usize>(this) - TOTAL_OVERHEAD).rtSize;\n  }\n\n  slice(begin: i32 = 0, end: i32 = BLOCK_MAXSIZE): ArrayBuffer {\n    let length = this.byteLength;\n    begin = begin < 0 ? max(length + begin, 0) : min(begin, length);\n    end   = end   < 0 ? max(length + end  , 0) : min(end  , length);\n    let outSize = <usize>max(end - begin, 0);\n    let out = changetype<ArrayBuffer>(__new(outSize, idof<ArrayBuffer>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this) + <usize>begin, outSize);\n    return out;\n  }\n\n  toString(): string {\n    return \"[object ArrayBuffer]\";\n  }\n}\n","import { COMPARATOR, SORT } from \"./util/sort\";\nimport { E_INDEXOUTOFRANGE, E_INVALIDLENGTH, E_NOTIMPLEMENTED } from \"./util/error\";\nimport { joinIntegerArray, joinFloatArray } from \"./util/string\";\nimport { REVERSE, FILL } from \"./util/bytes\";\nimport { idof } from \"./builtins\";\nimport { ArrayBufferView } from \"./arraybuffer\";\n\nexport class Int8Array extends ArrayBufferView {\n  [key: number]: i8;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<i8>();\n\n  constructor(length: i32) {\n    super(length, alignof<i8>());\n  }\n\n  get length(): i32 {\n    return this.byteLength;\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): i8 {\n    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i8>(this.dataStart + <usize>index);\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): i8 {\n    return load<i8>(this.dataStart + <usize>index);\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: native<i8>): void {\n    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<i8>(this.dataStart + <usize>index, value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: native<i8>): void {\n    store<i8>(this.dataStart + <usize>index, value);\n  }\n\n  at(index: i32): i8 {\n    let len = this.byteLength;\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i8>(this.dataStart + <usize>index);\n  }\n\n  includes(searchElement: i8, fromIndex: i32 = 0): bool {\n    return INCLUDES<Int8Array, i8>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: i8, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Int8Array, i8>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: i8, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Int8Array, i8>(this, searchElement, fromIndex);\n  }\n\n  fill(value: i32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Int8Array {\n    FILL<u8>(this.dataStart, this.length, u8(value), start, end);\n    return this;\n  }\n\n  sort(comparator: (a: i8, b: i8) => i32 = COMPARATOR<i8>()): Int8Array {\n    SORT<i8>(this.dataStart, this.length, comparator);\n    return this;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int8Array {\n    return SLICE<Int8Array, i8>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int8Array {\n    return SUBARRAY<Int8Array, i8>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Int8Array {\n    return COPY_WITHIN<Int8Array, i8>(this, target, start, end);\n  }\n\n  reduce<T extends number>(\n    fn: (accumulator: T, value: i8, index: i32, array: Int8Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Int8Array, i8, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T extends number>(\n    fn: (accumulator: T, value: i8, index: i32, array: Int8Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Int8Array, i8, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: i8, index: i32, self: Int8Array) => i8): Int8Array {\n    return MAP<Int8Array, i8>(this, fn);\n  }\n\n  filter(fn: (value: i8, index: i32, self: Int8Array) => bool): Int8Array {\n    return FILTER<Int8Array, i8>(this, fn);\n  }\n\n  findIndex(fn: (value: i8, index: i32, self: Int8Array) => bool): i32 {\n    return FIND_INDEX<Int8Array, i8>(this, fn);\n  }\n\n  findLastIndex(fn: (value: i8, index: i32, self: Int8Array) => bool): i32 {\n    return FIND_LAST_INDEX<Int8Array, i8>(this, fn);\n  }\n\n  some(fn: (value: i8, index: i32, self: Int8Array) => bool): bool {\n    return SOME<Int8Array, i8>(this, fn);\n  }\n\n  every(fn: (value: i8, index: i32, self: Int8Array) => bool): bool {\n    return EVERY<Int8Array, i8>(this, fn);\n  }\n\n  forEach(fn: (value: i8, index: i32, self: Int8Array) => void): void {\n    FOREACH<Int8Array, i8>(this, fn);\n  }\n\n  reverse(): Int8Array {\n    REVERSE<u8>(this.dataStart, this.length);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<i8>(this.dataStart, this.length, separator);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  set<U extends ArrayLike<number>>(source: U, offset: i32 = 0): void {\n    SET(this, source, offset);\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Int8Array {\n    return WRAP<Int8Array, i8>(buffer, byteOffset, length);\n  }\n}\n\nexport class Uint8Array extends ArrayBufferView {\n  [key: number]: u8;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<u8>();\n\n  constructor(length: i32) {\n    super(length, alignof<u8>());\n  }\n\n  get length(): i32 {\n    return this.byteLength;\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): u8 {\n    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u8>(this.dataStart + <usize>index);\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): u8 {\n    return load<u8>(this.dataStart + <usize>index);\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: native<u8>): void {\n    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<u8>(this.dataStart + <usize>index, value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: native<u8>): void {\n    store<u8>(this.dataStart + <usize>index, value);\n  }\n\n  at(index: i32): u8 {\n    let len = this.byteLength;\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u8>(this.dataStart + <usize>index);\n  }\n\n  includes(searchElement: u8, fromIndex: i32 = 0): bool {\n    return INCLUDES<Uint8Array, u8>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: u8, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Uint8Array, u8>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: u8, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Uint8Array, u8>(this, searchElement, fromIndex);\n  }\n\n  fill(value: u32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8Array {\n    FILL<u8>(this.dataStart, this.length, u8(value), start, end);\n    return this;\n  }\n\n  sort(comparator: (a: u8, b: u8) => i32 = COMPARATOR<u8>()): Uint8Array {\n    SORT<u8>(this.dataStart, this.length, comparator);\n    return this;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8Array {\n    return SLICE<Uint8Array, u8>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8Array {\n    return SUBARRAY<Uint8Array, u8>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Uint8Array {\n    return COPY_WITHIN<Uint8Array, u8>(this, target, start, end);\n  }\n\n  reduce<T extends number>(\n    fn: (accumulator: T, value: u8, index: i32, array: Uint8Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Uint8Array, u8, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T extends number>(\n    fn: (accumulator: T, value: u8, index: i32, array: Uint8Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Uint8Array, u8, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: u8, index: i32, self: Uint8Array) => u8): Uint8Array {\n    return MAP<Uint8Array, u8>(this, fn);\n  }\n\n  filter(fn: (value: u8, index: i32, self: Uint8Array) => bool): Uint8Array {\n    return FILTER<Uint8Array, u8>(this, fn);\n  }\n\n  findIndex(fn: (value: u8, index: i32, self: Uint8Array) => bool): i32 {\n    return FIND_INDEX<Uint8Array, u8>(this, fn);\n  }\n\n  findLastIndex(fn: (value: u8, index: i32, self: Uint8Array) => bool): i32 {\n    return FIND_LAST_INDEX<Uint8Array, u8>(this, fn);\n  }\n\n  some(fn: (value: u8, index: i32, self: Uint8Array) => bool): bool {\n    return SOME<Uint8Array, u8>(this, fn);\n  }\n\n  every(fn: (value: u8, index: i32, self: Uint8Array) => bool): bool {\n    return EVERY<Uint8Array, u8>(this, fn);\n  }\n\n  forEach(fn: (value: u8, index: i32, self: Uint8Array) => void): void {\n    FOREACH<Uint8Array, u8>(this, fn);\n  }\n\n  reverse(): Uint8Array {\n    REVERSE<u8>(this.dataStart, this.length);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<u8>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayLike<number>>(source: U, offset: i32 = 0): void {\n    SET(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Uint8Array {\n    return WRAP<Uint8Array, u8>(buffer, byteOffset, length);\n  }\n}\n\nexport class Uint8ClampedArray extends ArrayBufferView {\n  [key: number]: u8;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<u8>();\n\n  constructor(length: i32) {\n    super(length, alignof<u8>());\n  }\n\n  get length(): i32 {\n    return this.byteLength;\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): u8 {\n    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u8>(this.dataStart + <usize>index);\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): u8 {\n    return load<u8>(this.dataStart + <usize>index);\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: native<u8>): void {\n    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<u8>(this.dataStart + <usize>index, ~(<i32>value >> 31) & (((255 - value) >> 31) | value));\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: native<u8>): void {\n    store<u8>(this.dataStart + <usize>index, ~(<i32>value >> 31) & (((255 - value) >> 31) | value));\n  }\n\n  at(index: i32): u8 {\n    let len = this.byteLength;\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u8>(this.dataStart + <usize>index);\n  }\n\n  includes(searchElement: u8, fromIndex: i32 = 0): bool {\n    return INCLUDES<Uint8ClampedArray, u8>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: u8, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Uint8ClampedArray, u8>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: u8, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Uint8ClampedArray, u8>(this, searchElement, fromIndex);\n  }\n\n  fill(value: i32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8ClampedArray {\n    value = ~(value >> 31) & (((255 - value) >> 31) | value);\n    FILL<u8>(this.dataStart, this.length, u8(value), start, end);\n    return this;\n  }\n\n  sort(comparator: (a: u8, b: u8) => i32 = COMPARATOR<u8>()): Uint8ClampedArray {\n    SORT<u8>(this.dataStart, this.length, comparator);\n    return this;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8ClampedArray {\n    return SLICE<Uint8ClampedArray, u8>(this, begin, end);\n  }\n\n  subarray(start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8ClampedArray {\n    return SUBARRAY<Uint8ClampedArray, u8>(this, start, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Uint8ClampedArray {\n    return COPY_WITHIN<Uint8ClampedArray, u8>(this, target, start, end);\n  }\n\n  reduce<T extends number>(\n    fn: (accumulator: T, value: u8, index: i32, array: Uint8ClampedArray) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Uint8ClampedArray, u8, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T extends number>(\n    fn: (accumulator: T, value: u8, index: i32, array: Uint8ClampedArray) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Uint8ClampedArray, u8, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: u8, index: i32, self: Uint8ClampedArray) => u8): Uint8ClampedArray {\n    return MAP<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  filter(fn: (value: u8, index: i32, self: Uint8ClampedArray) => bool): Uint8ClampedArray {\n    return FILTER<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  findIndex(fn: (value: u8, index: i32, self: Uint8ClampedArray) => bool): i32 {\n    return FIND_INDEX<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  findLastIndex(fn: (value: u8, index: i32, self: Uint8ClampedArray) => bool): i32 {\n    return FIND_LAST_INDEX<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  some(fn: (value: u8, index: i32, self: Uint8ClampedArray) => bool): bool {\n    return SOME<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  every(fn: (value: u8, index: i32, self: Uint8ClampedArray) => bool): bool {\n    return EVERY<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  forEach(fn: (value: u8, index: i32, self: Uint8ClampedArray) => void): void {\n    FOREACH<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  reverse(): Uint8ClampedArray {\n    REVERSE<u8>(this.dataStart, this.length);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<u8>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayLike<number>>(source: U, offset: i32 = 0): void {\n    SET(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Uint8ClampedArray {\n    return WRAP<Uint8ClampedArray, u8>(buffer, byteOffset, length);\n  }\n}\n\nexport class Int16Array extends ArrayBufferView {\n  [key: number]: i16;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<i16>();\n\n  constructor(length: i32) {\n    super(length, alignof<i16>());\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<i16>();\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): i16 {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<i16>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i16>(this.dataStart + (<usize>index << alignof<i16>()));\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): i16 {\n    return load<i16>(this.dataStart + (<usize>index << alignof<i16>()));\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: native<i16>): void {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<i16>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<i16>(this.dataStart + (<usize>index << alignof<i16>()), value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: native<i16>): void {\n    store<i16>(this.dataStart + (<usize>index << alignof<i16>()), value);\n  }\n\n  at(index: i32): i16 {\n    let len = this.byteLength >>> alignof<i16>();\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i16>(this.dataStart + (<usize>index << alignof<i16>()));\n  }\n\n  includes(searchElement: i16, fromIndex: i32 = 0): bool {\n    return INCLUDES<Int16Array, i16>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: i16, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Int16Array, i16>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: i16, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Int16Array, i16>(this, searchElement, fromIndex);\n  }\n\n  fill(value: i32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Int16Array {\n    FILL<u16>(this.dataStart, this.length, u16(value), start, end);\n    return this;\n  }\n\n  sort(comparator: (a: i16, b: i16) => i32 = COMPARATOR<i16>()): Int16Array {\n    SORT<i16>(this.dataStart, this.length, comparator);\n    return this;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int16Array {\n    return SLICE<Int16Array, i16>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int16Array {\n    return SUBARRAY<Int16Array, i16>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Int16Array {\n    return COPY_WITHIN<Int16Array, i16>(this, target, start, end);\n  }\n\n  reduce<T extends number>(\n    fn: (accumulator: T, value: i16, index: i32, array: Int16Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Int16Array, i16, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T extends number>(\n    fn: (accumulator: T, value: i16, index: i32, array: Int16Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Int16Array, i16, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: i16, index: i32, self: Int16Array) => i16): Int16Array {\n    return MAP<Int16Array, i16>(this, fn);\n  }\n\n  filter(fn: (value: i16, index: i32, self: Int16Array) => bool): Int16Array {\n    return FILTER<Int16Array, i16>(this, fn);\n  }\n\n  findIndex(fn: (value: i16, index: i32, self: Int16Array) => bool): i32 {\n    return FIND_INDEX<Int16Array, i16>(this, fn);\n  }\n\n  findLastIndex(fn: (value: i16, index: i32, self: Int16Array) => bool): i32 {\n    return FIND_LAST_INDEX<Int16Array, i16>(this, fn);\n  }\n\n  some(fn: (value: i16, index: i32, self: Int16Array) => bool): bool {\n    return SOME<Int16Array, i16>(this, fn);\n  }\n\n  every(fn: (value: i16, index: i32, self: Int16Array) => bool): bool {\n    return EVERY<Int16Array, i16>(this, fn);\n  }\n\n  forEach(fn: (value: i16, index: i32, self: Int16Array) => void): void {\n    FOREACH<Int16Array, i16>(this, fn);\n  }\n\n  reverse(): Int16Array {\n    REVERSE<u16>(this.dataStart, this.length);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<i16>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayLike<number>>(source: U, offset: i32 = 0): void {\n    SET(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Int16Array {\n    return WRAP<Int16Array, i16>(buffer, byteOffset, length);\n  }\n}\n\nexport class Uint16Array extends ArrayBufferView {\n  [key: number]: u16;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<u16>();\n\n  constructor(length: i32) {\n    super(length, alignof<u16>());\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<u16>();\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): u16 {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<u16>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u16>(this.dataStart + (<usize>index << alignof<u16>()));\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): u16 {\n    return load<u16>(this.dataStart + (<usize>index << alignof<u16>()));\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: native<u16>): void {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<u16>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<u16>(this.dataStart + (<usize>index << alignof<u16>()), value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: native<u16>): void {\n    store<u16>(this.dataStart + (<usize>index << alignof<u16>()), value);\n  }\n\n  at(index: i32): u16 {\n    let len = this.byteLength >>> alignof<u16>();\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u16>(this.dataStart + (<usize>index << alignof<u16>()));\n  }\n\n  includes(searchElement: u16, fromIndex: i32 = 0): bool {\n    return INCLUDES<Uint16Array, u16>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: u16, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Uint16Array, u16>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: u16, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Uint16Array, u16>(this, searchElement, fromIndex);\n  }\n\n  fill(value: u32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint16Array {\n    FILL<u16>(this.dataStart, this.length, u16(value), start, end);\n    return this;\n  }\n\n  sort(comparator: (a: u16, b: u16) => i32 = COMPARATOR<u16>()): Uint16Array {\n    SORT<u16>(this.dataStart, this.length, comparator);\n    return this;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint16Array {\n    return SLICE<Uint16Array, u16>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint16Array {\n    return SUBARRAY<Uint16Array, u16>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Uint16Array {\n    return COPY_WITHIN<Uint16Array, u16>(this, target, start, end);\n  }\n\n  reduce<T extends number>(\n    fn: (accumulator: T, value: u16, index: i32, array: Uint16Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Uint16Array, u16, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T extends number>(\n    fn: (accumulator: T, value: u16, index: i32, array: Uint16Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Uint16Array, u16, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: u16, index: i32, self: Uint16Array) => u16): Uint16Array {\n    return MAP<Uint16Array, u16>(this, fn);\n  }\n\n  filter(fn: (value: u16, index: i32, self: Uint16Array) => bool): Uint16Array {\n    return FILTER<Uint16Array, u16>(this, fn);\n  }\n\n  findIndex(fn: (value: u16, index: i32, self: Uint16Array) => bool): i32 {\n    return FIND_INDEX<Uint16Array, u16>(this, fn);\n  }\n\n  findLastIndex(fn: (value: u16, index: i32, self: Uint16Array) => bool): i32 {\n    return FIND_LAST_INDEX<Uint16Array, u16>(this, fn);\n  }\n\n  some(fn: (value: u16, index: i32, self: Uint16Array) => bool): bool {\n    return SOME<Uint16Array, u16>(this, fn);\n  }\n\n  every(fn: (value: u16, index: i32, self: Uint16Array) => bool): bool {\n    return EVERY<Uint16Array, u16>(this, fn);\n  }\n\n  forEach(fn: (value: u16, index: i32, self: Uint16Array) => void): void {\n    FOREACH<Uint16Array, u16>(this, fn);\n  }\n\n  reverse(): Uint16Array {\n    REVERSE<u16>(this.dataStart, this.length);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<u16>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayLike<number>>(source: U, offset: i32 = 0): void {\n    SET(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Uint16Array {\n    return WRAP<Uint16Array, u16>(buffer, byteOffset, length);\n  }\n}\n\nexport class Int32Array extends ArrayBufferView {\n  [key: number]: i32;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<i32>();\n\n  constructor(length: i32) {\n    super(length, alignof<i32>());\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<i32>();\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): i32 {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<i32>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i32>(this.dataStart + (<usize>index << alignof<i32>()));\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): i32 {\n    return load<i32>(this.dataStart + (<usize>index << alignof<i32>()));\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: i32): void {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<i32>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<i32>(this.dataStart + (<usize>index << alignof<i32>()), value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: i32): void {\n    store<i32>(this.dataStart + (<usize>index << alignof<i32>()), value);\n  }\n\n  at(index: i32): i32 {\n    let len = this.byteLength >>> alignof<i32>();\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i32>(this.dataStart + (<usize>index << alignof<i32>()));\n  }\n\n  includes(searchElement: i32, fromIndex: i32 = 0): bool {\n    return INCLUDES<Int32Array, i32>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: i32, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Int32Array, i32>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: i32, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Int32Array, i32>(this, searchElement, fromIndex);\n  }\n\n  fill(value: i32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Int32Array {\n    FILL<u32>(this.dataStart, this.length, u32(value), start, end);\n    return this;\n  }\n\n  sort(comparator: (a: i32, b: i32) => i32 = COMPARATOR<i32>()): Int32Array {\n    SORT<i32>(this.dataStart, this.length, comparator);\n    return this;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int32Array {\n    return SLICE<Int32Array, i32>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int32Array {\n    return SUBARRAY<Int32Array, i32>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Int32Array {\n    return COPY_WITHIN<Int32Array, i32>(this, target, start, end);\n  }\n\n  reduce<T extends number>(\n    fn: (accumulator: T, value: i32, index: i32, array: Int32Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Int32Array, i32, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T extends number>(\n    fn: (accumulator: T, value: i32, index: i32, array: Int32Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Int32Array, i32, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: i32, index: i32, self: Int32Array) => i32): Int32Array {\n    return MAP<Int32Array, i32>(this, fn);\n  }\n\n  filter(fn: (value: i32, index: i32, self: Int32Array) => bool): Int32Array {\n    return FILTER<Int32Array, i32>(this, fn);\n  }\n\n  findIndex(fn: (value: i32, index: i32, self: Int32Array) => bool): i32 {\n    return FIND_INDEX<Int32Array, i32>(this, fn);\n  }\n\n  findLastIndex(fn: (value: i32, index: i32, self: Int32Array) => bool): i32 {\n    return FIND_LAST_INDEX<Int32Array, i32>(this, fn);\n  }\n\n  some(fn: (value: i32, index: i32, self: Int32Array) => bool): bool {\n    return SOME<Int32Array, i32>(this, fn);\n  }\n\n  every(fn: (value: i32, index: i32, self: Int32Array) => bool): bool {\n    return EVERY<Int32Array, i32>(this, fn);\n  }\n\n  forEach(fn: (value: i32, index: i32, self: Int32Array) => void): void {\n    FOREACH<Int32Array, i32>(this, fn);\n  }\n\n  reverse(): Int32Array {\n    REVERSE<u32>(this.dataStart, this.length);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<i32>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayLike<number>>(source: U, offset: i32 = 0): void {\n    SET(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Int32Array {\n    return WRAP<Int32Array, i32>(buffer, byteOffset, length);\n  }\n}\n\nexport class Uint32Array extends ArrayBufferView {\n  [key: number]: u32;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<u32>();\n\n  constructor(length: i32) {\n    super(length, alignof<u32>());\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<u32>();\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): u32 {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<u32>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u32>(this.dataStart + (<usize>index << alignof<u32>()));\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): u32 {\n    return load<u32>(this.dataStart + (<usize>index << alignof<u32>()));\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: u32): void {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<u32>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<u32>(this.dataStart + (<usize>index << alignof<u32>()), value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: u32): void {\n    store<u32>(this.dataStart + (<usize>index << alignof<u32>()), value);\n  }\n\n  at(index: i32): u32 {\n    let len = this.byteLength >>> alignof<u32>();\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u32>(this.dataStart + (<usize>index << alignof<u32>()));\n  }\n\n  includes(searchElement: u32, fromIndex: i32 = 0): bool {\n    return INCLUDES<Uint32Array, u32>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: u32, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Uint32Array, u32>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: u32, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Uint32Array, u32>(this, searchElement, fromIndex);\n  }\n\n  fill(value: u32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint32Array {\n    FILL<u32>(this.dataStart, this.length, value, start, end);\n    return this;\n  }\n\n  sort(comparator: (a: u32, b: u32) => i32 = COMPARATOR<u32>()): Uint32Array {\n    SORT<u32>(this.dataStart, this.length, comparator);\n    return this;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint32Array {\n    return SLICE<Uint32Array, u32>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint32Array {\n    return SUBARRAY<Uint32Array, u32>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Uint32Array {\n    return COPY_WITHIN<Uint32Array, u32>(this, target, start, end);\n  }\n\n  reduce<T extends number>(\n    fn: (accumulator: T, value: u32, index: i32, array: Uint32Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Uint32Array, u32, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T extends number>(\n    fn: (accumulator: T, value: u32, index: i32, array: Uint32Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Uint32Array, u32, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: u32, index: i32, self: Uint32Array) => u32): Uint32Array {\n    return MAP<Uint32Array, u32>(this, fn);\n  }\n\n  filter(fn: (value: u32, index: i32, self: Uint32Array) => bool): Uint32Array {\n    return FILTER<Uint32Array, u32>(this, fn);\n  }\n\n  findIndex(fn: (value: u32, index: i32, self: Uint32Array) => bool): i32 {\n    return FIND_INDEX<Uint32Array, u32>(this, fn);\n  }\n\n  findLastIndex(fn: (value: u32, index: i32, self: Uint32Array) => bool): i32 {\n    return FIND_LAST_INDEX<Uint32Array, u32>(this, fn);\n  }\n\n  some(fn: (value: u32, index: i32, self: Uint32Array) => bool): bool {\n    return SOME<Uint32Array, u32>(this, fn);\n  }\n\n  every(fn: (value: u32, index: i32, self: Uint32Array) => bool): bool {\n    return EVERY<Uint32Array, u32>(this, fn);\n  }\n\n  forEach(fn: (value: u32, index: i32, self: Uint32Array) => void): void {\n    FOREACH<Uint32Array, u32>(this, fn);\n  }\n\n  reverse(): Uint32Array {\n    REVERSE<u32>(this.dataStart, this.length);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<u32>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayLike<number>>(source: U, offset: i32 = 0): void {\n    SET(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Uint32Array {\n    return WRAP<Uint32Array, u32>(buffer, byteOffset, length);\n  }\n}\n\nexport class Int64Array extends ArrayBufferView {\n  [key: number]: i64;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<i64>();\n\n  constructor(length: i32) {\n    super(length, alignof<i64>());\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<i64>();\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): i64 {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<i64>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i64>(this.dataStart + (<usize>index << alignof<i64>()));\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): i64 {\n    return load<i64>(this.dataStart + (<usize>index << alignof<i64>()));\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: i64): void {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<i64>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<i64>(this.dataStart + (<usize>index << alignof<i64>()), value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: i64): void {\n    store<i64>(this.dataStart + (<usize>index << alignof<i64>()), value);\n  }\n\n  at(index: i32): i64 {\n    let len = this.byteLength >>> alignof<i64>();\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i64>(this.dataStart + (<usize>index << alignof<i64>()));\n  }\n\n  includes(searchElement: i64, fromIndex: i32 = 0): bool {\n    return INCLUDES<Int64Array, i64>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: i64, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Int64Array, i64>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: i64, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Int64Array, i64>(this, searchElement, fromIndex);\n  }\n\n  fill(value: i64, start: i32 = 0, end: i32 = i32.MAX_VALUE): Int64Array {\n    FILL<u64>(this.dataStart, this.length, u64(value), start, end);\n    return this;\n  }\n\n  sort(comparator: (a: i64, b: i64) => i32 = COMPARATOR<i64>()): Int64Array {\n    SORT<i64>(this.dataStart, this.length, comparator);\n    return this;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int64Array {\n    return SLICE<Int64Array, i64>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int64Array {\n    return SUBARRAY<Int64Array, i64>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Int64Array {\n    return COPY_WITHIN<Int64Array, i64>(this, target, start, end);\n  }\n\n  reduce<T extends number>(\n    fn: (accumulator: T, value: i64, index: i32, array: Int64Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Int64Array, i64, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T extends number>(\n    fn: (accumulator: T, value: i64, index: i32, array: Int64Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Int64Array, i64, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: i64, index: i32, self: Int64Array) => i64): Int64Array {\n    return MAP<Int64Array, i64>(this, fn);\n  }\n\n  filter(fn: (value: i64, index: i32, self: Int64Array) => bool): Int64Array {\n    return FILTER<Int64Array, i64>(this, fn);\n  }\n\n  findIndex(fn: (value: i64, index: i32, self: Int64Array) => bool): i32 {\n    return FIND_INDEX<Int64Array, i64>(this, fn);\n  }\n\n  findLastIndex(fn: (value: i64, index: i32, self: Int64Array) => bool): i32 {\n    return FIND_LAST_INDEX<Int64Array, i64>(this, fn);\n  }\n\n  some(fn: (value: i64, index: i32, self: Int64Array) => bool): bool {\n    return SOME<Int64Array, i64>(this, fn);\n  }\n\n  every(fn: (value: i64, index: i32, self: Int64Array) => bool): bool {\n    return EVERY<Int64Array, i64>(this, fn);\n  }\n\n  forEach(fn: (value: i64, index: i32, self: Int64Array) => void): void {\n    FOREACH<Int64Array, i64>(this, fn);\n  }\n\n  reverse(): Int64Array {\n    REVERSE<u64>(this.dataStart, this.length);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<i64>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayLike<number>>(source: U, offset: i32 = 0): void {\n    SET(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Int64Array {\n    return WRAP<Int64Array, i64>(buffer, byteOffset, length);\n  }\n}\n\nexport class Uint64Array extends ArrayBufferView {\n  [key: number]: u64;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<u64>();\n\n  constructor(length: i32) {\n    super(length, alignof<u64>());\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<u64>();\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): u64 {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<u64>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u64>(this.dataStart + (<usize>index << alignof<u64>()));\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): u64 {\n    return load<u64>(this.dataStart + (<usize>index << alignof<u64>()));\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: u64): void {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<u64>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<u64>(this.dataStart + (<usize>index << alignof<u64>()), value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: u64): void {\n    store<u64>(this.dataStart + (<usize>index << alignof<u64>()), value);\n  }\n\n  at(index: i32): u64 {\n    let len = this.byteLength >>> alignof<u64>();\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u64>(this.dataStart + (<usize>index << alignof<u64>()));\n  }\n\n  includes(searchElement: u64, fromIndex: i32 = 0): bool {\n    return INCLUDES<Uint64Array, u64>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: u64, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Uint64Array, u64>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: u64, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Uint64Array, u64>(this, searchElement, fromIndex);\n  }\n\n  fill(value: u64, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint64Array {\n    FILL<u64>(this.dataStart, this.length, value, start, end);\n    return this;\n  }\n\n  sort(comparator: (a: u64, b: u64) => i32 = COMPARATOR<u64>()): Uint64Array {\n    SORT<u64>(this.dataStart, this.length, comparator);\n    return this;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint64Array {\n    return SLICE<Uint64Array, u64>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint64Array {\n    return SUBARRAY<Uint64Array, u64>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Uint64Array {\n    return COPY_WITHIN<Uint64Array, u64>(this, target, start, end);\n  }\n\n  reduce<T extends number>(\n    fn: (accumulator: T, value: u64, index: i32, array: Uint64Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Uint64Array, u64, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T extends number>(\n    fn: (accumulator: T, value: u64, index: i32, array: Uint64Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Uint64Array, u64, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: u64, index: i32, self: Uint64Array) => u64): Uint64Array {\n    return MAP<Uint64Array, u64>(this, fn);\n  }\n\n  filter(fn: (value: u64, index: i32, self: Uint64Array) => bool): Uint64Array {\n    return FILTER<Uint64Array, u64>(this, fn);\n  }\n\n  findIndex(fn: (value: u64, index: i32, self: Uint64Array) => bool): i32 {\n    return FIND_INDEX<Uint64Array, u64>(this, fn);\n  }\n\n  findLastIndex(fn: (value: u64, index: i32, self: Uint64Array) => bool): i32 {\n    return FIND_LAST_INDEX<Uint64Array, u64>(this, fn);\n  }\n\n  some(fn: (value: u64, index: i32, self: Uint64Array) => bool): bool {\n    return SOME<Uint64Array, u64>(this, fn);\n  }\n\n  every(fn: (value: u64, index: i32, self: Uint64Array) => bool): bool {\n    return EVERY<Uint64Array, u64>(this, fn);\n  }\n\n  forEach(fn: (value: u64, index: i32, self: Uint64Array) => void): void {\n    FOREACH<Uint64Array, u64>(this, fn);\n  }\n\n  reverse(): Uint64Array {\n    REVERSE<u64>(this.dataStart, this.length);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<u64>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayLike<number>>(source: U, offset: i32 = 0): void {\n    SET(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Uint64Array {\n    return WRAP<Uint64Array, u64>(buffer, byteOffset, length);\n  }\n}\n\nexport class Float32Array extends ArrayBufferView {\n  [key: number]: f32;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<f32>();\n\n  constructor(length: i32) {\n    super(length, alignof<f32>());\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<f32>();\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): f32 {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<f32>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<f32>(this.dataStart + (<usize>index << alignof<f32>()));\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): f32 {\n    return load<f32>(this.dataStart + (<usize>index << alignof<f32>()));\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: f32): void {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<f32>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<f32>(this.dataStart + (<usize>index << alignof<f32>()), value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: f32): void {\n    store<f32>(this.dataStart + (<usize>index << alignof<f32>()), value);\n  }\n\n  at(index: i32): f32 {\n    let len = this.byteLength >>> alignof<f32>();\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<f32>(this.dataStart + (<usize>index << alignof<f32>()));\n  }\n\n  includes(searchElement: f32, fromIndex: i32 = 0): bool {\n    return INCLUDES<Float32Array, f32>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: f32, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Float32Array, f32>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: f32, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Float32Array, f32>(this, searchElement, fromIndex);\n  }\n\n  fill(value: f32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Float32Array {\n    FILL<f32>(this.dataStart, this.length, value, start, end);\n    return this;\n  }\n\n  sort(comparator: (a: f32, b: f32) => i32 = COMPARATOR<f32>()): Float32Array {\n    SORT<f32>(this.dataStart, this.length, comparator);\n    return this;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Float32Array {\n    return SLICE<Float32Array, f32>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Float32Array {\n    return SUBARRAY<Float32Array, f32>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Float32Array {\n    return COPY_WITHIN<Float32Array, f32>(this, target, start, end);\n  }\n\n  reduce<T extends number>(\n    fn: (accumulator: T, value: f32, index: i32, array: Float32Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Float32Array, f32, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T extends number>(\n    fn: (accumulator: T, value: f32, index: i32, array: Float32Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Float32Array, f32, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: f32, index: i32, self: Float32Array) => f32): Float32Array {\n    return MAP<Float32Array, f32>(this, fn);\n  }\n\n  filter(fn: (value: f32, index: i32, self: Float32Array) => bool): Float32Array {\n    return FILTER<Float32Array, f32>(this, fn);\n  }\n\n  findIndex(fn: (value: f32, index: i32, self: Float32Array) => bool): i32 {\n    return FIND_INDEX<Float32Array, f32>(this, fn);\n  }\n\n  findLastIndex(fn: (value: f32, index: i32, self: Float32Array) => bool): i32 {\n    return FIND_LAST_INDEX<Float32Array, f32>(this, fn);\n  }\n\n  some(fn: (value: f32, index: i32, self: Float32Array) => bool): bool {\n    return SOME<Float32Array, f32>(this, fn);\n  }\n\n  every(fn: (value: f32, index: i32, self: Float32Array) => bool): bool {\n    return EVERY<Float32Array, f32>(this, fn);\n  }\n\n  forEach(fn: (value: f32, index: i32, self: Float32Array) => void): void {\n    FOREACH<Float32Array, f32>(this, fn);\n  }\n\n  reverse(): Float32Array {\n    REVERSE<f32>(this.dataStart, this.length);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    return joinFloatArray<f32>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayLike<number>>(source: U, offset: i32 = 0): void {\n    SET(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Float32Array {\n    return WRAP<Float32Array, f32>(buffer, byteOffset, length);\n  }\n}\n\nexport class Float64Array extends ArrayBufferView {\n  [key: number]: f64;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<f64>();\n\n  constructor(length: i32) {\n    super(length, alignof<f64>());\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<f64>();\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): f64 {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<f64>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<f64>(this.dataStart + (<usize>index << alignof<f64>()));\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): f64 {\n    return load<f64>(this.dataStart + (<usize>index << alignof<f64>()));\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: f64): void {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<f64>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<f64>(this.dataStart + (<usize>index << alignof<f64>()), value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: f64): void {\n    store<f64>(this.dataStart + (<usize>index << alignof<f64>()), value);\n  }\n\n  at(index: i32): f64 {\n    let len = this.byteLength >>> alignof<f64>();\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<f64>(this.dataStart + (<usize>index << alignof<f64>()));\n  }\n\n  includes(searchElement: f64, fromIndex: i32 = 0): bool {\n    return INCLUDES<Float64Array, f64>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: f64, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Float64Array, f64>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: f64, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Float64Array, f64>(this, searchElement, fromIndex);\n  }\n\n  fill(value: f64, start: i32 = 0, end: i32 = i32.MAX_VALUE): Float64Array {\n    FILL<f64>(this.dataStart, this.length, value, start, end);\n    return this;\n  }\n\n  sort(comparator: (a: f64, b: f64) => i32 = COMPARATOR<f64>()): Float64Array {\n    SORT<f64>(this.dataStart, this.length, comparator);\n    return this;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Float64Array {\n    return SLICE<Float64Array, f64>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Float64Array {\n    return SUBARRAY<Float64Array, f64>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Float64Array {\n    return COPY_WITHIN<Float64Array, f64>(this, target, start, end);\n  }\n\n  reduce<T extends number>(\n    fn: (accumulator: T, value: f64, index: i32, array: Float64Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Float64Array, f64, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T extends number>(\n    fn: (accumulator: T, value: f64, index: i32, array: Float64Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Float64Array, f64, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: f64, index: i32, self: Float64Array) => f64): Float64Array {\n    return MAP<Float64Array, f64>(this, fn);\n  }\n\n  filter(fn: (value: f64, index: i32, self: Float64Array) => bool): Float64Array {\n    return FILTER<Float64Array, f64>(this, fn);\n  }\n\n  findIndex(fn: (value: f64, index: i32, self: Float64Array) => bool): i32 {\n    return FIND_INDEX<Float64Array, f64>(this, fn);\n  }\n\n  findLastIndex(fn: (value: f64, index: i32, self: Float64Array) => bool): i32 {\n    return FIND_LAST_INDEX<Float64Array, f64>(this, fn);\n  }\n\n  some(fn: (value: f64, index: i32, self: Float64Array) => bool): bool {\n    return SOME<Float64Array, f64>(this, fn);\n  }\n\n  every(fn: (value: f64, index: i32, self: Float64Array) => bool): bool {\n    return EVERY<Float64Array, f64>(this, fn);\n  }\n\n  forEach(fn: (value: f64, index: i32, self: Float64Array) => void): void {\n    FOREACH<Float64Array, f64>(this, fn);\n  }\n\n  reverse(): Float64Array {\n    REVERSE<f64>(this.dataStart, this.length);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    return joinFloatArray<f64>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayLike<number>>(source: U, offset: i32 = 0): void {\n    SET(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Float64Array {\n    return WRAP<Float64Array, f64>(buffer, byteOffset, length);\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction SLICE<TArray extends ArrayBufferView, T extends number>(\n  array: TArray,\n  start: i32,\n  end: i32\n): TArray {\n  let len = array.length;\n  start  = start < 0 ? max(start + len, 0) : min(start, len);\n  end    = end   < 0 ? max(end   + len, 0) : min(end  , len);\n  len = max(end - start, 0);\n  let slice = instantiate<TArray>(len);\n  memory.copy(\n    slice.dataStart,\n    array.dataStart + (<usize>start << alignof<T>()),\n    <usize>len << alignof<T>()\n  );\n  return slice;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction SUBARRAY<TArray extends ArrayBufferView, T extends number>(\n  array: TArray,\n  begin: i32,\n  end: i32\n): TArray {\n  let len = array.length;\n  begin = begin < 0 ? max(len + begin, 0) : min(begin, len);\n  end   = end   < 0 ? max(len + end,   0) : min(end,   len);\n  end   = max(end, begin);\n\n  let out = changetype<TArray>(__new(offsetof<TArray>(), idof<TArray>()));\n  let buf = changetype<usize>(array.buffer);\n  store<usize>(changetype<usize>(out), buf, offsetof<TArray>(\"buffer\"));\n  __link(changetype<usize>(out), buf, false);\n  store<usize>(changetype<usize>(out), array.dataStart + (<usize>begin << alignof<T>()), offsetof<TArray>(\"dataStart\"));\n  store<u32>(changetype<usize>(out), (end - begin) << alignof<T>(), offsetof<TArray>(\"byteLength\"));\n  return out;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction COPY_WITHIN<TArray extends ArrayBufferView, T extends number>(\n  array: TArray,\n  target: i32,\n  start: i32,\n  end: i32\n): TArray {\n  let len = array.length;\n  let ptr = array.dataStart;\n\n  end   = min<i32>(end, len);\n  let to    = target < 0 ? max(len + target, 0) : min(target, len);\n  let from  = start < 0 ? max(len + start, 0) : min(start, len);\n  let last  = end < 0 ? max(len + end, 0) : min(end, len);\n  let count = min(last - from, len - to);\n\n  memory.copy(\n    ptr + (<usize>to << alignof<T>()),\n    ptr + (<usize>from << alignof<T>()),\n    <usize>count << alignof<T>()\n  );\n  return array;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction REDUCE<TArray extends ArrayBufferView, T extends number, TRet extends number>(\n  array: TArray,\n  fn: (accumulator: TRet, value: T, index: i32, array: TArray) => TRet,\n  initialValue: TRet\n): TRet {\n  let ptr = array.dataStart;\n  for (let i = 0, k = array.length; i < k; i++) {\n    initialValue = fn(initialValue, load<T>(ptr + (<usize>i << alignof<T>())), i, array);\n  }\n  return initialValue;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction REDUCE_RIGHT<TArray extends ArrayBufferView, T extends number, TRet extends number>(\n  array: TArray,\n  fn: (accumulator: TRet, value: T, index: i32, array: TArray) => TRet,\n  initialValue: TRet\n): TRet {\n  let ptr = array.dataStart;\n  for (let i = array.length - 1; i >= 0; i--) {\n    initialValue = fn(initialValue, load<T>(ptr + (<usize>i << alignof<T>())), i, array);\n  }\n  return initialValue;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction MAP<TArray extends ArrayBufferView, T extends number>(\n  array: TArray,\n  fn: (value: T, index: i32, self: TArray) => T,\n): TArray {\n  let len = array.length;\n  let ptr = array.dataStart;\n\n  let byteLength = len << alignof<T>();\n  let out = changetype<TArray>(__new(offsetof<TArray>(), idof<TArray>()));\n  let buf = changetype<ArrayBuffer>(__new(byteLength, idof<ArrayBuffer>()));\n  for (let i = 0; i < len; i++) {\n    store<T>(\n      changetype<usize>(buf) + (<usize>i << alignof<T>()),\n      fn(load<T>(ptr + (<usize>i << alignof<T>())), i, array)\n    );\n  }\n  store<usize>(changetype<usize>(out), changetype<usize>(buf), offsetof<TArray>(\"buffer\"));\n  __link(changetype<usize>(out), changetype<usize>(buf), false);\n  store<usize>(changetype<usize>(out), changetype<usize>(buf), offsetof<TArray>(\"dataStart\"));\n  store<u32>(changetype<usize>(out), byteLength, offsetof<TArray>(\"byteLength\"));\n  return out;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction FILTER<TArray extends ArrayBufferView, T extends number>(\n  array: TArray,\n  fn: (value: T, index: i32, self: TArray) => bool,\n): TArray {\n  let len = array.length;\n  let out = changetype<TArray>(__new(offsetof<TArray>(), idof<TArray>()));\n  let buf = changetype<ArrayBuffer>(__new(len << alignof<T>(), idof<ArrayBuffer>()));\n  let dataStart  = array.dataStart;\n  let j: usize = 0;\n  for (let i = 0; i < len; i++) {\n    let value = load<T>(dataStart + (<usize>i << alignof<T>()));\n    if (fn(value, i, array)) {\n      store<T>(\n        changetype<usize>(buf) + (j++ << alignof<T>()),\n        value\n      );\n    }\n  }\n  // shrink output buffer\n  let byteLength = j << alignof<T>();\n  let data = __renew(changetype<usize>(buf), byteLength);\n  store<usize>(changetype<usize>(out), data, offsetof<TArray>(\"buffer\"));\n  __link(changetype<usize>(out), data, false);\n  store<u32>(changetype<usize>(out), byteLength, offsetof<TArray>(\"byteLength\"));\n  store<usize>(changetype<usize>(out), data, offsetof<TArray>(\"dataStart\"));\n  return out;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction FIND_INDEX<TArray extends ArrayBufferView, T extends number>(\n  array: TArray,\n  fn: (value: T, index: i32, array: TArray) => bool,\n): i32 {\n  let ptr = array.dataStart;\n  for (let i = 0, k = array.length; i < k; i++) {\n    if (fn(load<T>(ptr + (<usize>i << alignof<T>())), i, array)) return i;\n  }\n  return -1;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction FIND_LAST_INDEX<TArray extends ArrayBufferView, T extends number>(\n  array: TArray,\n  fn: (value: T, index: i32, array: TArray) => bool,\n): i32 {\n  let ptr = array.dataStart;\n  for (let i = array.length - 1; i >= 0; --i) {\n    if (fn(load<T>(ptr + (<usize>i << alignof<T>())), i, array)) return i;\n  }\n  return -1;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction INCLUDES<TArray extends ArrayBufferView, T extends number>(\n  array: TArray,\n  searchElement: T,\n  fromIndex: i32,\n): bool {\n  if (isFloat<T>()) {\n    let index: isize = fromIndex;\n    let len: isize = array.length;\n    if (len == 0 || index >= len) return false;\n    if (index < 0) index = max(len + index, 0);\n    let dataStart = array.dataStart;\n    while (index < len) {\n      let elem = load<T>(dataStart + (index << alignof<T>()));\n      // @ts-ignore\n      if (elem == searchElement || isNaN(elem) & isNaN(searchElement)) return true;\n      ++index;\n    }\n    return false;\n  } else {\n    return INDEX_OF<TArray, T>(array, searchElement, fromIndex) >= 0;\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction INDEX_OF<TArray extends ArrayBufferView, T extends number>(\n  array: TArray,\n  searchElement: T,\n  fromIndex: i32,\n): i32 {\n  let index: isize = fromIndex;\n  let len: isize = array.length;\n  if (len == 0 || index >= len) return -1;\n  if (index < 0) index = max(len + index, 0);\n  let dataStart = array.dataStart;\n  while (index < len) {\n    if (load<T>(dataStart + (index << alignof<T>())) == searchElement) return <i32>index;\n    ++index;\n  }\n  return -1;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction LAST_INDEX_OF<TArray extends ArrayBufferView, T extends number>(\n  array: TArray,\n  searchElement: T,\n  fromIndex: i32,\n): i32 {\n  let index: isize = fromIndex;\n  let len: isize = array.length;\n  if (len == 0) return -1;\n  if (index < 0) index = len + index; // no need to clamp\n  else if (index >= len) index = len - 1;\n  let dataStart = array.dataStart;\n  while (index >= 0) {\n    if (load<T>(dataStart + (index << alignof<T>())) == searchElement) return <i32>index;\n    --index;\n  }\n  return -1;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction SOME<TArray extends ArrayBufferView, T extends number>(\n  array: TArray,\n  fn: (value: T, index: i32, array: TArray) => bool,\n): bool {\n  let ptr = array.dataStart;\n  for (let i = 0, k = array.length; i < k; i++) {\n    if (fn(load<T>(ptr + (<usize>i << alignof<T>())), i, array)) return true;\n  }\n  return false;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction EVERY<TArray extends ArrayBufferView, T extends number>(\n  array: TArray,\n  fn: (value: T, index: i32, array: TArray) => bool,\n): bool {\n  let ptr = array.dataStart;\n  for (let i = 0, k = array.length; i < k; i++) {\n    if (fn(load<T>(ptr + (<usize>i << alignof<T>())), i, array)) continue;\n    return false;\n  }\n  return true;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction FOREACH<TArray extends ArrayBufferView, T extends number>(\n  array: TArray,\n  fn: (value: T, index: i32, array: TArray) => void,\n): void {\n  let ptr = array.dataStart;\n  for (let i = 0, k = array.length; i < k; i++) {\n    fn(load<T>(ptr + (<usize>i << alignof<T>())), i, array);\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction WRAP<TArray extends ArrayBufferView, T>(\n  buffer: ArrayBuffer,\n  byteOffset: i32 = 0,\n  len: i32 = -1\n): TArray {\n  let byteLength: i32;\n  let bufferByteLength = buffer.byteLength;\n  const mask: u32 = sizeof<T>() - 1;\n  if (i32(<u32>byteOffset > <u32>bufferByteLength) | (byteOffset & mask)) {\n    throw new RangeError(E_INDEXOUTOFRANGE);\n  }\n  if (len < 0) {\n    if (len == -1) {\n      if (bufferByteLength & mask) {\n        throw new RangeError(E_INVALIDLENGTH);\n      }\n      byteLength = bufferByteLength - byteOffset;\n    } else {\n      throw new RangeError(E_INVALIDLENGTH);\n    }\n  } else {\n    byteLength = len << alignof<T>();\n    if (byteOffset + byteLength > bufferByteLength) {\n      throw new RangeError(E_INVALIDLENGTH);\n    }\n  }\n  let out = changetype<TArray>(__new(offsetof<TArray>(), idof<TArray>()));\n  store<usize>(changetype<usize>(out), changetype<usize>(buffer), offsetof<TArray>(\"buffer\"));\n  __link(changetype<usize>(out), changetype<usize>(buffer), false);\n  store<u32>(changetype<usize>(out), byteLength, offsetof<TArray>(\"byteLength\"));\n  store<usize>(changetype<usize>(out), changetype<usize>(buffer) + <usize>byteOffset, offsetof<TArray>(\"dataStart\"));\n  return out;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction SET<\n  TArray extends ArrayLike<number>,\n  UArray extends ArrayLike<number>\n>(\n  target: TArray,\n  source: UArray,\n  offset: i32 = 0\n): void {\n  // need to assert at compile time that U is not a reference or a function\n  if (isReference<valueof<UArray>>()) {\n    ERROR(E_NOTIMPLEMENTED);\n  }\n  let sourceLen = source.length;\n  if (offset < 0 || sourceLen + offset > target.length) {\n    // offset is out of bounds\n    throw new RangeError(E_INDEXOUTOFRANGE);\n  }\n  // @ts-ignore: dataStart\n  let targetStart = target.dataStart + (<usize>offset << (alignof<valueof<TArray>>()));\n  // @ts-ignore: dataStart\n  let sourceStart = source.dataStart;\n  // if the types align and match, use memory.copy() instead of manual loop\n  if (\n    isInteger<valueof<TArray>>() == isInteger<valueof<UArray>>() &&\n    alignof<valueof<TArray>>() == alignof<valueof<UArray>>() &&\n    !(isSigned<valueof<UArray>>() && target instanceof Uint8ClampedArray)\n  ) {\n    memory.copy(targetStart, sourceStart, <usize>sourceLen << (alignof<valueof<UArray>>()));\n  } else {\n    for (let i = 0; i < sourceLen; i++) {\n      let ptr = targetStart + (<usize>i << (alignof<valueof<TArray>>()));\n      let value = load<valueof<UArray>>(sourceStart + (<usize>i << (alignof<valueof<UArray>>())));\n      // if TArray is Uint8ClampedArray, then values must be clamped\n      if (target instanceof Uint8ClampedArray) {\n        if (isFloat<valueof<UArray>>()) {\n          store<valueof<TArray>>(ptr,\n            isFinite<valueof<UArray>>(value)\n              ? <valueof<TArray>>max<valueof<UArray>>(0, min<valueof<UArray>>(255, value))\n              : 0\n          );\n        } else {\n          if (!isSigned<valueof<UArray>>()) {\n            store<valueof<TArray>>(ptr, min<valueof<UArray>>(255, value));\n          } else if (sizeof<valueof<TArray>>() <= 4) {\n            store<valueof<TArray>>(ptr, ~(<i32>value >> 31) & (((255 - <i32>value) >> 31) | value));\n          } else {\n            store<valueof<TArray>>(ptr, ~(<i64>value >> 63) & (((255 - <i64>value) >> 63) | value));\n          }\n        }\n      } else {\n        if (isFloat<valueof<UArray>>() && !isFloat<valueof<TArray>>()) {\n          store<valueof<TArray>>(ptr, isFinite<valueof<UArray>>(value) ? <valueof<TArray>>value : 0);\n        } else {\n          store<valueof<TArray>>(ptr, <valueof<TArray>>value);\n        }\n      }\n    }\n  }\n}\n","import { BindGroup, BindingType, Buffer, BufferUsage, Device, Float, RenderPass, RenderPipeline, Shader, ShaderStage, TextureFormat, UInt, VertexFormat, vertexBufferLayouts } from '../interop/mugl';\nimport { BaseExample, createBuffer, createFloat32Array, createUint16Array } from '../common';\n\nconst code = `\nstruct VertexInput {\n  @location(0) position: vec2<f32>,\n  @location(1) offset: vec2<f32>,\n  @location(2) color: vec3<f32>,\n  @location(3) angle: f32,\n};\n\nstruct VertexOutput {\n  @builtin(position) clip_position: vec4<f32>,\n  @location(0) color: vec3<f32>,\n};\n\n@vertex\nfn vs_main(\n  model: VertexInput,\n) -> VertexOutput {\n  var out: VertexOutput;\n  out.color = model.color;\n  out.clip_position = vec4<f32>(\n      cos(model.angle) * model.position[0] + sin(model.angle) * model.position[1] + model.offset[0],\n      -sin(model.angle) * model.position[0] + cos(model.angle) * model.position[1] + model.offset[1],\n      0.0,\n      1.0\n  );\n  return out;\n}\n\nstruct Data {\n  ambient: vec4<f32>,\n};\n@group(0) @binding(0) var<uniform> data: Data;\n\n@fragment\nfn fs_main(in: VertexOutput) -> @location(0) vec4<f32> {\n  return vec4<f32>(data.ambient.rgb + in.color, data.ambient[3]);\n}\n`;\n\nconst vert = `#version 300 es\nlayout (location=0) in vec2 position;\nlayout (location=1) in vec2 offset;\nlayout (location=2) in vec3 color;\nlayout (location=3) in float angle;\nout vec3 vColor;\nvoid main() {\n  gl_Position = vec4(\n    cos(angle) * position.x + sin(angle) * position.y + offset.x,\n    -sin(angle) * position.x + cos(angle) * position.y + offset.y,\n    0, 1);\n  vColor = color;\n}\n`;\n\nconst frag = `#version 300 es\nprecision mediump float;\nlayout(std140) uniform Data {\n  vec3 ambient;\n};\nin vec3 vColor;\nout vec4 outColor;\nvoid main () {\n  outColor = vec4(ambient + vColor, 1.0);\n}\n`;\n\nconst N = 10; // N * N triangles\nconst indices = createUint16Array([0, 1, 2, 0]);\nconst position = createFloat32Array([\n  0.0, -0.05,\n  -0.05, 0.0,\n  0.05, 0.05\n]);\nconst offsetAndColor = new Float32Array(Math.ceil(N * N * 5 / 4) as UInt * 4);\nconst angle = new Float32Array(Math.ceil(N * N / 4) as UInt * 4);\n\nconst fN = N as Float;\nfor (let i = 0; i < N * N; i++) {\n  angle[i] = Math.random() * (2 * Math.PI) as Float;\n\n  // Offsets\n  offsetAndColor[5 * i] = (-1 + 2 * Math.floor(i / N) / fN + 0.1) as Float;\n  offsetAndColor[5 * i + 1] = (-1 + 2 * ((i % N) as Float) / fN + 0.1) as Float;\n\n  // Colors\n  const r = (Math.floor(i / N) / fN) as Float;\n  const g = ((i % N) as Float) / fN;\n  const b = r * g + 0.2;\n  offsetAndColor[5 * i + 2] = r;\n  offsetAndColor[5 * i + 3] = g;\n  offsetAndColor[5 * i + 4] = b;\n}\n\nexport class InstancingExample extends BaseExample {\n  pass: RenderPass | null = null;\n  pipeline: RenderPipeline | null = null;\n  indexBuffer: Buffer | null = null;\n  position: Buffer | null = null;\n  offsetColor: Buffer | null = null;\n  angle: Buffer | null = null;\n  bindGroup: BindGroup | null = null;\n  ambient: Buffer | null = null;\n  ambientData: Float32Array = new Float32Array(4);\n  t: Float = 0;\n\n  constructor(\n    private readonly device: Device,\n    useWebGPU: boolean\n  ) {\n    super(useWebGPU);\n  }\n\n  init(): void {\n    let vs: Shader, fs: Shader;\n    if (this.useWebGPU) {\n      vs = fs = this.gpu.createShader(this.device, { code, usage: ShaderStage.Vertex | ShaderStage.Fragment });\n    } else {\n      vs = this.gpu.createShader(this.device, { code: vert, usage: ShaderStage.Vertex });\n      fs = this.gpu.createShader(this.device, { code: frag, usage: ShaderStage.Fragment });\n    }\n\n    this.indexBuffer = createBuffer(this.gpu, this.device, indices, BufferUsage.Index);\n    this.position = createBuffer(this.gpu, this.device, position);\n    this.offsetColor = createBuffer(this.gpu, this.device, offsetAndColor);\n    this.angle = createBuffer(this.gpu, this.device, angle, BufferUsage.Vertex | BufferUsage.Stream);\n    this.ambient = createBuffer(this.gpu, this.device, this.ambientData, BufferUsage.Uniform | BufferUsage.Stream);\n\n    const bindGroupLayout = this.gpu.createBindGroupLayout(this.device, {\n      entries: [{ label: 'Data', type: BindingType.Buffer }]\n    });\n\n    this.bindGroup = this.gpu.createBindGroup(this.device, {\n      layout: bindGroupLayout,\n      entries: [{ buffer: this.ambient }]\n    });\n\n    this.pipeline = this.gpu.createRenderPipeline(this.device, {\n      vertex: vs,\n      fragment: fs,\n      buffers: vertexBufferLayouts([\n        { attributes: [/* position */ VertexFormat.F32x2] },\n        { attributes: [/* offset */ VertexFormat.F32x2, /* color */ VertexFormat.F32x3], instanced: true },\n        { attributes: [/* angle */ VertexFormat.F32], instanced: true }\n      ]),\n      bindGroups: [bindGroupLayout],\n      depthStencil: {\n        format: TextureFormat.Depth24Stencil8\n      },\n    });\n\n    this.pass = this.gpu.createRenderPass(this.device, { clearColor: [0, 0, 0, 1] });\n\n    this.register([\n      this.bindGroup!, this.indexBuffer!, this.position!, this.offsetColor!, this.angle!, this.pipeline!, this.pass!,\n      vs, fs, bindGroupLayout\n    ]);\n  }\n\n  render(t: Float): boolean {\n    for (let i = 0; i < N * N; i++) {\n      angle[i] += (this.t - t - 2 * Math.PI * Math.floor(angle[i] / Math.PI / 2)) as Float;\n    }\n    this.t = t;\n\n    this.gpu.writeBuffer(this.device, this.angle!, angle);\n\n    const a = Math.sin(t) / 2 as Float;\n    this.ambientData[0] = this.ambientData[1] = this.ambientData[2] = a;\n    this.gpu.writeBuffer(this.device, this.ambient!, this.ambientData);\n\n    this.gpu.beginRenderPass(this.device, this.pass!);\n    this.gpu.setRenderPipeline(this.device, this.pipeline!);\n    this.gpu.setIndex(this.device, this.indexBuffer!);\n    this.gpu.setVertex(this.device, 0, this.position!);\n    this.gpu.setVertex(this.device, 1, this.offsetColor!);\n    this.gpu.setVertex(this.device, 2, this.angle!);\n    this.gpu.setBindGroup(this.device, 0, this.bindGroup!);\n    this.gpu.drawIndexed(this.device, 3, N * N);\n    this.gpu.submitRenderPass(this.device);\n\n    return true;\n  }\n}\n","import { BaseGPU, Buffer, BufferUsage, Device, Float, UInt } from '../interop/mugl';\n\nexport function createBuffer(\n  gpu: BaseGPU, device: Device, data: ArrayBufferView, usage: BufferUsage = BufferUsage.Vertex\n): Buffer {\n  const buffer = gpu.createBuffer(device, { usage, size: data.byteLength });\n  gpu.writeBuffer(device, buffer, data);\n  return buffer;\n}\n\n// Below helpers are for AssemblyScript which does not have constructor to convert array to typed array.\n\nexport function createFloat32Array(data: Float[]): Float32Array {\n  const out = new Float32Array(data.length);\n  for (let i = 0; i < data.length; ++i) {\n    out[i] = data[i];\n  }\n  return out;\n}\n\nexport function createUint16Array(data: UInt[]): Uint16Array {\n  const out = new Uint16Array(data.length);\n  for (let i = 0; i < data.length; ++i) {\n    out[i] = data[i];\n  }\n  return out;\n}\n","import { Math as JSMath } from \"./bindings/dom\";\nexport { JSMath };\n\nimport {\n  pow_lut, exp_lut, exp2_lut, log_lut, log2_lut,\n  powf_lut, expf_lut, exp2f_lut, logf_lut, log2f_lut\n} from \"./util/math\";\n\nimport {\n  abs as builtin_abs,\n  ceil as builtin_ceil,\n  clz as builtin_clz,\n  copysign as builtin_copysign,\n  floor as builtin_floor,\n  max as builtin_max,\n  min as builtin_min,\n  sqrt as builtin_sqrt,\n  trunc as builtin_trunc\n} from \"./builtins\";\n\n// SUN COPYRIGHT NOTICE\n//\n// Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.\n// Developed at SunPro, a Sun Microsystems, Inc. business.\n// Permission to use, copy, modify, and distribute this software\n// is freely granted, provided that this notice is preserved.\n//\n// Applies to all functions marked with a comment referring here.\n\n/** @internal */\n// @ts-ignore: decorator\n@lazy let rempio2_y0: f64, rempio2_y1: f64, res128_hi: u64;\n\n/** @internal */\n// @ts-ignore: decorator\n@lazy @inline const PIO2_TABLE = memory.data<u64>([\n  0x00000000A2F9836E, 0x4E441529FC2757D1, 0xF534DDC0DB629599, 0x3C439041FE5163AB,\n  0xDEBBC561B7246E3A, 0x424DD2E006492EEA, 0x09D1921CFE1DEB1C, 0xB129A73EE88235F5,\n  0x2EBB4484E99C7026, 0xB45F7E413991D639, 0x835339F49C845F8B, 0xBDF9283B1FF897FF,\n  0xDE05980FEF2F118B, 0x5A0A6D1F6D367ECF, 0x27CB09B74F463F66, 0x9E5FEA2D7527BAC7,\n  0xEBE5F17B3D0739F7, 0x8A5292EA6BFB5FB1, 0x1F8D5D0856033046, 0xFC7B6BABF0CFBC20,\n  0x9AF4361DA9E39161, 0x5EE61B086599855F, 0x14A068408DFFD880, 0x4D73273106061557\n]);\n\n/** @internal */\nfunction R(z: f64): f64 { // Rational approximation of (asin(x)-x)/x^3\n  const                   // see: musl/src/math/asin.c and SUN COPYRIGHT NOTICE above\n    pS0 = reinterpret<f64>(0x3FC5555555555555), //  1.66666666666666657415e-01\n    pS1 = reinterpret<f64>(0xBFD4D61203EB6F7D), // -3.25565818622400915405e-01\n    pS2 = reinterpret<f64>(0x3FC9C1550E884455), //  2.01212532134862925881e-01\n    pS3 = reinterpret<f64>(0xBFA48228B5688F3B), // -4.00555345006794114027e-02\n    pS4 = reinterpret<f64>(0x3F49EFE07501B288), //  7.91534994289814532176e-04\n    pS5 = reinterpret<f64>(0x3F023DE10DFDF709), //  3.47933107596021167570e-05\n    qS1 = reinterpret<f64>(0xC0033A271C8A2D4B), // -2.40339491173441421878e+00\n    qS2 = reinterpret<f64>(0x40002AE59C598AC8), //  2.02094576023350569471e+00\n    qS3 = reinterpret<f64>(0xBFE6066C1B8D0159), // -6.88283971605453293030e-01\n    qS4 = reinterpret<f64>(0x3FB3B8C5B12E9282); //  7.70381505559019352791e-02\n\n  let p = z * (pS0 + z * (pS1 + z * (pS2 + z * (pS3 + z * (pS4 + z * pS5)))));\n  let q = 1.0 + z * (qS1 + z * (qS2 + z * (qS3 + z * qS4)));\n  return p / q;\n}\n\n/** @internal */\n// @ts-ignore: decorator\n@inline\nfunction expo2(x: f64, sign: f64): f64 { // exp(x)/2 for x >= log(DBL_MAX)\n  const                       // see: musl/src/math/__expo2.c\n    k    = <u32>2043,\n    kln2 = reinterpret<f64>(0x40962066151ADD8B); // 0x1.62066151add8bp+10\n  let scale = reinterpret<f64>(<u64>((<u32>0x3FF + k / 2) << 20) << 32);\n  // in directed rounding correct sign before rounding or overflow is important\n  return NativeMath.exp(x - kln2) * (sign * scale) * scale;\n}\n\n/** @internal */\n/* Helper function to eventually get bits of π/2 * |x|\n *\n * y = π/4 * (frac << clz(frac) >> 11)\n * return clz(frac)\n *\n * Right shift 11 bits to make upper half fit in `double`\n */\n// @ts-ignore: decorator\n@inline\nfunction pio2_right(q0: u64, q1: u64): u64 { // see: jdh8/metallic/blob/master/src/math/double/rem_pio2.c\n  // Bits of π/4\n  const p0: u64 = 0xC4C6628B80DC1CD1;\n  const p1: u64 = 0xC90FDAA22168C234;\n\n  const Ox1p_64 = reinterpret<f64>(0x3BF0000000000000); // 0x1p-64\n  const Ox1p_75 = reinterpret<f64>(0x3B40000000000000); // 0x1p-75\n\n  let shift = clz(q1);\n\n  q1 = q1 << shift | q0 >> (64 - shift);\n  q0 <<= shift;\n\n  let lo = umuldi(p1, q1);\n  let hi = res128_hi;\n\n  let ahi = hi >> 11;\n  let alo = lo >> 11 | hi << 53;\n  let blo = <u64>(Ox1p_75 * <f64>p0 * <f64>q1 + Ox1p_75 * <f64>p1 * <f64>q0);\n\n  rempio2_y0 = <f64>(ahi + u64(lo < blo));\n  rempio2_y1 = Ox1p_64 * <f64>(alo + blo);\n\n  return shift;\n}\n\n/** @internal */\n// @ts-ignore: decorator\n@inline\nfunction umuldi(u: u64, v: u64): u64 {\n  let u1: u64 , v1: u64, w0: u64, w1: u64, t: u64;\n\n  u1 = u & 0xFFFFFFFF;\n  v1 = v & 0xFFFFFFFF;\n\n  u >>= 32;\n  v >>= 32;\n\n  t  = u1 * v1;\n  w0 = t & 0xFFFFFFFF;\n  t  = u * v1 + (t >> 32);\n  w1 = t >> 32;\n  t  = u1 * v + (t & 0xFFFFFFFF);\n\n  res128_hi = u * v + w1 + (t >> 32);\n  return (t << 32) + w0;\n}\n\n/** @internal */\nfunction pio2_large_quot(x: f64, u: i64): i32 { // see: jdh8/metallic/blob/master/src/math/double/rem_pio2.c\n  let magnitude = u & 0x7FFFFFFFFFFFFFFF;\n  let offset = (magnitude >> 52) - 1045;\n  let shift  = offset & 63;\n  let tblPtr = PIO2_TABLE + (<i32>(offset >> 6) << 3);\n  let s0: u64, s1: u64, s2: u64;\n\n  let b0 = load<u64>(tblPtr, 0 << 3);\n  let b1 = load<u64>(tblPtr, 1 << 3);\n  let b2 = load<u64>(tblPtr, 2 << 3);\n\n  // Get 192 bits of 0x1p-31 / π with `offset` bits skipped\n  if (shift) {\n    let rshift = 64 - shift;\n    let b3 = load<u64>(tblPtr, 3 << 3);\n    s0 = b1 >> rshift | b0 << shift;\n    s1 = b2 >> rshift | b1 << shift;\n    s2 = b3 >> rshift | b2 << shift;\n  } else {\n    s0 = b0;\n    s1 = b1;\n    s2 = b2;\n  }\n\n  let significand = (u & 0x000FFFFFFFFFFFFF) | 0x0010000000000000;\n\n  // First 128 bits of fractional part of x/(2π)\n  let blo = umuldi(s1, significand);\n  let bhi = res128_hi;\n\n  let ahi = s0 * significand;\n  let clo = (s2 >> 32) * (significand >> 32);\n  let plo = blo + clo;\n  let phi = ahi + bhi + u64(plo < clo);\n\n  // r: u128 = p << 2\n  let rlo = plo << 2;\n  let rhi = phi << 2 | plo >> 62;\n\n  // s: i128 = r >> 127\n  let slo = <i64>rhi >> 63;\n  let shi = slo >> 1;\n  let q   = (<i64>phi >> 62) - slo;\n\n  let shifter = 0x3CB0000000000000 - (pio2_right(rlo ^ slo, rhi ^ shi) << 52);\n  let signbit = (u ^ rhi) & 0x8000000000000000;\n  let coeff   = reinterpret<f64>(shifter | signbit);\n\n  rempio2_y0 *= coeff;\n  rempio2_y1 *= coeff;\n\n  return <i32>q;\n}\n\n/** @internal */\n// @ts-ignore: decorator\n@inline\nfunction rempio2(x: f64, u: u64, sign: i32): i32 {\n  const\n    pio2_1  = reinterpret<f64>(0x3FF921FB54400000), // 1.57079632673412561417e+00\n    pio2_1t = reinterpret<f64>(0x3DD0B4611A626331), // 6.07710050650619224932e-11\n    pio2_2  = reinterpret<f64>(0x3DD0B4611A600000), // 6.07710050630396597660e-11\n    pio2_2t = reinterpret<f64>(0x3BA3198A2E037073), // 2.02226624879595063154e-21\n    pio2_3  = reinterpret<f64>(0x3BA3198A2E000000), // 2.02226624871116645580e-21\n    pio2_3t = reinterpret<f64>(0x397B839A252049C1), // 8.47842766036889956997e-32\n    invpio2 = reinterpret<f64>(0x3FE45F306DC9C883); // 0.63661977236758134308\n\n  let ix = <u32>(u >> 32) & 0x7FFFFFFF;\n\n  if (ASC_SHRINK_LEVEL < 1) {\n    if (ix < 0x4002D97C) { // |x| < 3pi/4, special case with n=+-1\n      let q = 1, z: f64, y0: f64, y1: f64;\n      if (!sign) {\n        z = x - pio2_1;\n        if (ix != 0x3FF921FB) { // 33+53 bit pi is good enough\n          y0 = z - pio2_1t;\n          y1 = (z - y0) - pio2_1t;\n        } else { // near pi/2, use 33+33+53 bit pi\n          z -= pio2_2;\n          y0 = z - pio2_2t;\n          y1 = (z - y0) - pio2_2t;\n        }\n      } else { // negative x\n        z = x + pio2_1;\n        if (ix != 0x3FF921FB) { // 33+53 bit pi is good enough\n          y0 = z + pio2_1t;\n          y1 = (z - y0) + pio2_1t;\n        } else { // near pi/2, use 33+33+53 bit pi\n          z += pio2_2;\n          y0 = z + pio2_2t;\n          y1 = (z - y0) + pio2_2t;\n        }\n        q = -1;\n      }\n      rempio2_y0 = y0;\n      rempio2_y1 = y1;\n      return q;\n    }\n  }\n\n  if (ix < 0x413921FB) { // |x| ~< 2^20*pi/2 (1647099)\n    // Use precise Cody Waite scheme\n    let q  = nearest(x * invpio2);\n    let r  = x - q * pio2_1;\n    let w  = q * pio2_1t; // 1st round good to 85 bit\n    let j  = ix >> 20;\n    let y0 = r - w;\n    let hi = <u32>(reinterpret<u64>(y0) >> 32);\n    let i  = j - ((hi >> 20) & 0x7FF);\n\n    if (i > 16) { // 2nd iteration needed, good to 118\n      let t = r;\n      w  = q * pio2_2;\n      r  = t - w;\n      w  = q * pio2_2t - ((t - r) - w);\n      y0 = r - w;\n      hi = <u32>(reinterpret<u64>(y0) >> 32);\n      i = j - ((hi >> 20) & 0x7FF);\n      if (i > 49) { // 3rd iteration need, 151 bits acc\n        let t = r;\n        w  = q * pio2_3;\n        r  = t - w;\n        w  = q * pio2_3t - ((t - r) - w);\n        y0 = r - w;\n      }\n    }\n    let y1 = (r - y0) - w;\n    rempio2_y0 = y0;\n    rempio2_y1 = y1;\n    return <i32>q;\n  }\n  let q = pio2_large_quot(x, u);\n  return select(-q, q, sign);\n}\n\n/** @internal */\n// @ts-ignore: decorator\n@inline\nfunction sin_kern(x: f64, y: f64, iy: i32): f64 { // see: musl/tree/src/math/__sin.c\n  const\n    S1 = reinterpret<f64>(0xBFC5555555555549), // -1.66666666666666324348e-01\n    S2 = reinterpret<f64>(0x3F8111111110F8A6), //  8.33333333332248946124e-03\n    S3 = reinterpret<f64>(0xBF2A01A019C161D5), // -1.98412698298579493134e-04\n    S4 = reinterpret<f64>(0x3EC71DE357B1FE7D), //  2.75573137070700676789e-06\n    S5 = reinterpret<f64>(0xBE5AE5E68A2B9CEB), // -2.50507602534068634195e-08\n    S6 = reinterpret<f64>(0x3DE5D93A5ACFD57C); //  1.58969099521155010221e-10\n\n  let z = x * x;\n  let w = z * z;\n  let r = S2 + z * (S3 + z * S4) + z * w * (S5 + z * S6);\n  let v = z * x;\n  if (!iy) {\n    return x + v * (S1 + z * r);\n  } else {\n    return x - ((z * (0.5 * y - v * r) - y) - v * S1);\n  }\n}\n\n/** @internal */\n// @ts-ignore: decorator\n@inline\nfunction cos_kern(x: f64, y: f64): f64 { // see: musl/tree/src/math/__cos.c\n  const\n    C1 = reinterpret<f64>(0x3FA555555555554C), //  4.16666666666666019037e-02\n    C2 = reinterpret<f64>(0xBF56C16C16C15177), // -1.38888888888741095749e-03\n    C3 = reinterpret<f64>(0x3EFA01A019CB1590), //  2.48015872894767294178e-05\n    C4 = reinterpret<f64>(0xBE927E4F809C52AD), // -2.75573143513906633035e-07\n    C5 = reinterpret<f64>(0x3E21EE9EBDB4B1C4), //  2.08757232129817482790e-09\n    C6 = reinterpret<f64>(0xBDA8FAE9BE8838D4); // -1.13596475577881948265e-11\n\n  let z = x * x;\n  let w = z * z;\n  let r = z * (C1 + z * (C2 + z * C3)) + w * w * (C4 + z * (C5 + z * C6));\n  let hz = 0.5 * z;\n  w = 1.0 - hz;\n  return w + (((1.0 - w) - hz) + (z * r - x * y));\n}\n\n/** @internal */\nfunction tan_kern(x: f64, y: f64, iy: i32): f64 { // see: src/lib/msun/src/k_tan.c\n  const\n    T0  = reinterpret<f64>(0x3FD5555555555563), //  3.33333333333334091986e-01\n    T1  = reinterpret<f64>(0x3FC111111110FE7A), //  1.33333333333201242699e-01\n    T2  = reinterpret<f64>(0x3FABA1BA1BB341FE), //  5.39682539762260521377e-02\n    T3  = reinterpret<f64>(0x3F9664F48406D637), //  2.18694882948595424599e-02\n    T4  = reinterpret<f64>(0x3F8226E3E96E8493), //  8.86323982359930005737e-03\n    T5  = reinterpret<f64>(0x3F6D6D22C9560328), //  3.59207910759131235356e-03\n    T6  = reinterpret<f64>(0x3F57DBC8FEE08315), //  1.45620945432529025516e-03\n    T7  = reinterpret<f64>(0x3F4344D8F2F26501), //  5.88041240820264096874e-04\n    T8  = reinterpret<f64>(0x3F3026F71A8D1068), //  2.46463134818469906812e-04\n    T9  = reinterpret<f64>(0x3F147E88A03792A6), //  7.81794442939557092300e-05\n    T10 = reinterpret<f64>(0x3F12B80F32F0A7E9), //  7.14072491382608190305e-05\n    T11 = reinterpret<f64>(0xBEF375CBDB605373), // -1.85586374855275456654e-05\n    T12 = reinterpret<f64>(0x3EFB2A7074BF7AD4); //  2.59073051863633712884e-05\n\n  const\n    one    = reinterpret<f64>(0x3FF0000000000000), // 1.00000000000000000000e+00\n    pio4   = reinterpret<f64>(0x3FE921FB54442D18), // 7.85398163397448278999e-01\n    pio4lo = reinterpret<f64>(0x3C81A62633145C07); // 3.06161699786838301793e-17\n\n  let z: f64, r: f64, v: f64, w: f64, s: f64;\n  let hx = <i32>(reinterpret<u64>(x) >> 32); // high word of x\n  let ix = hx & 0x7FFFFFFF; // high word of |x|\n  let big = ix >= 0x3FE59428;\n  if (big) { // |x| >= 0.6744\n    if (hx < 0) { x = -x, y = -y; }\n    z = pio4 - x;\n    w = pio4lo - y;\n    x = z + w;\n    y = 0.0;\n  }\n  z = x * x;\n  w = z * z;\n  r = T1 + w * (T3 + w * (T5 + w * (T7 + w * (T9 + w * T11))));\n  v = z * (T2 + w * (T4 + w * (T6 + w * (T8 + w * (T10 + w * T12)))));\n  s = z * x;\n  r = y + z * (s * (r + v) + y);\n  r += T0 * s;\n  w = x + r;\n  if (big) {\n    v = iy;\n    return (1 - ((hx >> 30) & 2)) * (v - 2.0 * (x - (w * w / (w + v) - r)));\n  }\n  if (iy == 1) return w;\n  let a: f64, t: f64;\n  z = w;\n  z = reinterpret<f64>(reinterpret<u64>(z) & 0xFFFFFFFF00000000);\n  v = r - (z - x);  // z + v = r + x\n  t = a = -one / w; // a = -1.0 / w\n  t = reinterpret<f64>(reinterpret<u64>(t) & 0xFFFFFFFF00000000);\n  s = one + t * z;\n  return t + a * (s + t * v);\n}\n\n/** @internal */\nfunction dtoi32(x: f64): i32 {\n  if (ASC_SHRINK_LEVEL > 0) {\n    const inv32 = 1.0 / 4294967296;\n    return <i32><i64>(x - 4294967296 * floor(x * inv32));\n  } else {\n    let result = 0;\n    let u = reinterpret<u64>(x);\n    let e = (u >> 52) & 0x7FF;\n    if (e <= 1023 + 30) {\n      result = <i32>x;\n    } else if (e <= 1023 + 30 + 53) {\n      let v = (u & ((<u64>1 << 52) - 1)) | (<u64>1 << 52);\n      v = v << e - 1023 - 52 + 32;\n      result = <i32>(v >> 32);\n      result = select<i32>(-result, result, <i64>u < 0);\n    }\n    return result;\n  }\n}\n\n// @ts-ignore: decorator\n@lazy let random_seeded = false;\n\n// @ts-ignore: decorator\n@lazy let random_state0_64: u64, random_state1_64: u64;\n\n// @ts-ignore: decorator\n@lazy let random_state0_32: u32, random_state1_32: u32;\n\nfunction murmurHash3(h: u64): u64 { // Force all bits of a hash block to avalanche\n  h ^= h >> 33;                     // see: https://github.com/aappleby/smhasher\n  h *= 0xFF51AFD7ED558CCD;\n  h ^= h >> 33;\n  h *= 0xC4CEB9FE1A85EC53;\n  h ^= h >> 33;\n  return h;\n}\n\nfunction splitMix32(h: u32): u32 {\n  h += 0x6D2B79F5;\n  h  = (h ^ (h >> 15)) * (h | 1);\n  h ^= h + (h ^ (h >> 7)) * (h | 61);\n  return h ^ (h >> 14);\n}\n\nexport namespace NativeMath {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const E       = reinterpret<f64>(0x4005BF0A8B145769); // 2.7182818284590452354\n\n  // @ts-ignore: decorator\n  @lazy\n  export const LN2     = reinterpret<f64>(0x3FE62E42FEFA39EF); // 0.69314718055994530942\n\n  // @ts-ignore: decorator\n  @lazy\n  export const LN10    = reinterpret<f64>(0x40026BB1BBB55516); // 2.30258509299404568402\n\n  // @ts-ignore: decorator\n  @lazy\n  export const LOG2E   = reinterpret<f64>(0x3FF71547652B82FE); // 1.4426950408889634074\n\n  // @ts-ignore: decorator\n  @lazy\n  export const LOG10E  = reinterpret<f64>(0x3FDBCB7B1526E50E); // 0.43429448190325182765\n\n  // @ts-ignore: decorator\n  @lazy\n  export const PI      = reinterpret<f64>(0x400921FB54442D18); // 3.14159265358979323846\n\n  // @ts-ignore: decorator\n  @lazy\n  export const SQRT1_2 = reinterpret<f64>(0x3FE6A09E667F3BCD); // 0.70710678118654752440\n\n  // @ts-ignore: decorator\n  @lazy\n  export const SQRT2   = reinterpret<f64>(0x3FF6A09E667F3BCD); // 1.41421356237309504880\n\n  // @ts-ignore: decorator\n  @lazy\n  export let sincos_sin: f64 = 0;\n\n  // @ts-ignore: decorator\n  @lazy\n  export let sincos_cos: f64 = 0;\n\n  // @ts-ignore: decorator\n  @inline export function abs(x: f64): f64 {\n    return builtin_abs<f64>(x);\n  }\n\n  export function acos(x: f64): f64 { // see: musl/src/math/acos.c and SUN COPYRIGHT NOTICE above\n    const\n      pio2_hi   = reinterpret<f64>(0x3FF921FB54442D18), // 1.57079632679489655800e+00\n      pio2_lo   = reinterpret<f64>(0x3C91A62633145C07), // 6.12323399573676603587e-17\n      Ox1p_120f = reinterpret<f32>(0x03800000);\n\n    let hx = <u32>(reinterpret<u64>(x) >> 32);\n    let ix = hx & 0x7FFFFFFF;\n    if (ix >= 0x3FF00000) {\n      let lx = <u32>reinterpret<u64>(x);\n      if ((ix - 0x3FF00000 | lx) == 0) {\n        if (<i32>hx < 0) return 2 * pio2_hi + Ox1p_120f;\n        return 0;\n      }\n      return 0 / (x - x);\n    }\n    if (ix < 0x3FE00000) {\n      if (ix <= 0x3C600000) return pio2_hi + Ox1p_120f;\n      return pio2_hi - (x - (pio2_lo - x * R(x * x)));\n    }\n    let s: f64, w: f64, z: f64;\n    if (<i32>hx < 0) {\n      // z = (1.0 + x) * 0.5;\n      z = 0.5 + x * 0.5;\n      s = builtin_sqrt<f64>(z);\n      w = R(z) * s - pio2_lo;\n      return 2 * (pio2_hi - (s + w));\n    }\n    // z = (1.0 - x) * 0.5;\n    z = 0.5 - x * 0.5;\n    s = builtin_sqrt<f64>(z);\n    let df = reinterpret<f64>(reinterpret<u64>(s) & 0xFFFFFFFF00000000);\n    let c = (z - df * df) / (s + df);\n    w = R(z) * s + c;\n    return 2 * (df + w);\n  }\n\n  export function acosh(x: f64): f64 { // see: musl/src/math/acosh.c\n    const s = reinterpret<f64>(0x3FE62E42FEFA39EF);\n    let u = reinterpret<u64>(x);\n    // Prevent propagation for all input values less than 1.0.\n    // Note musl lib didn't fix this yet.\n    if (<i64>u < 0x3FF0000000000000) return (x - x) / 0.0;\n    let e = u >> 52 & 0x7FF;\n    if (e < 0x3FF + 1) return log1p(x - 1 + builtin_sqrt<f64>((x - 1) * (x - 1) + 2 * (x - 1)));\n    if (e < 0x3FF + 26) return log(2 * x - 1 / (x + builtin_sqrt<f64>(x * x - 1)));\n    return log(x) + s;\n  }\n\n  export function asin(x: f64): f64 { // see: musl/src/math/asin.c and SUN COPYRIGHT NOTICE above\n    const\n      pio2_hi   = reinterpret<f64>(0x3FF921FB54442D18), // 1.57079632679489655800e+00\n      pio2_lo   = reinterpret<f64>(0x3C91A62633145C07), // 6.12323399573676603587e-17\n      Ox1p_120f = reinterpret<f32>(0x03800000);\n\n    let hx = <u32>(reinterpret<u64>(x) >> 32);\n    let ix = hx & 0x7FFFFFFF;\n    if (ix >= 0x3FF00000) {\n      let lx = <u32>reinterpret<u64>(x);\n      if ((ix - 0x3FF00000 | lx) == 0) return x * pio2_hi + Ox1p_120f;\n      return 0 / (x - x);\n    }\n    if (ix < 0x3FE00000) {\n      if (ix < 0x3E500000 && ix >= 0x00100000) return x;\n      return x + x * R(x * x);\n    }\n    // let z = (1.0 - builtin_abs<f64>(x)) * 0.5;\n    let z = 0.5 - builtin_abs<f64>(x) * 0.5;\n    let s = builtin_sqrt<f64>(z);\n    let r = R(z);\n    if (ix >= 0x3FEF3333) x = pio2_hi - (2 * (s + s * r) - pio2_lo);\n    else {\n      let f = reinterpret<f64>(reinterpret<u64>(s) & 0xFFFFFFFF00000000);\n      let c = (z - f * f) / (s + f);\n      x = 0.5 * pio2_hi - (2 * s * r - (pio2_lo - 2 * c) - (0.5 * pio2_hi - 2 * f));\n    }\n    return select(-x, x, <i32>hx < 0);\n  }\n\n  export function asinh(x: f64): f64 { // see: musl/src/math/asinh.c\n    const c = reinterpret<f64>(0x3FE62E42FEFA39EF); // 0.693147180559945309417232121458176568\n    let u = reinterpret<u64>(x);\n    let e = u >> 52 & 0x7FF;\n    let y = reinterpret<f64>(u & 0x7FFFFFFFFFFFFFFF);\n    if (e >= 0x3FF + 26) y = log(y) + c;\n    else if (e >= 0x3FF + 1)  y =   log(2 * y + 1 / (builtin_sqrt<f64>(y * y + 1) + y));\n    else if (e >= 0x3FF - 26) y = log1p(y + y * y / (builtin_sqrt<f64>(y * y + 1) + 1));\n    return builtin_copysign(y, x);\n  }\n\n  export function atan(x: f64): f64 { // see musl/src/math/atan.c and SUN COPYRIGHT NOTICE above\n    const\n      atanhi0   = reinterpret<f64>(0x3FDDAC670561BB4F), //  4.63647609000806093515e-01\n      atanhi1   = reinterpret<f64>(0x3FE921FB54442D18), //  7.85398163397448278999e-01\n      atanhi2   = reinterpret<f64>(0x3FEF730BD281F69B), //  9.82793723247329054082e-01\n      atanhi3   = reinterpret<f64>(0x3FF921FB54442D18), //  1.57079632679489655800e+00\n      atanlo0   = reinterpret<f64>(0x3C7A2B7F222F65E2), //  2.26987774529616870924e-17\n      atanlo1   = reinterpret<f64>(0x3C81A62633145C07), //  3.06161699786838301793e-17\n      atanlo2   = reinterpret<f64>(0x3C7007887AF0CBBD), //  1.39033110312309984516e-17\n      atanlo3   = reinterpret<f64>(0x3C91A62633145C07), //  6.12323399573676603587e-17\n      aT0       = reinterpret<f64>(0x3FD555555555550D), //  3.33333333333329318027e-01\n      aT1       = reinterpret<f64>(0xBFC999999998EBC4), // -1.99999999998764832476e-01\n      aT2       = reinterpret<f64>(0x3FC24924920083FF), //  1.42857142725034663711e-01\n      aT3       = reinterpret<f64>(0xBFBC71C6FE231671), // -1.11111104054623557880e-01,\n      aT4       = reinterpret<f64>(0x3FB745CDC54C206E), //  9.09088713343650656196e-02\n      aT5       = reinterpret<f64>(0xBFB3B0F2AF749A6D), // -7.69187620504482999495e-02\n      aT6       = reinterpret<f64>(0x3FB10D66A0D03D51), //  6.66107313738753120669e-02\n      aT7       = reinterpret<f64>(0xBFADDE2D52DEFD9A), // -5.83357013379057348645e-02\n      aT8       = reinterpret<f64>(0x3FA97B4B24760DEB), //  4.97687799461593236017e-02\n      aT9       = reinterpret<f64>(0xBFA2B4442C6A6C2F), // -3.65315727442169155270e-02\n      aT10      = reinterpret<f64>(0x3F90AD3AE322DA11), //  1.62858201153657823623e-02\n      Ox1p_120f = reinterpret<f32>(0x03800000);\n\n    let ix = <u32>(reinterpret<u64>(x) >> 32);\n    let sx = x;\n    ix &= 0x7FFFFFFF;\n    let z: f64;\n    if (ix >= 0x44100000) {\n      if (isNaN(x)) return x;\n      z = atanhi3 + Ox1p_120f;\n      return builtin_copysign<f64>(z, sx);\n    }\n    let id: i32;\n    if (ix < 0x3FDC0000) {\n      if (ix < 0x3E400000) return x;\n      id = -1;\n    } else {\n      x = builtin_abs<f64>(x);\n      if (ix < 0x3FF30000) {\n        if (ix < 0x3FE60000) {\n          id = 0;\n          x = (2.0 * x - 1.0) / (2.0 + x);\n        } else {\n          id = 1;\n          x = (x - 1.0) / (x + 1.0);\n        }\n      } else {\n        if (ix < 0x40038000) {\n          id = 2;\n          x = (x - 1.5) / (1.0 + 1.5 * x);\n        } else {\n          id = 3;\n          x = -1.0 / x;\n        }\n      }\n    }\n    z = x * x;\n    let w = z * z;\n    let s1 = z * (aT0 + w * (aT2 + w * (aT4 + w * (aT6 + w * (aT8 + w * aT10)))));\n    let s2 = w * (aT1 + w * (aT3 + w * (aT5 + w * (aT7 + w * aT9))));\n    let s3 = x * (s1 + s2);\n    if (id < 0) return x - s3;\n    switch (id) {\n      case 0: { z = atanhi0 - ((s3 - atanlo0) - x); break; }\n      case 1: { z = atanhi1 - ((s3 - atanlo1) - x); break; }\n      case 2: { z = atanhi2 - ((s3 - atanlo2) - x); break; }\n      case 3: { z = atanhi3 - ((s3 - atanlo3) - x); break; }\n      default: unreachable();\n    }\n    return builtin_copysign<f64>(z, sx);\n  }\n\n  export function atanh(x: f64): f64 { // see: musl/src/math/atanh.c\n    let u = reinterpret<u64>(x);\n    let e = u >> 52 & 0x7FF;\n    let y = builtin_abs(x);\n    if (e < 0x3FF - 1) {\n      if (e >= 0x3FF - 32) y = 0.5 * log1p(2 * y + 2 * y * y / (1 - y));\n    } else {\n      y = 0.5 * log1p(2 * (y / (1 - y)));\n    }\n    return builtin_copysign<f64>(y, x);\n  }\n\n  export function atan2(y: f64, x: f64): f64 { // see: musl/src/math/atan2.c and SUN COPYRIGHT NOTICE above\n    const pi_lo = reinterpret<f64>(0x3CA1A62633145C07); // 1.2246467991473531772E-16\n    if (isNaN(x) || isNaN(y)) return x + y;\n    let u = reinterpret<u64>(x);\n    let ix = <u32>(u >> 32);\n    let lx = <u32>u;\n    u = reinterpret<u64>(y);\n    let iy = <u32>(u >> 32);\n    let ly = <u32>u;\n    if ((ix - 0x3FF00000 | lx) == 0) return atan(y);\n    let m = ((iy >> 31) & 1) | ((ix >> 30) & 2);\n    ix = ix & 0x7FFFFFFF;\n    iy = iy & 0x7FFFFFFF;\n    if ((iy | ly) == 0) {\n      switch (m) {\n        case 0:\n        case 1: return  y;\n        case 2: return  PI;\n        case 3: return -PI;\n      }\n    }\n    if ((ix | lx) == 0) return m & 1 ? -PI / 2 : PI / 2;\n    if (ix == 0x7FF00000) {\n      if (iy == 0x7FF00000) {\n        let t = m & 2 ? 3 * PI / 4 : PI / 4;\n        return m & 1 ? -t : t;\n      } else {\n        let t = m & 2 ? PI : 0;\n        return m & 1 ? -t : t;\n      }\n    }\n    let z: f64;\n    if (ix + (64 << 20) < iy || iy == 0x7FF00000) return m & 1 ? -PI / 2 : PI / 2;\n    if ((m & 2) && iy + (64 << 20) < ix) z = 0;\n    else z = atan(builtin_abs<f64>(y / x));\n    switch (m) {\n      case 0: return  z;\n      case 1: return -z;\n      case 2: return PI - (z - pi_lo);\n      case 3: return (z - pi_lo) - PI;\n    }\n    unreachable();\n    return 0;\n  }\n\n  export function cbrt(x: f64): f64 { // see: musl/src/math/cbrt.c and SUN COPYRIGHT NOTICE above\n    const\n      B1     = <u32>715094163,\n      B2     = <u32>696219795,\n      P0     = reinterpret<f64>(0x3FFE03E60F61E692), //  1.87595182427177009643\n      P1     = reinterpret<f64>(0xBFFE28E092F02420), // -1.88497979543377169875\n      P2     = reinterpret<f64>(0x3FF9F1604A49D6C2), //  1.621429720105354466140\n      P3     = reinterpret<f64>(0xBFE844CBBEE751D9), // -0.758397934778766047437\n      P4     = reinterpret<f64>(0x3FC2B000D4E4EDD7), //  0.145996192886612446982\n      Ox1p54 = reinterpret<f64>(0x4350000000000000); //  0x1p54\n\n    let u = reinterpret<u64>(x);\n    let hx = <u32>(u >> 32) & 0x7FFFFFFF;\n    if (hx >= 0x7FF00000) return x + x;\n    if (hx < 0x00100000) {\n      u = reinterpret<u64>(x * Ox1p54);\n      hx = <u32>(u >> 32) & 0x7FFFFFFF;\n      if (hx == 0) return x;\n      hx = hx / 3 + B2;\n    } else {\n      hx = hx / 3 + B1;\n    }\n    u &= 1 << 63;\n    u |= <u64>hx << 32;\n    let t = reinterpret<f64>(u);\n    let r = (t * t) * (t / x);\n    t = t * ((P0 + r * (P1 + r * P2)) + ((r * r) * r) * (P3 + r * P4));\n    t = reinterpret<f64>((reinterpret<u64>(t) + 0x80000000) & 0xFFFFFFFFC0000000);\n    let s = t * t;\n    r = x / s;\n    r = (r - t) / (2 * t + r);\n    t = t + t * r;\n    return t;\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function ceil(x: f64): f64 {\n    return builtin_ceil<f64>(x);\n  }\n\n  export function clz32(x: f64): f64 {\n    if (!isFinite(x)) return 32;\n    /*\n     * Wasm (MVP) and JS have different approaches for double->int conversions.\n     *\n     * For emulate JS conversion behavior and avoid trapping from wasm we should modulate by MAX_INT\n     * our float-point arguments before actual convertion to integers.\n     */\n    return builtin_clz(dtoi32(x));\n  }\n\n  export function cos(x: f64): f64 { // see: musl/src/math/cos.c\n    let u  = reinterpret<u64>(x);\n    let ux = u32(u >> 32);\n    let sign = ux >> 31;\n\n    ux &= 0x7FFFFFFF;\n\n    // |x| ~< pi/4\n    if (ux <= 0x3FE921FB) {\n      if (ux < 0x3E46A09E) {  // |x| < 2**-27 * sqrt(2)\n        return 1.0;\n      }\n      return cos_kern(x, 0);\n    }\n\n    // sin(Inf or NaN) is NaN\n    if (ux >= 0x7FF00000) return x - x;\n\n    // argument reduction needed\n    let n  = rempio2(x, u, sign);\n    let y0 = rempio2_y0;\n    let y1 = rempio2_y1;\n\n    x = n & 1 ? sin_kern(y0, y1, 1) : cos_kern(y0, y1);\n    return (n + 1) & 2 ? -x : x;\n  }\n\n  export function cosh(x: f64): f64 { // see: musl/src/math/cosh.c\n    let u = reinterpret<u64>(x);\n    u &= 0x7FFFFFFFFFFFFFFF;\n    x = reinterpret<f64>(u);\n    let w = <u32>(u >> 32);\n    let t: f64;\n    if (w < 0x3FE62E42) {\n      if (w < 0x3FF00000 - (26 << 20)) return 1;\n      t = expm1(x);\n      // return 1 + t * t / (2 * (1 + t));\n      return 1 + t * t / (2 + 2 * t);\n    }\n    if (w < 0x40862E42) {\n      t = exp(x);\n      return 0.5 * (t + 1 / t);\n    }\n    t = expo2(x, 1);\n    return t;\n  }\n\n  export function exp(x: f64): f64 { // see: musl/src/math/exp.c and SUN COPYRIGHT NOTICE above\n    if (ASC_SHRINK_LEVEL < 1) {\n      return exp_lut(x);\n    } else {\n      const\n        ln2hi     = reinterpret<f64>(0x3FE62E42FEE00000), //  6.93147180369123816490e-01\n        ln2lo     = reinterpret<f64>(0x3DEA39EF35793C76), //  1.90821492927058770002e-10\n        invln2    = reinterpret<f64>(0x3FF71547652B82FE), //  1.44269504088896338700e+00\n        P1        = reinterpret<f64>(0x3FC555555555553E), //  1.66666666666666019037e-01\n        P2        = reinterpret<f64>(0xBF66C16C16BEBD93), // -2.77777777770155933842e-03\n        P3        = reinterpret<f64>(0x3F11566AAF25DE2C), //  6.61375632143793436117e-05\n        P4        = reinterpret<f64>(0xBEBBBD41C5D26BF1), // -1.65339022054652515390e-06\n        P5        = reinterpret<f64>(0x3E66376972BEA4D0), //  4.13813679705723846039e-08\n        overflow  = reinterpret<f64>(0x40862E42FEFA39EF), //  709.782712893383973096\n        underflow = reinterpret<f64>(0xC0874910D52D3051), // -745.13321910194110842\n        Ox1p1023  = reinterpret<f64>(0x7FE0000000000000); //  0x1p1023\n\n      let hx = u32(reinterpret<u64>(x) >> 32);\n      let sign = hx >> 31;\n      hx &= 0x7FFFFFFF;\n      if (hx >= 0x4086232B) {\n        if (isNaN(x)) return x;\n        if (x > overflow)  return x * Ox1p1023;\n        if (x < underflow) return 0;\n      }\n      let hi: f64, lo: f64 = 0;\n      let k = 0;\n      if (hx > 0x3FD62E42) {\n        if (hx >= 0x3FF0A2B2) {\n          k = i32(invln2 * x + builtin_copysign<f64>(0.5, x));\n        } else {\n          k = 1 - (sign << 1);\n        }\n        hi = x - k * ln2hi;\n        lo = k * ln2lo;\n        x = hi - lo;\n      } else if (hx > 0x3E300000) {\n        hi = x;\n      } else return 1.0 + x;\n      let xs = x * x;\n      // let c = x - xp2 * (P1 + xp2 * (P2 + xp2 * (P3 + xp2 * (P4 + xp2 * P5))));\n      let xq = xs * xs;\n      let c = x - (xs * P1 + xq * ((P2 + xs * P3) + xq * (P4 + xs * P5)));\n      let y = 1.0 + (x * c / (2 - c) - lo + hi);\n      return k == 0 ? y : scalbn(y, k);\n    }\n  }\n\n  export function exp2(x: f64): f64 {\n    return exp2_lut(x);\n  }\n\n  export function expm1(x: f64): f64 { // see: musl/src/math/expm1.c and SUN COPYRIGHT NOTICE above\n    const\n      o_threshold = reinterpret<f64>(0x40862E42FEFA39EF), //  7.09782712893383973096e+02\n      ln2_hi      = reinterpret<f64>(0x3FE62E42FEE00000), //  6.93147180369123816490e-01\n      ln2_lo      = reinterpret<f64>(0x3DEA39EF35793C76), //  1.90821492927058770002e-10\n      invln2      = reinterpret<f64>(0x3FF71547652B82FE), //  1.44269504088896338700e+00\n      Q1          = reinterpret<f64>(0xBFA11111111110F4), // -3.33333333333331316428e-02\n      Q2          = reinterpret<f64>(0x3F5A01A019FE5585), //  1.58730158725481460165e-03\n      Q3          = reinterpret<f64>(0xBF14CE199EAADBB7), // -7.93650757867487942473e-05\n      Q4          = reinterpret<f64>(0x3ED0CFCA86E65239), //  4.00821782732936239552e-06\n      Q5          = reinterpret<f64>(0xBE8AFDB76E09C32D), // -2.01099218183624371326e-07\n      Ox1p1023    = reinterpret<f64>(0x7FE0000000000000); //  0x1p1023\n\n    let u = reinterpret<u64>(x);\n    let hx = u32(u >> 32) & 0x7FFFFFFF;\n    let sign = u32(u >> 63);\n    let k = 0;\n    if (hx >= 0x4043687A) {\n      if (isNaN(x)) return x;\n      if (sign) return -1;\n      if (x > o_threshold) return x * Ox1p1023;\n    }\n    let c = 0.0, t: f64;\n    if (hx > 0x3FD62E42) {\n      k = select<i32>(\n        1 - (sign << 1),\n        i32(invln2 * x + builtin_copysign<f64>(0.5, x)),\n        hx < 0x3FF0A2B2\n      );\n      t = <f64>k;\n      let hi = x - t * ln2_hi;\n      let lo = t * ln2_lo;\n      x = hi - lo;\n      c = (hi - x) - lo;\n    } else if (hx < 0x3C900000) return x;\n    let hfx = 0.5 * x;\n    let hxs = x * hfx;\n    // let r1 = 1.0 + hxs * (Q1 + hxs * (Q2 + hxs * (Q3 + hxs * (Q4 + hxs * Q5))));\n    let hxq = hxs * hxs;\n    let r1 = (1.0 + hxs * Q1) + hxq * ((Q2 + hxs * Q3) + hxq * (Q4 + hxs * Q5));\n    t = 3.0 - r1 * hfx;\n    let e = hxs * ((r1 - t) / (6.0 - x * t));\n    if (k == 0) return x - (x * e - hxs);\n    e = x * (e - c) - c;\n    e -= hxs;\n    if (k == -1) return 0.5 * (x - e) - 0.5;\n    if (k == 1) {\n      if (x < -0.25) return -2.0 * (e - (x + 0.5));\n      return 1.0 + 2.0 * (x - e);\n    }\n    u = (0x3FF + k) << 52;\n    let twopk = reinterpret<f64>(u);\n    let y: f64;\n    if (k < 0 || k > 56) {\n      y = x - e + 1.0;\n      if (k == 1024) y = y * 2.0 * Ox1p1023;\n      else y = y * twopk;\n      return y - 1.0;\n    }\n    u = (0x3FF - k) << 52;\n    y = reinterpret<f64>(u);\n    if (k < 20) y = (1 - y) - e;\n    else y = 1 - (e + y);\n    return (x + y) * twopk;\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function floor(x: f64): f64 {\n    return builtin_floor<f64>(x);\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function fround(x: f64): f64 {\n    return <f32>x;\n  }\n\n  export function hypot(x: f64, y: f64): f64 { // see: musl/src/math/hypot.c\n    const\n      SPLIT    = reinterpret<f64>(0x41A0000000000000) + 1, // 0x1p27 + 1\n      Ox1p700  = reinterpret<f64>(0x6BB0000000000000),\n      Ox1p_700 = reinterpret<f64>(0x1430000000000000);\n\n    let ux = reinterpret<u64>(x);\n    let uy = reinterpret<u64>(y);\n    ux &= 0x7FFFFFFFFFFFFFFF;\n    uy &= 0x7FFFFFFFFFFFFFFF;\n    if (ux < uy) {\n      let ut = ux;\n      ux = uy;\n      uy = ut;\n    }\n    let ex = i32(ux >> 52);\n    let ey = i32(uy >> 52);\n    y = reinterpret<f64>(uy);\n    if (ey == 0x7FF) return y;\n    x = reinterpret<f64>(ux);\n    if (ex == 0x7FF || uy == 0) return x;\n    if (ex - ey > 64) return x + y;\n    let z = 1.0;\n    if (ex > 0x3FF + 510) {\n      z  = Ox1p700;\n      x *= Ox1p_700;\n      y *= Ox1p_700;\n    } else if (ey < 0x3FF - 450) {\n      z  = Ox1p_700;\n      x *= Ox1p700;\n      y *= Ox1p700;\n    }\n    let c = x * SPLIT;\n    let h = x - c + c;\n    let l = x - h;\n    let hx = x * x;\n    let lx = h * h - hx + (2 * h + l) * l;\n    c = y * SPLIT;\n    h = y - c + c;\n    l = y - h;\n    let hy = y * y;\n    let ly = h * h - hy + (2 * h + l) * l;\n    return z * builtin_sqrt(ly + lx + hy + hx);\n  }\n\n  export function imul(x: f64, y: f64): f64 {\n    /*\n     * Wasm (MVP) and JS have different approaches for double->int conversions.\n     *\n     * For emulate JS conversion behavior and avoid trapping from wasm we should modulate by MAX_INT\n     * our float-point arguments before actual convertion to integers.\n     */\n    if (!isFinite(x + y)) return 0;\n    return dtoi32(x) * dtoi32(y);\n  }\n\n  export function log(x: f64): f64 { // see: musl/src/math/log.c and SUN COPYRIGHT NOTICE above\n    if (ASC_SHRINK_LEVEL < 1) {\n      return log_lut(x);\n    } else {\n      const\n        ln2_hi = reinterpret<f64>(0x3FE62E42FEE00000), // 6.93147180369123816490e-01\n        ln2_lo = reinterpret<f64>(0x3DEA39EF35793C76), // 1.90821492927058770002e-10\n        Lg1    = reinterpret<f64>(0x3FE5555555555593), // 6.666666666666735130e-01\n        Lg2    = reinterpret<f64>(0x3FD999999997FA04), // 3.999999999940941908e-01\n        Lg3    = reinterpret<f64>(0x3FD2492494229359), // 2.857142874366239149e-01\n        Lg4    = reinterpret<f64>(0x3FCC71C51D8E78AF), // 2.222219843214978396e-01\n        Lg5    = reinterpret<f64>(0x3FC7466496CB03DE), // 1.818357216161805012e-01\n        Lg6    = reinterpret<f64>(0x3FC39A09D078C69F), // 1.531383769920937332e-01\n        Lg7    = reinterpret<f64>(0x3FC2F112DF3E5244), // 1.479819860511658591e-01\n        Ox1p54 = reinterpret<f64>(0x4350000000000000); // 0x1p54\n\n      let u = reinterpret<u64>(x);\n      let hx = u32(u >> 32);\n      let k = 0;\n      let sign = hx >> 31;\n      if (sign || hx < 0x00100000) {\n        if (u << 1 == 0) return -1 / (x * x);\n        if (sign) return (x - x) / 0.0;\n        k -= 54;\n        x *= Ox1p54;\n        u = reinterpret<u64>(x);\n        hx = u32(u >> 32);\n      } else if (hx >= 0x7FF00000) {\n        return x;\n      } else if (hx == 0x3FF00000 && u << 32 == 0) {\n        return 0;\n      }\n      hx += 0x3FF00000 - 0x3FE6A09E;\n      k += (<i32>hx >> 20) - 0x3FF;\n      hx = (hx & 0x000FFFFF) + 0x3FE6A09E;\n      u = <u64>hx << 32 | (u & 0xFFFFFFFF);\n      x = reinterpret<f64>(u);\n      let f = x - 1.0;\n      let hfsq = 0.5 * f * f;\n      let s = f / (2.0 + f);\n      let z = s * s;\n      let w = z * z;\n      let t1 = w * (Lg2 + w * (Lg4 + w * Lg6));\n      let t2 = z * (Lg1 + w * (Lg3 + w * (Lg5 + w * Lg7)));\n      let r = t2 + t1;\n      let dk = <f64>k;\n      return s * (hfsq + r) + dk * ln2_lo - hfsq + f + dk * ln2_hi;\n    }\n  }\n\n  export function log10(x: f64): f64 { // see: musl/src/math/log10.c and SUN COPYRIGHT NOTICE above\n    const\n      ivln10hi  = reinterpret<f64>(0x3FDBCB7B15200000), // 4.34294481878168880939e-01\n      ivln10lo  = reinterpret<f64>(0x3DBB9438CA9AADD5), // 2.50829467116452752298e-11\n      log10_2hi = reinterpret<f64>(0x3FD34413509F6000), // 3.01029995663611771306e-01\n      log10_2lo = reinterpret<f64>(0x3D59FEF311F12B36), // 3.69423907715893078616e-13\n      Lg1       = reinterpret<f64>(0x3FE5555555555593), // 6.666666666666735130e-01\n      Lg2       = reinterpret<f64>(0x3FD999999997FA04), // 3.999999999940941908e-01\n      Lg3       = reinterpret<f64>(0x3FD2492494229359), // 2.857142874366239149e-01\n      Lg4       = reinterpret<f64>(0x3FCC71C51D8E78AF), // 2.222219843214978396e-01\n      Lg5       = reinterpret<f64>(0x3FC7466496CB03DE), // 1.818357216161805012e-01\n      Lg6       = reinterpret<f64>(0x3FC39A09D078C69F), // 1.531383769920937332e-01\n      Lg7       = reinterpret<f64>(0x3FC2F112DF3E5244), // 1.479819860511658591e-01\n      Ox1p54    = reinterpret<f64>(0x4350000000000000); // 0x1p54\n\n    let u = reinterpret<u64>(x);\n    let hx = u32(u >> 32);\n    let k = 0;\n    let sign = hx >> 31;\n    if (sign || hx < 0x00100000) {\n      if (u << 1 == 0) return -1 / (x * x);\n      if (sign) return (x - x) / 0.0;\n      k -= 54;\n      x *= Ox1p54;\n      u = reinterpret<u64>(x);\n      hx = u32(u >> 32);\n    } else if (hx >= 0x7FF00000) {\n      return x;\n    } else if (hx == 0x3FF00000 && u << 32 == 0) {\n      return 0;\n    }\n    hx += 0x3FF00000 - 0x3FE6A09E;\n    k += i32(hx >> 20) - 0x3FF;\n    hx = (hx & 0x000FFFFF) + 0x3FE6A09E;\n    u = <u64>hx << 32 | (u & 0xFFFFFFFF);\n    x = reinterpret<f64>(u);\n    let f = x - 1.0;\n    let hfsq = 0.5 * f * f;\n    let s = f / (2.0 + f);\n    let z = s * s;\n    let w = z * z;\n    let t1 = w * (Lg2 + w * (Lg4 + w * Lg6));\n    let t2 = z * (Lg1 + w * (Lg3 + w * (Lg5 + w * Lg7)));\n    let r = t2 + t1;\n    let hi = f - hfsq;\n    u = reinterpret<u64>(hi);\n    u &= 0xFFFFFFFF00000000;\n    hi = reinterpret<f64>(u);\n    let lo = f - hi - hfsq + s * (hfsq + r);\n    let val_hi = hi * ivln10hi;\n    let dk = <f64>k;\n    let y = dk * log10_2hi;\n    let val_lo = dk * log10_2lo + (lo + hi) * ivln10lo + lo * ivln10hi;\n    w = y + val_hi;\n    val_lo += (y - w) + val_hi;\n    return val_lo + w;\n  }\n\n  export function log1p(x: f64): f64 { // see: musl/src/math/log1p.c and SUN COPYRIGHT NOTICE above\n    const\n      ln2_hi = reinterpret<f64>(0x3FE62E42FEE00000), // 6.93147180369123816490e-01\n      ln2_lo = reinterpret<f64>(0x3DEA39EF35793C76), // 1.90821492927058770002e-10\n      Lg1    = reinterpret<f64>(0x3FE5555555555593), // 6.666666666666735130e-01\n      Lg2    = reinterpret<f64>(0x3FD999999997FA04), // 3.999999999940941908e-01\n      Lg3    = reinterpret<f64>(0x3FD2492494229359), // 2.857142874366239149e-01\n      Lg4    = reinterpret<f64>(0x3FCC71C51D8E78AF), // 2.222219843214978396e-01\n      Lg5    = reinterpret<f64>(0x3FC7466496CB03DE), // 1.818357216161805012e-01\n      Lg6    = reinterpret<f64>(0x3FC39A09D078C69F), // 1.531383769920937332e-01\n      Lg7    = reinterpret<f64>(0x3FC2F112DF3E5244); // 1.479819860511658591e-01\n\n    let u = reinterpret<u64>(x);\n    let hx = u32(u >> 32);\n    let k = 1;\n    let c = 0.0, f = 0.0;\n    if (hx < 0x3FDA827A || bool(hx >> 31)) {\n      if (hx >= 0xBFF00000) {\n        if (x == -1) return x / 0.0;\n        return (x - x) / 0.0;\n      }\n      if (hx << 1 < 0x3CA00000 << 1) return x;\n      if (hx <= 0xBFD2BEC4) {\n        k = 0;\n        c = 0;\n        f = x;\n      }\n    } else if (hx >= 0x7FF00000) return x;\n    if (k) {\n      u = reinterpret<u64>(1 + x);\n      let hu = u32(u >> 32);\n      hu += 0x3FF00000 - 0x3FE6A09E;\n      k = i32(hu >> 20) - 0x3FF;\n      if (k < 54) {\n        let uf = reinterpret<f64>(u);\n        c = k >= 2 ? 1 - (uf - x) : x - (uf - 1);\n        c /= uf;\n      } else c = 0;\n      hu = (hu & 0x000FFFFF) + 0x3FE6A09E;\n      u = <u64>hu << 32 | (u & 0xFFFFFFFF);\n      f = reinterpret<f64>(u) - 1;\n    }\n    let hfsq = 0.5 * f * f;\n    let s = f / (2.0 + f);\n    let z = s * s;\n    let w = z * z;\n    let t1 = w * (Lg2 + w * (Lg4 + w * Lg6));\n    let t2 = z * (Lg1 + w * (Lg3 + w * (Lg5 + w * Lg7)));\n    let r = t2 + t1;\n    let dk = <f64>k;\n    return s * (hfsq + r) + (dk * ln2_lo + c) - hfsq + f + dk * ln2_hi;\n  }\n\n  export function log2(x: f64): f64 { // see: musl/src/math/log2.c and SUN COPYRIGHT NOTICE above\n    if (ASC_SHRINK_LEVEL < 1) {\n      return log2_lut(x);\n    } else {\n      const\n        ivln2hi = reinterpret<f64>(0x3FF7154765200000), // 1.44269504072144627571e+00\n        ivln2lo = reinterpret<f64>(0x3DE705FC2EEFA200), // 1.67517131648865118353e-10\n        Lg1     = reinterpret<f64>(0x3FE5555555555593), // 6.666666666666735130e-01\n        Lg2     = reinterpret<f64>(0x3FD999999997FA04), // 3.999999999940941908e-01\n        Lg3     = reinterpret<f64>(0x3FD2492494229359), // 2.857142874366239149e-01\n        Lg4     = reinterpret<f64>(0x3FCC71C51D8E78AF), // 2.222219843214978396e-01\n        Lg5     = reinterpret<f64>(0x3FC7466496CB03DE), // 1.818357216161805012e-01\n        Lg6     = reinterpret<f64>(0x3FC39A09D078C69F), // 1.531383769920937332e-01\n        Lg7     = reinterpret<f64>(0x3FC2F112DF3E5244), // 1.479819860511658591e-01\n        Ox1p54  = reinterpret<f64>(0x4350000000000000); // 1p54\n\n      let u = reinterpret<u64>(x);\n      let hx = u32(u >> 32);\n      let k = 0;\n      let sign = hx >> 31;\n      if (sign || hx < 0x00100000) {\n        if (u << 1 == 0) return -1 / (x * x);\n        if (sign) return (x - x) / 0.0;\n        k -= 54;\n        x *= Ox1p54;\n        u = reinterpret<u64>(x);\n        hx = u32(u >> 32);\n      } else if (hx >= 0x7FF00000) {\n        return x;\n      } else if (hx == 0x3FF00000 && u << 32 == 0) {\n        return 0;\n      }\n      hx += 0x3FF00000 - 0x3FE6A09E;\n      k += i32(hx >> 20) - 0x3FF;\n      hx = (hx & 0x000FFFFF) + 0x3FE6A09E;\n      u = <u64>hx << 32 | (u & 0xFFFFFFFF);\n      x = reinterpret<f64>(u);\n      let f = x - 1.0;\n      let hfsq = 0.5 * f * f;\n      let s = f / (2.0 + f);\n      let z = s * s;\n      let w = z * z;\n      let t1 = w * (Lg2 + w * (Lg4 + w * Lg6));\n      let t2 = z * (Lg1 + w * (Lg3 + w * (Lg5 + w * Lg7)));\n      let r = t2 + t1;\n      let hi = f - hfsq;\n      u = reinterpret<u64>(hi);\n      u &= 0xFFFFFFFF00000000;\n      hi = reinterpret<f64>(u);\n      let lo = f - hi - hfsq + s * (hfsq + r);\n      let val_hi = hi * ivln2hi;\n      let val_lo = (lo + hi) * ivln2lo + lo * ivln2hi;\n      let y = <f64>k;\n      w = y + val_hi;\n      val_lo += (y - w) + val_hi;\n      val_hi = w;\n      return val_lo + val_hi;\n    }\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function max(value1: f64, value2: f64): f64 {\n    return builtin_max<f64>(value1, value2);\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function min(value1: f64, value2: f64): f64 {\n    return builtin_min<f64>(value1, value2);\n  }\n\n  export function pow(x: f64, y: f64): f64 { // see: musl/src/math/pow.c and SUN COPYRIGHT NOTICE above\n    // TODO: remove this fast pathes after introduced own mid-end IR with \"stdlib call simplify\" transforms\n    if (builtin_abs<f64>(y) <= 2) {\n      if (y == 2.0) return x * x;\n      if (y == 0.5) {\n        return select<f64>(\n          builtin_abs<f64>(builtin_sqrt<f64>(x)),\n          Infinity,\n          x != -Infinity\n        );\n      }\n      if (y == -1.0) return 1 / x;\n      if (y == 1.0) return x;\n      if (y == 0.0) return 1.0;\n    }\n    if (ASC_SHRINK_LEVEL < 1) {\n      return pow_lut(x, y);\n    } else {\n      const\n        dp_h1   = reinterpret<f64>(0x3FE2B80340000000), //  5.84962487220764160156e-01\n        dp_l1   = reinterpret<f64>(0x3E4CFDEB43CFD006), //  1.35003920212974897128e-08\n        two53   = reinterpret<f64>(0x4340000000000000), //  9007199254740992.0\n        huge    = reinterpret<f64>(0x7E37E43C8800759C), //  1e+300\n        tiny    = reinterpret<f64>(0x01A56E1FC2F8F359), //  1e-300\n        L1      = reinterpret<f64>(0x3FE3333333333303), //  5.99999999999994648725e-01\n        L2      = reinterpret<f64>(0x3FDB6DB6DB6FABFF), //  4.28571428578550184252e-01\n        L3      = reinterpret<f64>(0x3FD55555518F264D), //  3.33333329818377432918e-01\n        L4      = reinterpret<f64>(0x3FD17460A91D4101), //  2.72728123808534006489e-01\n        L5      = reinterpret<f64>(0x3FCD864A93C9DB65), //  2.30660745775561754067e-01\n        L6      = reinterpret<f64>(0x3FCA7E284A454EEF), //  2.06975017800338417784e-01\n        P1      = reinterpret<f64>(0x3FC555555555553E), //  1.66666666666666019037e-01\n        P2      = reinterpret<f64>(0xBF66C16C16BEBD93), // -2.77777777770155933842e-03\n        P3      = reinterpret<f64>(0x3F11566AAF25DE2C), //  6.61375632143793436117e-05\n        P4      = reinterpret<f64>(0xBEBBBD41C5D26BF1), // -1.65339022054652515390e-06\n        P5      = reinterpret<f64>(0x3E66376972BEA4D0), //  4.13813679705723846039e-08\n        lg2     = reinterpret<f64>(0x3FE62E42FEFA39EF), //  6.93147180559945286227e-01\n        lg2_h   = reinterpret<f64>(0x3FE62E4300000000), //  6.93147182464599609375e-01\n        lg2_l   = reinterpret<f64>(0xBE205C610CA86C39), // -1.90465429995776804525e-09\n        ovt     = reinterpret<f64>(0x3C971547652B82FE), //  8.0085662595372944372e-017\n        cp      = reinterpret<f64>(0x3FEEC709DC3A03FD), //  9.61796693925975554329e-01\n        cp_h    = reinterpret<f64>(0x3FEEC709E0000000), //  9.61796700954437255859e-01\n        cp_l    = reinterpret<f64>(0xBE3E2FE0145B01F5), // -7.02846165095275826516e-09\n        ivln2   = reinterpret<f64>(0x3FF71547652B82FE), //  1.44269504088896338700e+00\n        ivln2_h = reinterpret<f64>(0x3FF7154760000000), //  1.44269502162933349609e+00\n        ivln2_l = reinterpret<f64>(0x3E54AE0BF85DDF44), //  1.92596299112661746887e-08\n        inv3    = reinterpret<f64>(0x3FD5555555555555); //  0.3333333333333333333333\n\n      let u_ = reinterpret<u64>(x);\n      let hx = i32(u_ >> 32);\n      let lx = <u32>u_;\n      u_ = reinterpret<u64>(y);\n      let hy = i32(u_ >> 32);\n      let ly = <u32>u_;\n      let ix = hx & 0x7FFFFFFF;\n      let iy = hy & 0x7FFFFFFF;\n      if ((iy | ly) == 0) return 1.0; // x**0 = 1, even if x is NaN\n      // if (hx == 0x3FF00000 && lx == 0) return 1.0; // C: 1**y = 1, even if y is NaN, JS: NaN\n      if ( // NaN if either arg is NaN\n        ix > 0x7FF00000 || (ix == 0x7FF00000 && lx != 0) ||\n        iy > 0x7FF00000 || (iy == 0x7FF00000 && ly != 0)\n      ) return x + y;\n      let yisint = 0, k: i32;\n      if (hx < 0) {\n        if (iy >= 0x43400000) yisint = 2;\n        else if (iy >= 0x3FF00000) {\n          k = (iy >> 20) - 0x3FF;\n          let offset = select<u32>(52, 20, k > 20) - k;\n          let Ly = select<u32>(ly, iy, k > 20);\n          let jj = Ly >> offset;\n          if ((jj << offset) == Ly) yisint = 2 - (jj & 1);\n        }\n      }\n      if (ly == 0) {\n        if (iy == 0x7FF00000) { // y is +-inf\n          if (((ix - 0x3FF00000) | lx) == 0) return NaN; // C: (-1)**+-inf is 1, JS: NaN\n          else if (ix >= 0x3FF00000) return hy >= 0 ? y : 0.0; // (|x|>1)**+-inf = inf,0\n          else return hy >= 0 ? 0.0 : -y; // (|x|<1)**+-inf = 0,inf\n        }\n        if (iy == 0x3FF00000) {\n          if (hy >= 0) return x;\n          return 1 / x;\n        }\n        if (hy == 0x40000000) return x * x;\n        if (hy == 0x3FE00000) {\n          if (hx >= 0) return builtin_sqrt(x);\n        }\n      }\n      let ax = builtin_abs<f64>(x), z: f64;\n      if (lx == 0) {\n        if (ix == 0 || ix == 0x7FF00000 || ix == 0x3FF00000) {\n          z = ax;\n          if (hy < 0) z = 1.0 / z;\n          if (hx < 0) {\n            if (((ix - 0x3FF00000) | yisint) == 0) {\n              let d = z - z;\n              z = d / d;\n            } else if (yisint == 1) z = -z;\n          }\n          return z;\n        }\n      }\n      let s = 1.0;\n      if (hx < 0) {\n        if (yisint == 0) {\n          let d = x - x;\n          return d / d;\n        }\n        if (yisint == 1) s = -1.0;\n      }\n      let t1: f64, t2: f64, p_h: f64, p_l: f64, r: f64, t: f64, u: f64, v: f64, w: f64;\n      let j: i32, n: i32;\n      if (iy > 0x41E00000) {\n        if (iy > 0x43F00000) {\n          if (ix <= 0x3FEFFFFF) return hy < 0 ? huge * huge : tiny * tiny;\n          if (ix >= 0x3FF00000) return hy > 0 ? huge * huge : tiny * tiny;\n        }\n        if (ix < 0x3FEFFFFF) return hy < 0 ? s * huge * huge : s * tiny * tiny;\n        if (ix > 0x3FF00000) return hy > 0 ? s * huge * huge : s * tiny * tiny;\n        t = ax - 1.0;\n        w = (t * t) * (0.5 - t * (inv3 - t * 0.25));\n        u = ivln2_h * t;\n        v = t * ivln2_l - w * ivln2;\n        t1 = u + v;\n        t1 = reinterpret<f64>(reinterpret<u64>(t1) & 0xFFFFFFFF00000000);\n        t2 = v - (t1 - u);\n      } else {\n        let ss: f64, s2: f64, s_h: f64, s_l: f64, t_h: f64, t_l: f64;\n        n = 0;\n        if (ix < 0x00100000) {\n          ax *= two53;\n          n -= 53;\n          ix = <u32>(reinterpret<u64>(ax) >> 32);\n        }\n        n += (ix >> 20) - 0x3FF;\n        j = ix & 0x000FFFFF;\n        ix = j | 0x3FF00000;\n        if (j <= 0x3988E) k = 0;\n        else if (j < 0xBB67A) k = 1;\n        else {\n          k = 0;\n          n += 1;\n          ix -= 0x00100000;\n        }\n        ax = reinterpret<f64>(reinterpret<u64>(ax) & 0xFFFFFFFF | (<u64>ix << 32));\n        let bp = select<f64>(1.5, 1.0, k); // k ? 1.5 : 1.0\n        u = ax - bp;\n        v = 1.0 / (ax + bp);\n        ss = u * v;\n        s_h = ss;\n        s_h = reinterpret<f64>(reinterpret<u64>(s_h) & 0xFFFFFFFF00000000);\n        t_h = reinterpret<f64>(u64(((ix >> 1) | 0x20000000) + 0x00080000 + (k << 18)) << 32);\n        t_l = ax - (t_h - bp);\n        s_l = v * ((u - s_h * t_h) - s_h * t_l);\n        s2 = ss * ss;\n        r = s2 * s2 * (L1 + s2 * (L2 + s2 * (L3 + s2 * (L4 + s2 * (L5 + s2 * L6)))));\n        r += s_l * (s_h + ss);\n        s2 = s_h * s_h;\n        t_h = 3.0 + s2 + r;\n        t_h = reinterpret<f64>(reinterpret<u64>(t_h) & 0xFFFFFFFF00000000);\n        t_l = r - ((t_h - 3.0) - s2);\n        u = s_h * t_h;\n        v = s_l * t_h + t_l * ss;\n        p_h = u + v;\n        p_h = reinterpret<f64>(reinterpret<u64>(p_h) & 0xFFFFFFFF00000000);\n        p_l = v - (p_h - u);\n        let z_h = cp_h * p_h;\n        let dp_l = select<f64>(dp_l1, 0.0, k);\n        let z_l = cp_l * p_h + p_l * cp + dp_l;\n        t = <f64>n;\n        let dp_h = select<f64>(dp_h1, 0.0, k);\n        t1 = ((z_h + z_l) + dp_h) + t;\n        t1 = reinterpret<f64>(reinterpret<u64>(t1) & 0xFFFFFFFF00000000);\n        t2 = z_l - (((t1 - t) - dp_h) - z_h);\n      }\n      let y1 = y;\n      y1 = reinterpret<f64>(reinterpret<u64>(y1) & 0xFFFFFFFF00000000);\n      p_l = (y - y1) * t1 + y * t2;\n      p_h = y1 * t1;\n      z = p_l + p_h;\n      u_ = reinterpret<u64>(z);\n      j = u32(u_ >> 32);\n      let i = <i32>u_;\n      if (j >= 0x40900000) {\n        if (((j - 0x40900000) | i) != 0) return s * huge * huge;\n        if (p_l + ovt > z - p_h) return s * huge * huge;\n      } else if ((j & 0x7FFFFFFF) >= 0x4090CC00) {\n        if (((j - 0xC090CC00) | i) != 0) return s * tiny * tiny;\n        if (p_l <= z - p_h) return s * tiny * tiny;\n      }\n      i = j & 0x7FFFFFFF;\n      k = (i >> 20) - 0x3FF;\n      n = 0;\n      if (i > 0x3FE00000) {\n        n = j + (0x00100000 >> (k + 1));\n        k = ((n & 0x7FFFFFFF) >> 20) - 0x3FF;\n        t = 0.0;\n        t = reinterpret<f64>(u64(n & ~(0x000FFFFF >> k)) << 32);\n        n = ((n & 0x000FFFFF) | 0x00100000) >> (20 - k);\n        if (j < 0) n = -n;\n        p_h -= t;\n      }\n      t = p_l + p_h;\n      t = reinterpret<f64>(reinterpret<u64>(t) & 0xFFFFFFFF00000000);\n      u = t * lg2_h;\n      v = (p_l - (t - p_h)) * lg2 + t * lg2_l;\n      z = u + v;\n      w = v - (z - u);\n      t = z * z;\n      t1 = z - t * (P1 + t * (P2 + t * (P3 + t * (P4 + t * P5))));\n      r = (z * t1) / (t1 - 2.0) - (w + z * w);\n      z = 1.0 - (r - z);\n      j = u32(reinterpret<u64>(z) >> 32);\n      j += n << 20;\n      if ((j >> 20) <= 0) z = scalbn(z, n);\n      else z = reinterpret<f64>(reinterpret<u64>(z) & 0xFFFFFFFF | (<u64>j << 32));\n      return s * z;\n    }\n  }\n\n  export function seedRandom(value: i64): void {\n    // Instead zero seed use golden ratio:\n    // phi = (1 + sqrt(5)) / 2\n    // trunc(2^64 / phi) = 0x9e3779b97f4a7c15\n    if (value == 0) value = 0x9e3779b97f4a7c15;\n    random_state0_64 = murmurHash3(value);\n    random_state1_64 = murmurHash3(~random_state0_64);\n    random_state0_32 = splitMix32(<u32>value);\n    random_state1_32 = splitMix32(random_state0_32);\n    random_seeded = true;\n  }\n\n  export function random(): f64 { // see: v8/src/base/utils/random-number-generator.cc\n    if (!random_seeded) seedRandom(reinterpret<i64>(seed()));\n    let s1 = random_state0_64;\n    let s0 = random_state1_64;\n    random_state0_64 = s0;\n    s1 ^= s1 << 23;\n    s1 ^= s1 >> 17;\n    s1 ^= s0;\n    s1 ^= s0 >> 26;\n    random_state1_64 = s1;\n    let r = (s0 >> 12) | 0x3FF0000000000000;\n    return reinterpret<f64>(r) - 1;\n  }\n\n  export function round(x: f64): f64 {\n    if (ASC_SHRINK_LEVEL > 0) {\n      return builtin_ceil<f64>(x) - f64(builtin_ceil<f64>(x) - 0.5 > x);\n    } else {\n      let roundUp = builtin_ceil<f64>(x);\n      return select<f64>(roundUp, roundUp - 1.0, roundUp - 0.5 <= x);\n    }\n  }\n\n  export function sign(x: f64): f64 {\n    if (ASC_SHRINK_LEVEL > 0) {\n      return select<f64>(builtin_copysign<f64>(1, x), x, builtin_abs(x) > 0);\n    } else {\n      return select<f64>(1, select<f64>(-1, x, x < 0), x > 0);\n    }\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function signbit(x: f64): bool {\n    return bool(reinterpret<u64>(x) >>> 63);\n  }\n\n  export function sin(x: f64): f64 { // see: musl/src/math/sin.c\n    let u  = reinterpret<u64>(x);\n    let ux = u32(u >> 32);\n    let sign = ux >> 31;\n\n    ux &= 0x7FFFFFFF;\n\n    // |x| ~< pi/4\n    if (ux <= 0x3FE921FB) {\n      if (ux < 0x3E500000) { // |x| < 2**-26\n        return x;\n      }\n      return sin_kern(x, 0.0, 0);\n    }\n\n    // sin(Inf or NaN) is NaN\n    if (ux >= 0x7FF00000) return x - x;\n\n    // argument reduction needed\n    let n  = rempio2(x, u, sign);\n    let y0 = rempio2_y0;\n    let y1 = rempio2_y1;\n\n    x = n & 1 ? cos_kern(y0, y1) : sin_kern(y0, y1, 1);\n    return n & 2 ? -x : x;\n  }\n\n  export function sinh(x: f64): f64 { // see: musl/src/math/sinh.c\n    let u = reinterpret<u64>(x) & 0x7FFFFFFFFFFFFFFF;\n    let a = reinterpret<f64>(u);\n    let w = u32(u >> 32);\n    let h = builtin_copysign(0.5, x);\n    if (w < 0x40862E42) {\n      let t = expm1(a);\n      if (w < 0x3FF00000) {\n        if (w < 0x3FF00000 - (26 << 20)) return x;\n        return h * (2 * t - t * t / (t + 1));\n      }\n      return h * (t + t / (t + 1));\n    }\n    return expo2(a, 2 * h);\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function sqrt(x: f64): f64 {\n    return builtin_sqrt<f64>(x);\n  }\n\n  export function tan(x: f64): f64 { // see: musl/src/math/tan.c\n    let u = reinterpret<u64>(x);\n    let ux = u32(u >> 32);\n    let sign = ux >>> 31;\n\n    ux &= 0x7FFFFFFF;\n\n    // |x| ~< pi/4\n    if (ux <= 0x3FE921FB) {\n      if (ux < 0x3E400000) { // |x| < 2**-27\n        return x;\n      }\n      return tan_kern(x, 0.0, 1);\n    }\n\n    // tan(Inf or NaN) is NaN\n    if (ux >= 0x7FF00000) return x - x;\n\n    let n = rempio2(x, u, sign);\n    return tan_kern(rempio2_y0, rempio2_y1, 1 - ((n & 1) << 1));\n  }\n\n  export function tanh(x: f64): f64 { // see: musl/src/math/tanh.c\n    let u = reinterpret<u64>(x);\n    u &= 0x7FFFFFFFFFFFFFFF;\n    let y = reinterpret<f64>(u);\n    let w = u32(u >> 32);\n    let t: f64;\n    if (w > 0x3FE193EA) {\n      if (w > 0x40340000) {\n        t = 1 - 0 / y;\n      } else {\n        t = expm1(2 * y);\n        t = 1 - 2 / (t + 2);\n      }\n    } else if (w > 0x3FD058AE) {\n      t = expm1(2 * y);\n      t = t / (t + 2);\n    } else if (w >= 0x00100000) {\n      t = expm1(-2 * y);\n      t = -t / (t + 2);\n    } else t = y;\n    return builtin_copysign<f64>(t, x);\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function trunc(x: f64): f64 {\n    return builtin_trunc<f64>(x);\n  }\n\n  export function scalbn(x: f64, n: i32): f64 { // see: https://git.musl-libc.org/cgit/musl/tree/src/math/scalbn.c\n    const\n      Ox1p53    = reinterpret<f64>(0x4340000000000000),\n      Ox1p1023  = reinterpret<f64>(0x7FE0000000000000),\n      Ox1p_1022 = reinterpret<f64>(0x0010000000000000);\n\n    let y = x;\n    if (n > 1023) {\n      y *= Ox1p1023;\n      n -= 1023;\n      if (n > 1023) {\n        y *= Ox1p1023;\n        n = builtin_min<i32>(n - 1023, 1023);\n      }\n    } else if (n < -1022) {\n      // make sure final n < -53 to avoid double\n      // rounding in the subnormal range\n      y *= Ox1p_1022 * Ox1p53;\n      n += 1022 - 53;\n      if (n < -1022) {\n        y *= Ox1p_1022 * Ox1p53;\n        n = builtin_max<i32>(n + 1022 - 53, -1022);\n      }\n    }\n    return y * reinterpret<f64>(<u64>(0x3FF + n) << 52);\n  }\n\n  export function mod(x: f64, y: f64): f64 { // see: musl/src/math/fmod.c\n    if (builtin_abs<f64>(y) == 1.0) {\n      // x % 1, x % -1  ==>  sign(x) * abs(x - 1.0 * trunc(x / 1.0))\n      // TODO: move this rule to compiler's optimization pass.\n      // It could be apply for any x % C_pot, where \"C_pot\" is pow of two const.\n      return builtin_copysign<f64>(x - builtin_trunc<f64>(x), x);\n    }\n    let ux = reinterpret<u64>(x);\n    let uy = reinterpret<u64>(y);\n    let ex = i64(ux >> 52 & 0x7FF);\n    let ey = i64(uy >> 52 & 0x7FF);\n    let sx = ux >> 63;\n    let uy1 = uy << 1;\n    if (uy1 == 0 || ex == 0x7FF || isNaN<f64>(y)) {\n      let m = x * y;\n      return m / m;\n    }\n    let ux1 = ux << 1;\n    if (ux1 <= uy1) {\n      return x * f64(ux1 != uy1);\n    }\n    if (!ex) {\n      ex -= builtin_clz<i64>(ux << 12);\n      ux <<= 1 - ex;\n    } else {\n      ux &= u64(-1) >> 12;\n      ux |= 1 << 52;\n    }\n    if (!ey) {\n      ey -= builtin_clz<i64>(uy << 12);\n      uy <<= 1 - ey;\n    } else {\n      uy &= u64(-1) >> 12;\n      uy |= 1 << 52;\n    }\n    while (ex > ey) {\n      if (ux >= uy) {\n        if (ux == uy) return 0 * x;\n        ux -= uy;\n      }\n      ux <<= 1;\n      --ex;\n    }\n    if (ux >= uy) {\n      if (ux == uy) return 0 * x;\n      ux -= uy;\n    }\n    // for (; !(ux >> 52); ux <<= 1) --ex;\n    let shift = builtin_clz<i64>(ux << 11);\n    ex -= shift;\n    ux <<= shift;\n    if (ex > 0) {\n      ux -= 1 << 52;\n      ux |= ex << 52;\n    } else {\n      ux >>= -ex + 1;\n    }\n    return reinterpret<f64>(ux | (sx << 63));\n  }\n\n  export function rem(x: f64, y: f64): f64 { // see: musl/src/math/remquo.c\n    let ux = reinterpret<u64>(x);\n    let uy = reinterpret<u64>(y);\n    let ex = i64(ux >> 52 & 0x7FF);\n    let ey = i64(uy >> 52 & 0x7FF);\n    if (uy << 1 == 0 || ex == 0x7FF || isNaN(y)) {\n      let m = x * y;\n      return m / m;\n    }\n    if (ux << 1 == 0) return x;\n    let uxi = ux;\n    if (!ex) {\n      ex -= builtin_clz<i64>(uxi << 12);\n      uxi <<= 1 - ex;\n    } else {\n      uxi &= u64(-1) >> 12;\n      uxi |= 1 << 52;\n    }\n    if (!ey) {\n      ey -= builtin_clz<i64>(uy << 12);\n      uy <<= 1 - ey;\n    } else {\n      uy &= u64(-1) >> 12;\n      uy |= 1 << 52;\n    }\n    let q: u32 = 0;\n    do {\n      if (ex < ey) {\n        if (ex + 1 == ey) break; // goto end\n        return x;\n      }\n      while (ex > ey) {\n        if (uxi >= uy) {\n          uxi -= uy;\n          ++q;\n        }\n        uxi <<= 1;\n        q <<= 1;\n        --ex;\n      }\n      if (uxi >= uy) {\n        uxi -= uy;\n        ++q;\n      }\n      if (uxi == 0) ex = -60;\n      else {\n        let shift = builtin_clz<i64>(uxi << 11);\n        ex -= shift;\n        uxi <<= shift;\n      }\n      break;\n    } while (false);\n    // end:\n    if (ex > 0) {\n      uxi -= 1 << 52;\n      uxi |= ex << 52;\n    } else {\n      uxi >>= -ex + 1;\n    }\n    x = reinterpret<f64>(uxi);\n    y = builtin_abs<f64>(y);\n    let x2 = x + x;\n    if (ex == ey || (ex + 1 == ey && (x2 > y || (x2 == y && <bool>(q & 1))))) {\n      x -= y;\n      // ++q;\n    }\n    return <i64>ux < 0 ? -x : x;\n  }\n\n  export function sincos(x: f64): void { // see: musl/tree/src/math/sincos.c\n    let u = reinterpret<u64>(x);\n    let ux = u32(u >> 32);\n    let sign = ux >> 31;\n    ux &= 0x7FFFFFFF;\n\n    if (ux <= 0x3FE921FB) {  // |x| ~<= π/4\n      if (ux < 0x3E46A09E) { // if |x| < 2**-27 * sqrt(2)\n        sincos_sin = x;\n        sincos_cos = 1;\n        return;\n      }\n      sincos_sin = sin_kern(x, 0, 0);\n      sincos_cos = cos_kern(x, 0);\n      return;\n    }\n    // sin(Inf or NaN) is NaN\n    if (ux >= 0x7F800000) {\n      let xx = x - x;\n      sincos_sin = xx;\n      sincos_cos = xx;\n      return;\n    }\n    // general argument reduction needed\n    let n = rempio2(x, u, sign);\n    let y0 = rempio2_y0;\n    let y1 = rempio2_y1;\n    let s = sin_kern(y0, y1, 1);\n    let c = cos_kern(y0, y1);\n    let sin = s, cos = c;\n    if (n & 1) {\n      sin =  c;\n      cos = -s;\n    }\n    if (n & 2) {\n      sin = -sin;\n      cos = -cos;\n    }\n    sincos_sin = sin;\n    sincos_cos = cos;\n  }\n}\n\n// @ts-ignore: decorator\n@lazy let rempio2f_y: f64;\n\n// @ts-ignore: decorator\n@lazy @inline const PIO2F_TABLE = memory.data<u64>([\n  0xA2F9836E4E441529,\n  0xFC2757D1F534DDC0,\n  0xDB6295993C439041,\n  0xFE5163ABDEBBC561\n]);\n\nfunction Rf(z: f32): f32 { // Rational approximation of (asin(x)-x)/x^3\n  const                    // see: musl/src/math/asinf.c and SUN COPYRIGHT NOTICE above\n    pS0 = reinterpret<f32>(0x3E2AAA75), //  1.6666586697e-01f\n    pS1 = reinterpret<f32>(0xBD2F13BA), // -4.2743422091e-02f\n    pS2 = reinterpret<f32>(0xBC0DD36B), // -8.6563630030e-03f\n    qS1 = reinterpret<f32>(0xBF34E5AE); // -7.0662963390e-01f\n\n  let p = z * (pS0 + z * (pS1 + z * pS2));\n  let q: f32 = 1 + z * qS1;\n  return p / q;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction expo2f(x: f32, sign: f32): f32 { // exp(x)/2 for x >= log(DBL_MAX)\n  const                                // see: musl/src/math/__expo2f.c\n    k    = <u32>235,\n    kln2 = reinterpret<f32>(0x4322E3BC); // 0x1.45c778p+7f\n  let scale = reinterpret<f32>(u32(0x7F + (k >> 1)) << 23);\n  // in directed rounding correct sign before rounding or overflow is important\n  return NativeMathf.exp(x - kln2) * (sign * scale) * scale;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction pio2f_large_quot(x: f32, u: i32): i32 { // see: jdh8/metallic/blob/master/src/math/float/rem_pio2f.c\n  const coeff = reinterpret<f64>(0x3BF921FB54442D18); // π * 0x1p-65 = 8.51530395021638647334e-20\n\n  let offset = (u >> 23) - 152;\n  let shift  = u64(offset & 63);\n  let tblPtr = PIO2F_TABLE + (offset >> 6 << 3);\n\n  let b0 = load<u64>(tblPtr, 0 << 3);\n  let b1 = load<u64>(tblPtr, 1 << 3);\n  let lo: u64;\n\n  if (shift > 32) {\n    let b2 = load<u64>(tblPtr, 2 << 3);\n    lo  = b2 >> (96 - shift);\n    lo |= b1 << (shift - 32);\n  } else {\n    lo = b1 >> (32 - shift);\n  }\n\n  let hi = (b1 >> (64 - shift)) | (b0 << shift);\n  let mantissa: u64 = (u & 0x007FFFFF) | 0x00800000;\n  let product = mantissa * hi + (mantissa * lo >> 32);\n  let r: i64 = product << 2;\n  let q = i32((product >> 62) + (r >>> 63));\n  rempio2f_y = copysign<f64>(coeff, x) * <f64>r;\n  return q;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction rempio2f(x: f32, u: u32, sign: i32): i32 { // see: jdh8/metallic/blob/master/src/math/float/rem_pio2f.c\n  const\n    pi2hi = reinterpret<f64>(0x3FF921FB50000000), // 1.57079631090164184570\n    pi2lo = reinterpret<f64>(0x3E5110B4611A6263), // 1.58932547735281966916e-8\n    _2_pi = reinterpret<f64>(0x3FE45F306DC9C883); // 0.63661977236758134308\n\n  if (u < 0x4DC90FDB) { // π * 0x1p28\n    let q = nearest(x * _2_pi);\n    rempio2f_y = x - q * pi2hi - q * pi2lo;\n    return <i32>q;\n  }\n\n  let q = pio2f_large_quot(x, u);\n  return select(-q, q, sign);\n}\n\n// |sin(x)/x - s(x)| < 2**-37.5 (~[-4.89e-12, 4.824e-12]).\n// @ts-ignore: decorator\n@inline\nfunction sin_kernf(x: f64): f32 { // see: musl/tree/src/math/__sindf.c\n  const\n    S1 = reinterpret<f64>(0xBFC5555554CBAC77), // -0x15555554cbac77.0p-55\n    S2 = reinterpret<f64>(0x3F811110896EFBB2), //  0x111110896efbb2.0p-59\n    S3 = reinterpret<f64>(0xBF2A00F9E2CAE774), // -0x1a00f9e2cae774.0p-65\n    S4 = reinterpret<f64>(0x3EC6CD878C3B46A7); //  0x16cd878c3b46a7.0p-71\n\n  let z = x * x;\n  let w = z * z;\n  let r = S3 + z * S4;\n  let s = z * x;\n  return f32((x + s * (S1 + z * S2)) + s * w * r);\n}\n\n// |cos(x) - c(x)| < 2**-34.1 (~[-5.37e-11, 5.295e-11]).\n// @ts-ignore: decorator\n@inline\nfunction cos_kernf(x: f64): f32 { // see: musl/tree/src/math/__cosdf.c\n  const\n    C0 = reinterpret<f64>(0xBFDFFFFFFD0C5E81), // -0x1ffffffd0c5e81.0p-54\n    C1 = reinterpret<f64>(0x3FA55553E1053A42), //  0x155553e1053a42.0p-57\n    C2 = reinterpret<f64>(0xBF56C087E80F1E27), // -0x16c087e80f1e27.0p-62\n    C3 = reinterpret<f64>(0x3EF99342E0EE5069); //  0x199342e0ee5069.0p-68\n\n  let z = x * x;\n  let w = z * z;\n  let r = C2 + z * C3;\n  return f32(((1 + z * C0) + w * C1) + (w * z) * r);\n}\n\n// |tan(x)/x - t(x)| < 2**-25.5 (~[-2e-08, 2e-08]).\n// @ts-ignore: decorator\n@inline\nfunction tan_kernf(x: f64, odd: i32): f32 { // see: musl/tree/src/math/__tandf.c\n  const\n    T0 = reinterpret<f64>(0x3FD5554D3418C99F), // 0x15554d3418c99f.0p-54\n    T1 = reinterpret<f64>(0x3FC112FD38999F72), // 0x1112fd38999f72.0p-55\n    T2 = reinterpret<f64>(0x3FAB54C91D865AFE), // 0x1b54c91d865afe.0p-57\n    T3 = reinterpret<f64>(0x3F991DF3908C33CE), // 0x191df3908c33ce.0p-58\n    T4 = reinterpret<f64>(0x3F685DADFCECF44E), // 0x185dadfcecf44e.0p-61\n    T5 = reinterpret<f64>(0x3F8362B9BF971BCD); // 0x1362b9bf971bcd.0p-59\n\n  let z = x * x;\n  let r = T4 + z * T5;\n  let t = T2 + z * T3;\n  let w = z * z;\n  let s = z * x;\n  let u = T0 + z * T1;\n\n  r = (x + s * u) + (s * w) * (t + w * r);\n  return f32(odd ? -1 / r : r);\n}\n\n// See: jdh8/metallic/src/math/float/log2f.c and jdh8/metallic/src/math/float/kernel/atanh.h\n// @ts-ignore: decorator\n@inline\nfunction log2f(x: f64): f64 {\n  const\n    log2e = reinterpret<f64>(0x3FF71547652B82FE), // 1.44269504088896340736\n    c0 = reinterpret<f64>(0x3FD555554FD9CAEF),    // 0.33333332822728226129\n    c1 = reinterpret<f64>(0x3FC999A7A8AF4132),    // 0.20000167595436263505\n    c2 = reinterpret<f64>(0x3FC2438D79437030),    // 0.14268654271188685375\n    c3 = reinterpret<f64>(0x3FBE2F663B001C97);    // 0.11791075649681414150\n\n  let i = reinterpret<i64>(x);\n  let exponent = (i - 0x3FE6A09E667F3BCD) >> 52;\n  x = reinterpret<f64>(i - (exponent << 52));\n  x = (x - 1) / (x + 1);\n  let xx = x * x;\n  let y = x + x * xx * (c0 + c1 * xx + (c2 + c3 * xx) * (xx * xx));\n  return (2 * log2e) * y + <f64>exponent;\n}\n\n// See: jdh8/metallic/src/math/float/exp2f.h and jdh8/metallic/blob/master/src/math/float/kernel/exp2f.h\n// @ts-ignore: decorator\n@inline\nfunction exp2f(x: f64): f64 {\n  const\n    c0 = reinterpret<f64>(0x3FE62E4302FCC24A), // 6.931471880289532425e-1\n    c1 = reinterpret<f64>(0x3FCEBFBE07D97B91), // 2.402265108421173406e-1\n    c2 = reinterpret<f64>(0x3FAC6AF6CCFC1A65), // 5.550357105498874537e-2\n    c3 = reinterpret<f64>(0x3F83B29E3CE9AEF6), // 9.618030771171497658e-3\n    c4 = reinterpret<f64>(0x3F55F0896145A89F), // 1.339086685300950937e-3\n    c5 = reinterpret<f64>(0x3F2446C81E384864); // 1.546973499989028719e-4\n\n  if (x < -1022) return 0;\n  if (x >= 1024) return Infinity;\n\n  let n = nearest(x);\n  x -= n;\n  let xx = x * x;\n  let y = 1 + x * (c0 + c1 * x + (c2 + c3 * x) * xx + (c4 + c5 * x) * (xx * xx));\n  return reinterpret<f64>(reinterpret<i64>(y) + (<i64>n << 52));\n}\n\nexport namespace NativeMathf {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const E       = <f32>NativeMath.E;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const LN2     = <f32>NativeMath.LN2;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const LN10    = <f32>NativeMath.LN10;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const LOG2E   = <f32>NativeMath.LOG2E;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const LOG10E  = <f32>NativeMath.LOG10E;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const PI      = <f32>NativeMath.PI;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const SQRT1_2 = <f32>NativeMath.SQRT1_2;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const SQRT2   = <f32>NativeMath.SQRT2;\n\n  // @ts-ignore: decorator\n  @lazy\n  export let sincos_sin: f32 = 0;\n\n  // @ts-ignore: decorator\n  @lazy\n  export let sincos_cos: f32 = 0;\n\n  // @ts-ignore: decorator\n  @inline\n  export function abs(x: f32): f32 {\n    return builtin_abs<f32>(x);\n  }\n\n  export function acos(x: f32): f32 { // see: musl/src/math/acosf.c and SUN COPYRIGHT NOTICE above\n    const\n      pio2_hi   = reinterpret<f32>(0x3FC90FDA), // 1.5707962513e+00f\n      pio2_lo   = reinterpret<f32>(0x33A22168), // 7.5497894159e-08f\n      Ox1p_120f = reinterpret<f32>(0x03800000); // 0x1p-120f\n\n    let hx = reinterpret<u32>(x);\n    let ix = hx & 0x7FFFFFFF;\n    if (ix >= 0x3F800000) {\n      if (ix == 0x3F800000) {\n        return select<f32>(2 * pio2_hi + Ox1p_120f, 0, <i32>hx < 0);\n      }\n      return 0 / (x - x);\n    }\n    if (ix < 0x3F000000) {\n      if (ix <= 0x32800000) return pio2_hi + Ox1p_120f;\n      return pio2_hi - (x - (pio2_lo - x * Rf(x * x)));\n    }\n    let z: f32, w: f32, s: f32;\n    if (<i32>hx < 0) {\n      // z = (1 + x) * 0.5;\n      z = 0.5 + x * 0.5;\n      s = builtin_sqrt<f32>(z);\n      w = Rf(z) * s - pio2_lo;\n      return 2 * (pio2_hi - (s + w));\n    }\n    // z = (1 - x) * 0.5;\n    z = 0.5 - x * 0.5;\n    s = builtin_sqrt<f32>(z);\n    hx = reinterpret<u32>(s);\n    let df = reinterpret<f32>(hx & 0xFFFFF000);\n    let c = (z - df * df) / (s + df);\n    w = Rf(z) * s + c;\n    return 2 * (df + w);\n  }\n\n  export function acosh(x: f32): f32 { // see: musl/src/math/acoshf.c\n    const s = reinterpret<f32>(0x3F317218); // 0.693147180559945309417232121458176568f\n    let u = reinterpret<u32>(x);\n    let a = u & 0x7FFFFFFF;\n    if (a < 0x3F800000 + (1 << 23)) { // |x| < 2, invalid if x < 1\n      let xm1 = x - 1;\n      return log1p(xm1 + builtin_sqrt(xm1 * (xm1 + 2)));\n    }\n    if (u < 0x3F800000 + (12 << 23)) { // 2 <= x < 0x1p12\n      return log(2 * x - 1 / (x + builtin_sqrt<f32>(x * x - 1)));\n    }\n    // x >= 0x1p12 or x <= -2 or NaN\n    return log(x) + s;\n  }\n\n  export function asin(x: f32): f32 { // see: musl/src/math/asinf.c and SUN COPYRIGHT NOTICE above\n    const\n      pio2      = reinterpret<f32>(0x3FC90FDB), // 1.570796326794896558e+00f\n      Ox1p_120f = reinterpret<f32>(0x03800000); // 0x1p-120f\n\n    let sx = x;\n    let hx = reinterpret<u32>(x) & 0x7FFFFFFF;\n    if (hx >= 0x3F800000) {\n      if (hx == 0x3F800000) return x * pio2 + Ox1p_120f;\n      return 0 / (x - x);\n    }\n    if (hx < 0x3F000000) {\n      if (hx < 0x39800000 && hx >= 0x00800000) return x;\n      return x + x * Rf(x * x);\n    }\n    // let z: f32 = (1 - builtin_abs<f32>(x)) * 0.5;\n    let z: f32 = 0.5 - builtin_abs<f32>(x) * 0.5;\n    let s = builtin_sqrt<f64>(z); // sic\n    x = f32(pio2 - 2 * (s + s * Rf(z)));\n    return builtin_copysign(x, sx);\n  }\n\n  export function asinh(x: f32): f32 { // see: musl/src/math/asinhf.c\n    const c = reinterpret<f32>(0x3F317218); // 0.693147180559945309417232121458176568f\n    let u = reinterpret<u32>(x) & 0x7FFFFFFF;\n    let y = reinterpret<f32>(u);\n    if (u >= 0x3F800000 + (12 << 23)) y = log(y) + c;\n    else if (u >= 0x3F800000 + (1 << 23))  y =   log(2 * y + 1 / (builtin_sqrt<f32>(y * y + 1) + y));\n    else if (u >= 0x3F800000 - (12 << 23)) y = log1p(y + y * y / (builtin_sqrt<f32>(y * y + 1) + 1));\n    return builtin_copysign(y, x);\n  }\n\n  export function atan(x: f32): f32 { // see: musl/src/math/atanf.c and SUN COPYRIGHT NOTICE above\n    const\n      atanhi0   = reinterpret<f32>(0x3EED6338), //  4.6364760399e-01f\n      atanhi1   = reinterpret<f32>(0x3F490FDA), //  7.8539812565e-01f\n      atanhi2   = reinterpret<f32>(0x3F7B985E), //  9.8279368877e-01f\n      atanhi3   = reinterpret<f32>(0x3FC90FDA), //  1.5707962513e+00f\n      atanlo0   = reinterpret<f32>(0x31AC3769), //  5.0121582440e-09f\n      atanlo1   = reinterpret<f32>(0x33222168), //  3.7748947079e-08f\n      atanlo2   = reinterpret<f32>(0x33140FB4), //  3.4473217170e-08f\n      atanlo3   = reinterpret<f32>(0x33A22168), //  7.5497894159e-08f\n      aT0       = reinterpret<f32>(0x3EAAAAA9), //  3.3333328366e-01f\n      aT1       = reinterpret<f32>(0xBE4CCA98), // -1.9999158382e-01f\n      aT2       = reinterpret<f32>(0x3E11F50D), //  1.4253635705e-01f\n      aT3       = reinterpret<f32>(0xBDDA1247), // -1.0648017377e-01f\n      aT4       = reinterpret<f32>(0x3D7CAC25), //  6.1687607318e-02f\n      Ox1p_120f = reinterpret<f32>(0x03800000); //  0x1p-120f\n\n    let ix = reinterpret<u32>(x);\n    let sx = x;\n    ix &= 0x7FFFFFFF;\n    let z: f32;\n    if (ix >= 0x4C800000) {\n      if (isNaN(x)) return x;\n      z = atanhi3 + Ox1p_120f;\n      return builtin_copysign(z, sx);\n    }\n    let id: i32;\n    if (ix < 0x3EE00000) {\n      if (ix < 0x39800000) return x;\n      id = -1;\n    } else {\n      x = builtin_abs<f32>(x);\n      if (ix < 0x3F980000) {\n        if (ix < 0x3F300000) {\n          id = 0;\n          x = (2.0 * x - 1.0) / (2.0 + x);\n        } else {\n          id = 1;\n          x = (x - 1.0) / (x + 1.0);\n        }\n      } else {\n        if (ix < 0x401C0000) {\n          id = 2;\n          x = (x - 1.5) / (1.0 + 1.5 * x);\n        } else {\n          id = 3;\n          x = -1.0 / x;\n        }\n      }\n    }\n    z = x * x;\n    let w = z * z;\n    let s1 = z * (aT0 + w * (aT2 + w * aT4));\n    let s2 = w * (aT1 + w * aT3);\n    let s3 = x * (s1 + s2);\n    if (id < 0) return x - s3;\n    switch (id) {\n      case 0: { z = atanhi0 - ((s3 - atanlo0) - x); break; }\n      case 1: { z = atanhi1 - ((s3 - atanlo1) - x); break; }\n      case 2: { z = atanhi2 - ((s3 - atanlo2) - x); break; }\n      case 3: { z = atanhi3 - ((s3 - atanlo3) - x); break; }\n      default: unreachable();\n    }\n    return builtin_copysign(z, sx);\n  }\n\n  export function atanh(x: f32): f32 { // see: musl/src/math/atanhf.c\n    let u = reinterpret<u32>(x);\n    let y = builtin_abs(x);\n    if (u < 0x3F800000 - (1 << 23)) {\n      if (u >= 0x3F800000 - (32 << 23)) y = 0.5 * log1p(2 * y * (1.0 + y / (1 - y)));\n    } else y = 0.5 * log1p(2 * (y / (1 - y)));\n    return builtin_copysign(y, x);\n  }\n\n  export function atan2(y: f32, x: f32): f32 { // see: musl/src/math/atan2f.c and SUN COPYRIGHT NOTICE above\n    const\n      pi    = reinterpret<f32>(0x40490FDB), //  3.1415927410e+00f\n      pi_lo = reinterpret<f32>(0xB3BBBD2E); // -8.7422776573e-08f\n\n    if (isNaN(x) || isNaN(y)) return x + y;\n    let ix = reinterpret<u32>(x);\n    let iy = reinterpret<u32>(y);\n    if (ix == 0x3F800000) return atan(y);\n    let m = u32(((iy >> 31) & 1) | ((ix >> 30) & 2));\n    ix &= 0x7FFFFFFF;\n    iy &= 0x7FFFFFFF;\n    if (iy == 0) {\n      switch (m) {\n        case 0:\n        case 1: return  y;\n        case 2: return  pi;\n        case 3: return -pi;\n      }\n    }\n    if (ix == 0) return m & 1 ? -pi / 2 : pi / 2;\n    if (ix == 0x7F800000) {\n      if (iy == 0x7F800000) {\n        let t: f32 = m & 2 ? 3 * pi / 4 : pi / 4;\n        return m & 1 ? -t : t;\n      } else {\n        let t: f32 = m & 2 ? pi : 0.0;\n        return m & 1 ? -t : t;\n      }\n    }\n    if (ix + (26 << 23) < iy || iy == 0x7F800000) return m & 1 ? -pi / 2 : pi / 2;\n    let z: f32;\n    if ((m & 2) && iy + (26 << 23) < ix) z = 0.0;\n    else z = atan(builtin_abs<f32>(y / x));\n    switch (m) {\n      case 0: return  z;\n      case 1: return -z;\n      case 2: return pi - (z - pi_lo);\n      case 3: return (z - pi_lo) - pi;\n    }\n    unreachable();\n    return 0;\n  }\n\n  export function cbrt(x: f32): f32 { // see: musl/src/math/cbrtf.c and SUN COPYRIGHT NOTICE above\n    const\n      B1      = <u32>709958130,\n      B2      = <u32>642849266,\n      Ox1p24f = reinterpret<f32>(0x4B800000);\n\n    let u = reinterpret<u32>(x);\n    let hx = u & 0x7FFFFFFF;\n    if (hx >= 0x7F800000) return x + x;\n    if (hx < 0x00800000) {\n      if (hx == 0) return x;\n      u = reinterpret<u32>(x * Ox1p24f);\n      hx = u & 0x7FFFFFFF;\n      hx = hx / 3 + B2;\n    } else {\n      hx = hx / 3 + B1;\n    }\n    u &= 0x80000000;\n    u |= hx;\n    let t = <f64>reinterpret<f32>(u);\n    let r = t * t * t;\n    t = t * (<f64>x + x + r) / (x + r + r);\n    r = t * t * t;\n    t = t * (<f64>x + x + r) / (x + r + r);\n    return <f32>t;\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function ceil(x: f32): f32 {\n    return builtin_ceil<f32>(x);\n  }\n\n  export function clz32(x: f32): f32 {\n    if (!isFinite(x)) return 32;\n    return <f32>builtin_clz(dtoi32(x));\n  }\n\n  export function cos(x: f32): f32 { // see: musl/src/math/cosf.c\n    const\n      c1pio2 = reinterpret<f64>(0x3FF921FB54442D18), // M_PI_2 * 1\n      c2pio2 = reinterpret<f64>(0x400921FB54442D18), // M_PI_2 * 2\n      c3pio2 = reinterpret<f64>(0x4012D97C7F3321D2), // M_PI_2 * 3\n      c4pio2 = reinterpret<f64>(0x401921FB54442D18); // M_PI_2 * 4\n\n    let ux = reinterpret<u32>(x);\n    let sign = ux >> 31;\n    ux &= 0x7FFFFFFF;\n\n    if (ux <= 0x3F490FDA) {  // |x| ~<= π/4\n      if (ux < 0x39800000) { // |x| < 2**-12\n        // raise inexact if x != 0\n        return 1;\n      }\n      return cos_kernf(x);\n    }\n\n    if (ASC_SHRINK_LEVEL < 1) {\n      if (ux <= 0x407B53D1) {  // |x| ~<= 5π/4\n        if (ux > 0x4016CBE3) { // |x|  ~> 3π/4\n          return -cos_kernf(sign ? x + c2pio2 : x - c2pio2);\n        } else {\n          return sign ? sin_kernf(x + c1pio2) : sin_kernf(c1pio2 - x);\n        }\n      }\n      if (ux <= 0x40E231D5) {  // |x| ~<= 9π/4\n        if (ux > 0x40AFEDDF) { // |x|  ~> 7π/4\n          return cos_kernf(sign ? x + c4pio2 : x - c4pio2);\n        } else {\n          return sign ? sin_kernf(-x - c3pio2) : sin_kernf(x - c3pio2);\n        }\n      }\n    }\n\n    // cos(Inf or NaN) is NaN\n    if (ux >= 0x7F800000) return x - x;\n\n    // general argument reduction needed\n    let n = rempio2f(x, ux, sign);\n    let y = rempio2f_y;\n\n    let t = n & 1 ? sin_kernf(y) : cos_kernf(y);\n    return (n + 1) & 2 ? -t : t;\n  }\n\n  export function cosh(x: f32): f32 { // see: musl/src/math/coshf.c\n    let u = reinterpret<u32>(x);\n    u &= 0x7FFFFFFF;\n    x = reinterpret<f32>(u);\n    if (u < 0x3F317217) {\n      if (u < 0x3F800000 - (12 << 23)) return 1;\n      let t = expm1(x);\n      // return 1 + t * t / (2 * (1 + t));\n      return 1 + t * t / (2 + 2 * t);\n    }\n    if (u < 0x42B17217) {\n      let t = exp(x);\n      // return 0.5 * (t + 1 / t);\n      return 0.5 * t + 0.5 / t;\n    }\n    return expo2f(x, 1);\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function floor(x: f32): f32 {\n    return builtin_floor<f32>(x);\n  }\n\n  export function exp(x: f32): f32 { // see: musl/src/math/expf.c and SUN COPYRIGHT NOTICE above\n    if (ASC_SHRINK_LEVEL < 1) {\n      return expf_lut(x);\n    } else {\n      const\n        ln2hi    = reinterpret<f32>(0x3F317200), //  6.9314575195e-1f\n        ln2lo    = reinterpret<f32>(0x35BFBE8E), //  1.4286067653e-6f\n        invln2   = reinterpret<f32>(0x3FB8AA3B), //  1.4426950216e+0f\n        P1       = reinterpret<f32>(0x3E2AAA8F), //  1.6666625440e-1f\n        P2       = reinterpret<f32>(0xBB355215), // -2.7667332906e-3f\n        Ox1p127f = reinterpret<f32>(0x7F000000); //  0x1p+127f\n\n      let hx = reinterpret<u32>(x);\n      let sign = hx >> 31;\n      hx &= 0x7FFFFFFF;\n      if (hx >= 0x42AEAC50) {\n        if (hx > 0x7F800000) return x; // NaN\n        if (hx >= 0x42B17218) {\n          if (!sign) return x * Ox1p127f;\n          else if (hx >= 0x42CFF1B5) return 0;\n        }\n      }\n      let hi: f32, lo: f32;\n      let k: i32;\n      if (hx > 0x3EB17218) {\n        if (hx > 0x3F851592) {\n          k = i32(invln2 * x + builtin_copysign<f32>(0.5, x));\n        } else {\n          k = 1 - (sign << 1);\n        }\n        hi = x - <f32>k * ln2hi;\n        lo = <f32>k * ln2lo;\n        x = hi - lo;\n      } else if (hx > 0x39000000) {\n        k = 0;\n        hi = x;\n        lo = 0;\n      } else {\n        return 1 + x;\n      }\n      let xx = x * x;\n      let c = x - xx * (P1 + xx * P2);\n      let y: f32 = 1 + (x * c / (2 - c) - lo + hi);\n      return k == 0 ? y : scalbn(y, k);\n    }\n  }\n\n  export function exp2(x: f32): f32 {\n    return exp2f_lut(x);\n  }\n\n  export function expm1(x: f32): f32 { // see: musl/src/math/expm1f.c and SUN COPYRIGHT NOTICE above\n    const\n      ln2_hi   = reinterpret<f32>(0x3F317180), //  6.9313812256e-01f\n      ln2_lo   = reinterpret<f32>(0x3717F7D1), //  9.0580006145e-06f\n      invln2   = reinterpret<f32>(0x3FB8AA3B), //  1.4426950216e+00f\n      Q1       = reinterpret<f32>(0xBD088868), // -3.3333212137e-02f\n      Q2       = reinterpret<f32>(0x3ACF3010), //  1.5807170421e-03f\n      Ox1p127f = reinterpret<f32>(0x7F000000); //  0x1p+127f\n\n    let u = reinterpret<u32>(x);\n    let hx = u & 0x7FFFFFFF;\n    let sign = u >> 31;\n    if (hx >= 0x4195B844) {\n      if (hx > 0x7F800000) return x;\n      if (sign) return -1;\n      if (hx > 0x42B17217) { // x > log(FLT_MAX)\n        x *= Ox1p127f;\n        return x;\n      }\n    }\n    let c: f32 = 0.0, t: f32, k: i32;\n    if (hx > 0x3EB17218) {\n      k = select<i32>(\n        1 - (sign << 1),\n        i32(invln2 * x + builtin_copysign<f32>(0.5, x)),\n        hx < 0x3F851592\n      );\n      t = <f32>k;\n      let hi = x - t * ln2_hi;\n      let lo = t * ln2_lo;\n      x = hi - lo;\n      c = (hi - x) - lo;\n    } else if (hx < 0x33000000) {\n      return x;\n    } else k = 0;\n    let hfx: f32 = 0.5 * x;\n    let hxs: f32 = x * hfx;\n    let r1: f32 = 1.0 + hxs * (Q1 + hxs * Q2);\n    t  = 3.0 - r1 * hfx;\n    let e = hxs * ((r1 - t) / (6.0 - x * t));\n    if (k == 0) return x - (x * e - hxs);\n    e  = x * (e - c) - c;\n    e -= hxs;\n    if (k == -1) return 0.5 * (x - e) - 0.5;\n    if (k == 1) {\n      if (x < -0.25) return -2.0 * (e - (x + 0.5));\n      return 1.0 + 2.0 * (x - e);\n    }\n    u = (0x7F + k) << 23;\n    let twopk = reinterpret<f32>(u);\n    let y: f32;\n    if (k < 0 || k > 56) {\n      y = x - e + 1.0;\n      if (k == 128) y = y * 2.0 * Ox1p127f;\n      else y = y * twopk;\n      return y - 1.0;\n    }\n    u = (0x7F - k) << 23;\n    y = reinterpret<f32>(u);\n    if (k < 20) y = (1 - y) - e;\n    else y = 1 - (e + y);\n    return (x + y) * twopk;\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function fround(x: f32): f32 {\n    return x;\n  }\n\n  export function hypot(x: f32, y: f32): f32 { // see: musl/src/math/hypotf.c\n    const\n      Ox1p90f  = reinterpret<f32>(0x6C800000),\n      Ox1p_90f = reinterpret<f32>(0x12800000);\n\n    let ux = reinterpret<u32>(x);\n    let uy = reinterpret<u32>(y);\n    ux &= 0x7FFFFFFF;\n    uy &= 0x7FFFFFFF;\n    if (ux < uy) {\n      let ut = ux;\n      ux = uy;\n      uy = ut;\n    }\n    x = reinterpret<f32>(ux);\n    y = reinterpret<f32>(uy);\n    if (uy == 0xFF << 23) return y;\n    if (ux >= 0xFF << 23 || uy == 0 || ux - uy >= 25 << 23) return x + y;\n    let z: f32 = 1;\n    if (ux >= (0x7F + 60) << 23) {\n      z  = Ox1p90f;\n      x *= Ox1p_90f;\n      y *= Ox1p_90f;\n    } else if (uy < (0x7F - 60) << 23) {\n      z  = Ox1p_90f;\n      x *= Ox1p90f;\n      y *= Ox1p90f;\n    }\n    return z * builtin_sqrt<f32>(f32(<f64>x * x + <f64>y * y));\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function imul(x: f32, y: f32): f32 {\n    /*\n     * Wasm (MVP) and JS have different approaches for double->int conversions.\n     *\n     * For emulate JS conversion behavior and avoid trapping from wasm we should modulate by MAX_INT\n     * our float-point arguments before actual convertion to integers.\n     */\n    if (!isFinite(x + y)) return 0;\n    return <f32>(dtoi32(x) * dtoi32(y));\n  }\n\n  export function log(x: f32): f32 { // see: musl/src/math/logf.c and SUN COPYRIGHT NOTICE above\n    if (ASC_SHRINK_LEVEL < 1) {\n      return logf_lut(x);\n    } else {\n      const\n        ln2_hi  = reinterpret<f32>(0x3F317180), // 6.9313812256e-01f\n        ln2_lo  = reinterpret<f32>(0x3717F7D1), // 9.0580006145e-06f\n        Lg1     = reinterpret<f32>(0x3F2AAAAA), // 0xaaaaaa.0p-24f\n        Lg2     = reinterpret<f32>(0x3ECCCE13), // 0xccce13.0p-25f\n        Lg3     = reinterpret<f32>(0x3E91E9EE), // 0x91e9ee.0p-25f\n        Lg4     = reinterpret<f32>(0x3E789E26), // 0xf89e26.0p-26f\n        Ox1p25f = reinterpret<f32>(0x4C000000);\n\n      let u = reinterpret<u32>(x);\n      let k = 0;\n      let sign = u >> 31;\n      if (sign || u < 0x00800000) {\n        if (u << 1 == 0) return -1 / (x * x);\n        if (sign) return (x - x) / 0;\n        k -= 25;\n        x *= Ox1p25f;\n        u = reinterpret<u32>(x);\n      } else if (u >= 0x7F800000) {\n        return x;\n      } else if (u == 0x3F800000) {\n        return 0;\n      }\n      u += 0x3F800000 - 0x3F3504F3;\n      k += i32(u >> 23) - 0x7F;\n      u = (u & 0x007FFFFF) + 0x3F3504F3;\n      x = reinterpret<f32>(u);\n      let f = x - 1.0;\n      let s = f / (2.0 + f);\n      let z = s * s;\n      let w = z * z;\n      let t1 = w * (Lg2 + w * Lg4);\n      let t2 = z * (Lg1 + w * Lg3);\n      let r = t2 + t1;\n      let hfsq = <f32>0.5 * f * f;\n      let dk = <f32>k;\n      return s * (hfsq + r) + dk * ln2_lo - hfsq + f + dk * ln2_hi;\n    }\n  }\n\n  export function log10(x: f32): f32 { // see: musl/src/math/log10f.c and SUN COPYRIGHT NOTICE above\n    const\n      ivln10hi  = reinterpret<f32>(0x3EDE6000), //  4.3432617188e-01f\n      ivln10lo  = reinterpret<f32>(0xB804EAD9), // -3.1689971365e-05f\n      log10_2hi = reinterpret<f32>(0x3E9A2080), //  3.0102920532e-01f\n      log10_2lo = reinterpret<f32>(0x355427DB), //  7.9034151668e-07f\n      Lg1       = reinterpret<f32>(0x3F2AAAAA), //  0xaaaaaa.0p-24f, 0.66666662693f\n      Lg2       = reinterpret<f32>(0x3ECCCE13), //  0xccce13.0p-25f, 0.40000972152f\n      Lg3       = reinterpret<f32>(0x3E91E9EE), //  0x91e9ee.0p-25f, 0.28498786688f\n      Lg4       = reinterpret<f32>(0x3E789E26), //  0xf89e26.0p-26f, 0.24279078841f\n      Ox1p25f   = reinterpret<f32>(0x4C000000); //  0x1p25f\n\n    let ux = reinterpret<u32>(x);\n    let k = 0;\n    let sign = ux >> 31;\n    if (sign || ux < 0x00800000) {\n      if (ux << 1 == 0) return -1 / (x * x);\n      if (sign) return (x - x) / 0.0;\n      k -= 25;\n      x *= Ox1p25f;\n      ux = reinterpret<u32>(x);\n    } else if (ux >= 0x7F800000) {\n      return x;\n    } else if (ux == 0x3F800000) {\n      return 0;\n    }\n    ux += 0x3F800000 - 0x3F3504F3;\n    k += i32(ux >> 23) - 0x7F;\n    ux = (ux & 0x007FFFFF) + 0x3F3504F3;\n    x = reinterpret<f32>(ux);\n    let f = x - 1.0;\n    let s = f / (2.0 + f);\n    let z = s * s;\n    let w = z * z;\n    let t1 = w * (Lg2 + w * Lg4);\n    let t2 = z * (Lg1 + w * Lg3);\n    let r = t2 + t1;\n    let hfsq: f32 = 0.5 * f * f;\n    let hi = f - hfsq;\n    ux = reinterpret<u32>(hi);\n    ux &= 0xFFFFF000;\n    hi = reinterpret<f32>(ux);\n    let lo = f - hi - hfsq + s * (hfsq + r);\n    let dk = <f32>k;\n    return dk * log10_2lo + (lo + hi) * ivln10lo + lo * ivln10hi + hi * ivln10hi + dk * log10_2hi;\n  }\n\n  export function log1p(x: f32): f32 { // see: musl/src/math/log1pf.c and SUN COPYRIGHT NOTICE above\n    const\n      ln2_hi = reinterpret<f32>(0x3F317180), // 6.9313812256e-01\n      ln2_lo = reinterpret<f32>(0x3717F7D1), // 9.0580006145e-06\n      Lg1    = reinterpret<f32>(0x3F2AAAAA), // 0xaaaaaa.0p-24f, 0.66666662693f\n      Lg2    = reinterpret<f32>(0x3ECCCE13), // 0xccce13.0p-25f, 0.40000972152f\n      Lg3    = reinterpret<f32>(0x3E91E9EE), // 0x91e9ee.0p-25f, 0.28498786688f\n      Lg4    = reinterpret<f32>(0x3E789E26); // 0xf89e26.0p-26f, 0.24279078841f\n\n    let ix = reinterpret<u32>(x);\n    let c: f32 = 0;\n    let f: f32 = 0;\n    let k = 1;\n    if (ix < 0x3ED413D0 || bool(ix >> 31)) {\n      if (ix >= 0xBF800000) {\n        if (x == -1) return x / 0.0;\n        return (x - x) / 0.0;\n      }\n      if (ix << 1 < 0x33800000 << 1) return x;\n      if (ix <= 0xBE95F619) {\n        k = 0;\n        c = 0;\n        f = x;\n      }\n    } else if (ix >= 0x7F800000) return x;\n    if (k) {\n      let uf: f32 = 1 + x;\n      let iu = reinterpret<u32>(uf);\n      iu += 0x3F800000 - 0x3F3504F3;\n      k = i32(iu >> 23) - 0x7F;\n      if (k < 25) {\n        c = k >= 2 ? 1 - (uf - x) : x - (uf - 1);\n        c /= uf;\n      } else c = 0;\n      iu = (iu & 0x007FFFFF) + 0x3F3504F3;\n      f = reinterpret<f32>(iu) - 1;\n    }\n    let s = f / (2.0 + f);\n    let z = s * s;\n    let w = z * z;\n    let t1 = w * (Lg2 + w * Lg4);\n    let t2 = z * (Lg1 + w * Lg3);\n    let r = t2 + t1;\n    let hfsq: f32 = 0.5 * f * f;\n    let dk = <f32>k;\n    return s * (hfsq + r) + (dk * ln2_lo + c) - hfsq + f + dk * ln2_hi;\n  }\n\n  export function log2(x: f32): f32 { // see: musl/src/math/log2f.c and SUN COPYRIGHT NOTICE above\n    if (ASC_SHRINK_LEVEL < 1) {\n      return log2f_lut(x);\n    } else {\n      const\n        ivln2hi = reinterpret<f32>(0x3FB8B000), //  1.4428710938e+00f\n        ivln2lo = reinterpret<f32>(0xB9389AD4), // -1.7605285393e-04\n        Lg1     = reinterpret<f32>(0x3F2AAAAA), //  0xaaaaaa.0p-24f, 0.66666662693f\n        Lg2     = reinterpret<f32>(0x3ECCCE13), //  0xccce13.0p-25f, 0.40000972152f\n        Lg3     = reinterpret<f32>(0x3E91E9EE), //  0x91e9ee.0p-25f, 0.28498786688f\n        Lg4     = reinterpret<f32>(0x3E789E26), //  0xf89e26.0p-26f, 0.24279078841f\n        Ox1p25f = reinterpret<f32>(0x4C000000); //  0x1p25f\n\n      let ux = reinterpret<u32>(x);\n      let k = 0;\n      let sign = ux >> 31;\n      if (sign || ux < 0x00800000) {\n        if (ux << 1 == 0) return -1 / (x * x);\n        if (sign) return (x - x) / 0.0;\n        k -= 25;\n        x *= Ox1p25f;\n        ux = reinterpret<u32>(x);\n      } else if (ux >= 0x7F800000) {\n        return x;\n      } else if (ux == 0x3F800000) {\n        return 0;\n      }\n      ux += 0x3F800000 - 0x3F3504F3;\n      k += i32(ux >> 23) - 0x7F;\n      ux = (ux & 0x007FFFFF) + 0x3F3504F3;\n      x = reinterpret<f32>(ux);\n      let f = x - 1.0;\n      let s = f / (2.0 + f);\n      let z = s * s;\n      let w = z * z;\n      let t1 = w * (Lg2 + w * Lg4);\n      let t2 = z * (Lg1 + w * Lg3);\n      let r = t2 + t1;\n      let hfsq: f32 = 0.5 * f * f;\n      let hi = f - hfsq;\n      let u = reinterpret<u32>(hi);\n      u &= 0xFFFFF000;\n      hi = reinterpret<f32>(u);\n      let lo: f32 = f - hi - hfsq + s * (hfsq + r);\n      let dk = <f32>k;\n      return (lo + hi) * ivln2lo + lo * ivln2hi + hi * ivln2hi + dk;\n    }\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function max(value1: f32, value2: f32): f32 {\n    return builtin_max<f32>(value1, value2);\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function min(value1: f32, value2: f32): f32 {\n    return builtin_min<f32>(value1, value2);\n  }\n\n  export function pow(x: f32, y: f32): f32 {\n    // TODO: remove this fast pathes after introduced own mid-end IR with \"stdlib call simplify\" transforms\n    if (builtin_abs<f32>(y) <= 2) {\n      if (y == 2.0) return x * x;\n      if (y == 0.5) {\n        return select<f32>(\n          builtin_abs<f32>(builtin_sqrt<f32>(x)),\n          Infinity,\n          x != -Infinity\n        );\n      }\n      if (y == -1.0) return 1 / x;\n      if (y == 1.0) return x;\n      if (y == 0.0) return 1.0;\n    }\n    if (ASC_SHRINK_LEVEL < 1) {\n      // see: musl/src/math/powf.c\n      return powf_lut(x, y);\n    } else {\n      // based on:  jdh8/metallic/src/math/float/powf.c\n      if (y == 0) return 1;\n      // @ts-ignore: cast\n      if (isNaN(x) | isNaN(y)) {\n        return NaN;\n      }\n      let sign: u32 = 0;\n      let uy = reinterpret<u32>(y);\n      let ux = reinterpret<u32>(x);\n      let sx = ux >> 31;\n      ux &= 0x7FFFFFFF;\n      if (sx && nearest(y) == y) {\n        x = -x;\n        sx = 0;\n        sign = u32(nearest(y * 0.5) != y * 0.5) << 31;\n      }\n      let m: u32;\n      if (ux == 0x3F800000) { // x == 1\n        m = sx | u32((uy & 0x7FFFFFFF) == 0x7F800000) ? 0x7FC00000 : 0x3F800000;\n      } else if (ux == 0) {\n        m = <i32>uy < 0 ? 0x7F800000 : 0;\n      } else if (ux == 0x7F800000) {\n        m = <i32>uy < 0 ? 0 : 0x7F800000;\n      } else if (sx) {\n        m = 0x7FC00000;\n      } else {\n        m = reinterpret<u32>(<f32>exp2f(<f64>y * log2f(x)));\n      }\n      return reinterpret<f32>(m | sign);\n    }\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function seedRandom(value: i64): void {\n    NativeMath.seedRandom(value);\n  }\n\n  // Using xoroshiro64starstar from http://xoshiro.di.unimi.it/xoroshiro64starstar.c\n  export function random(): f32 {\n    if (!random_seeded) seedRandom(reinterpret<i64>(seed()));\n\n    let s0 = random_state0_32;\n    let s1 = random_state1_32;\n    let r  = rotl<u32>(s0 * 0x9E3779BB, 5) * 5;\n\n    s1 ^= s0;\n    random_state0_32 = rotl<u32>(s0, 26) ^ s1 ^ (s1 << 9);\n    random_state1_32 = rotl<u32>(s1, 13);\n\n    return reinterpret<f32>((r >> 9) | (127 << 23)) - 1.0;\n  }\n\n  export function round(x: f32): f32 {\n    if (ASC_SHRINK_LEVEL > 0) {\n      return builtin_ceil<f32>(x) - f32(builtin_ceil<f32>(x) - 0.5 > x);\n    } else {\n      let roundUp = builtin_ceil<f32>(x);\n      return select<f32>(roundUp, roundUp - 1.0, roundUp - 0.5 <= x);\n    }\n  }\n\n  export function sign(x: f32): f32 {\n    if (ASC_SHRINK_LEVEL > 0) {\n      return select<f32>(builtin_copysign<f32>(1, x), x, builtin_abs(x) > 0);\n    } else {\n      return select<f32>(1, select<f32>(-1, x, x < 0), x > 0);\n    }\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function signbit(x: f32): bool {\n    return <bool>(reinterpret<u32>(x) >>> 31);\n  }\n\n  export function sin(x: f32): f32 { // see: musl/src/math/sinf.c\n    const\n      s1pio2 = reinterpret<f64>(0x3FF921FB54442D18), // M_PI_2 * 1\n      s2pio2 = reinterpret<f64>(0x400921FB54442D18), // M_PI_2 * 2\n      s3pio2 = reinterpret<f64>(0x4012D97C7F3321D2), // M_PI_2 * 3\n      s4pio2 = reinterpret<f64>(0x401921FB54442D18); // M_PI_2 * 4\n\n    let ux = reinterpret<u32>(x);\n    let sign = ux >> 31;\n    ux &= 0x7FFFFFFF;\n\n    if (ux <= 0x3F490FDA) {  // |x| ~<= π/4\n      if (ux < 0x39800000) { // |x| < 2**-12\n        return x;\n      }\n      return sin_kernf(x);\n    }\n\n    if (ASC_SHRINK_LEVEL < 1) {\n      if (ux <= 0x407B53D1) {   // |x| ~<= 5π/4\n        if (ux <= 0x4016CBE3) { // |x| ~<= 3π/4\n          return sign ? -cos_kernf(x + s1pio2) : cos_kernf(x - s1pio2);\n        }\n        return sin_kernf(-(sign ? x + s2pio2 : x - s2pio2));\n      }\n\n      if (ux <= 0x40E231D5) {   // |x| ~<= 9π/4\n        if (ux <= 0x40AFEDDF) { // |x| ~<= 7π/4\n          return sign ? cos_kernf(x + s3pio2) : -cos_kernf(x - s3pio2);\n        }\n        return sin_kernf(sign ? x + s4pio2 : x - s4pio2);\n      }\n    }\n\n    // sin(Inf or NaN) is NaN\n    if (ux >= 0x7F800000) return x - x;\n\n    let n = rempio2f(x, ux, sign);\n    let y = rempio2f_y;\n\n    let t = n & 1 ? cos_kernf(y) : sin_kernf(y);\n    return n & 2 ? -t : t;\n  }\n\n  export function sinh(x: f32): f32 { // see: musl/src/math/sinhf.c\n    let u = reinterpret<u32>(x) & 0x7FFFFFFF;\n    let a = reinterpret<f32>(u);\n    let h = builtin_copysign<f32>(0.5, x);\n    if (u < 0x42B17217) {\n      let t = expm1(a);\n      if (u < 0x3F800000) {\n        if (u < 0x3F800000 - (12 << 23)) return x;\n        return h * (2 * t - t * t / (t + 1));\n      }\n      return h * (t + t / (t + 1));\n    }\n    return expo2f(a, 2 * h);\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function sqrt(x: f32): f32 {\n    return builtin_sqrt<f32>(x);\n  }\n\n  export function tan(x: f32): f32 { // see: musl/src/math/tanf.c\n    const\n      t1pio2 = reinterpret<f64>(0x3FF921FB54442D18), // 1 * M_PI_2\n      t2pio2 = reinterpret<f64>(0x400921FB54442D18), // 2 * M_PI_2\n      t3pio2 = reinterpret<f64>(0x4012D97C7F3321D2), // 3 * M_PI_2\n      t4pio2 = reinterpret<f64>(0x401921FB54442D18); // 4 * M_PI_2\n\n    let ux = reinterpret<u32>(x);\n    let sign = ux >> 31;\n    ux &= 0x7FFFFFFF;\n\n    if (ux <= 0x3F490FDA) {  // |x| ~<= π/4\n      if (ux < 0x39800000) { // |x| < 2**-12\n        return x;\n      }\n      return tan_kernf(x, 0);\n    }\n\n    if (ASC_SHRINK_LEVEL < 1) {\n      if (ux <= 0x407B53D1) {   // |x| ~<= 5π/4\n        if (ux <= 0x4016CBE3) { // |x| ~<= 3π/4\n          return tan_kernf((sign ? x + t1pio2 : x - t1pio2), 1);\n        } else {\n          return tan_kernf((sign ? x + t2pio2 : x - t2pio2), 0);\n        }\n      }\n      if (ux <= 0x40E231D5) {   // |x| ~<= 9π/4\n        if (ux <= 0x40AFEDDF) { // |x| ~<= 7π/4\n          return tan_kernf((sign ? x + t3pio2 : x - t3pio2), 1);\n        } else {\n          return tan_kernf((sign ? x + t4pio2 : x - t4pio2), 0);\n        }\n      }\n    }\n\n    // tan(Inf or NaN) is NaN\n    if (ux >= 0x7F800000) return x - x;\n\n    // argument reduction\n    let n = rempio2f(x, ux, sign);\n    let y = rempio2f_y;\n    return tan_kernf(y, n & 1);\n  }\n\n  export function tanh(x: f32): f32 { // see: musl/src/math/tanhf.c\n    let u = reinterpret<u32>(x);\n    u &= 0x7FFFFFFF;\n    let y = reinterpret<f32>(u);\n    let t: f32;\n    if (u > 0x3F0C9F54) {\n      if (u > 0x41200000) t = 1 + 0 / y;\n      else {\n        t = expm1(2 * y);\n        t = 1 - 2 / (t + 2);\n      }\n    } else if (u > 0x3E82C578) {\n      t = expm1(2 * y);\n      t = t / (t + 2);\n    } else if (u >= 0x00800000) {\n      t = expm1(-2 * y);\n      t = -t / (t + 2);\n    } else t = y;\n    return builtin_copysign<f32>(t, x);\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function trunc(x: f32): f32 {\n    return builtin_trunc<f32>(x);\n  }\n\n  export function scalbn(x: f32, n: i32): f32 { // see: https://git.musl-libc.org/cgit/musl/tree/src/math/scalbnf.c\n    const\n      Ox1p24f   = reinterpret<f32>(0x4B800000),\n      Ox1p127f  = reinterpret<f32>(0x7F000000),\n      Ox1p_126f = reinterpret<f32>(0x00800000);\n\n    let y = x;\n    if (n > 127) {\n      y *= Ox1p127f;\n      n -= 127;\n      if (n > 127) {\n        y *= Ox1p127f;\n        n = builtin_min<i32>(n - 127, 127);\n      }\n    } else if (n < -126) {\n      y *= Ox1p_126f * Ox1p24f;\n      n += 126 - 24;\n      if (n < -126) {\n        y *= Ox1p_126f * Ox1p24f;\n        n = builtin_max<i32>(n + 126 - 24, -126);\n      }\n    }\n    return y * reinterpret<f32>(<u32>(0x7F + n) << 23);\n  }\n\n  export function mod(x: f32, y: f32): f32 { // see: musl/src/math/fmodf.c\n    if (builtin_abs<f32>(y) == 1.0) {\n      // x % 1, x % -1  ==>  sign(x) * abs(x - 1.0 * trunc(x / 1.0))\n      // TODO: move this rule to compiler's optimization pass.\n      // It could be apply for any x % C_pot, where \"C_pot\" is pow of two const.\n      return builtin_copysign<f32>(x - builtin_trunc<f32>(x), x);\n    }\n    let ux = reinterpret<u32>(x);\n    let uy = reinterpret<u32>(y);\n    let ex = i32(ux >> 23 & 0xFF);\n    let ey = i32(uy >> 23 & 0xFF);\n    let sm = ux & 0x80000000;\n    let uy1 = uy << 1;\n    if (uy1 == 0 || ex == 0xFF || isNaN<f32>(y)) {\n      let m = x * y;\n      return m / m;\n    }\n    let ux1 = ux << 1;\n    if (ux1 <= uy1) {\n      return x * f32(ux1 != uy1);\n    }\n    if (!ex) {\n      ex -= builtin_clz<u32>(ux << 9);\n      ux <<= 1 - ex;\n    } else {\n      ux &= <u32>-1 >> 9;\n      ux |= 1 << 23;\n    }\n    if (!ey) {\n      ey -= builtin_clz<u32>(uy << 9);\n      uy <<= 1 - ey;\n    } else {\n      uy &= u32(-1) >> 9;\n      uy |= 1 << 23;\n    }\n    while (ex > ey) {\n      if (ux >= uy) {\n        if (ux == uy) return 0 * x;\n        ux -= uy;\n      }\n      ux <<= 1;\n      --ex;\n    }\n    if (ux >= uy) {\n      if (ux == uy) return 0 * x;\n      ux -= uy;\n    }\n    // for (; !(ux >> 23); ux <<= 1) --ex;\n    let shift = <i32>builtin_clz<u32>(ux << 8);\n    ex -= shift;\n    ux <<= shift;\n    if (ex > 0) {\n      ux -= 1 << 23;\n      ux |= <u32>ex << 23;\n    } else {\n      ux >>= -ex + 1;\n    }\n    return reinterpret<f32>(ux | sm);\n  }\n\n  export function rem(x: f32, y: f32): f32 { // see: musl/src/math/remquof.c\n    let ux = reinterpret<u32>(x);\n    let uy = reinterpret<u32>(y);\n    let ex = i32(ux >> 23 & 0xFF);\n    let ey = i32(uy >> 23 & 0xFF);\n    let uxi = ux;\n    if (uy << 1 == 0 || ex == 0xFF || isNaN(y)) return (x * y) / (x * y);\n    if (ux << 1 == 0) return x;\n    if (!ex) {\n      ex -= builtin_clz<u32>(uxi << 9);\n      uxi <<= 1 - ex;\n    } else {\n      uxi &= u32(-1) >> 9;\n      uxi |= 1 << 23;\n    }\n    if (!ey) {\n      ey -= builtin_clz<u32>(uy << 9);\n      uy <<= 1 - ey;\n    } else {\n      uy &= u32(-1) >> 9;\n      uy |= 1 << 23;\n    }\n    let q = 0;\n    do {\n      if (ex < ey) {\n        if (ex + 1 == ey) break; // goto end\n        return x;\n      }\n      while (ex > ey) {\n        if (uxi >= uy) {\n          uxi -= uy;\n          ++q;\n        }\n        uxi <<= 1;\n        q <<= 1;\n        --ex;\n      }\n      if (uxi >= uy) {\n        uxi -= uy;\n        ++q;\n      }\n      if (uxi == 0) ex = -30;\n      else {\n        let shift = builtin_clz<i32>(uxi << 8);\n        ex -= shift;\n        uxi <<= shift;\n      }\n      break;\n    } while (false);\n    // end:\n    if (ex > 0) {\n      uxi -= 1 << 23;\n      uxi |= <u32>ex << 23;\n    } else {\n      uxi >>= -ex + 1;\n    }\n    x = reinterpret<f32>(uxi);\n    y = builtin_abs<f32>(y);\n    let x2 = x + x;\n    if (ex == ey || (ex + 1 == ey && (<f32>x2 > y || (<f32>x2 == y && bool(q & 1))))) {\n      x -= y;\n      // q++;\n    }\n    return <i32>ux < 0 ? -x : x;\n  }\n\n  export function sincos(x: f32): void { // see: musl/tree/src/math/sincosf.c\n    const\n      s1pio2 = reinterpret<f64>(0x3FF921FB54442D18), // 1 * M_PI_2\n      s2pio2 = reinterpret<f64>(0x400921FB54442D18), // 2 * M_PI_2\n      s3pio2 = reinterpret<f64>(0x4012D97C7F3321D2), // 3 * M_PI_2\n      s4pio2 = reinterpret<f64>(0x401921FB54442D18); // 4 * M_PI_2\n\n    let ux = reinterpret<u32>(x);\n    let sign = ux >> 31;\n    ux &= 0x7FFFFFFF;\n\n    if (ux <= 0x3F490FDA) {  // |x| ~<= π/4\n      if (ux < 0x39800000) { // |x| < 2**-12\n        sincos_sin = x;\n        sincos_cos = 1;\n        return;\n      }\n      sincos_sin = sin_kernf(x);\n      sincos_cos = cos_kernf(x);\n      return;\n    }\n    if (ASC_SHRINK_LEVEL < 1) {\n      if (ux <= 0x407B53D1) {   // |x| ~<= 5π/4\n        if (ux <= 0x4016CBE3) { // |x| ~<= 3π/4\n          if (sign) {\n            sincos_sin = -cos_kernf(x + s1pio2);\n            sincos_cos =  sin_kernf(x + s1pio2);\n          } else {\n            sincos_sin = cos_kernf(s1pio2 - x);\n            sincos_cos = sin_kernf(s1pio2 - x);\n          }\n          return;\n        }\n        // -sin(x + c) is not correct if x+c could be 0: -0 vs +0\n        sincos_sin = -sin_kernf(sign ? x + s2pio2 : x - s2pio2);\n        sincos_cos = -cos_kernf(sign ? x + s2pio2 : x - s2pio2);\n        return;\n      }\n      if (ux <= 0x40E231D5) {   // |x| ~<= 9π/4\n        if (ux <= 0x40AFEDDF) { // |x| ~<= 7π/4\n          if (sign) {\n            sincos_sin =  cos_kernf(x + s3pio2);\n            sincos_cos = -sin_kernf(x + s3pio2);\n          } else {\n            sincos_sin = -cos_kernf(x - s3pio2);\n            sincos_cos =  sin_kernf(x - s3pio2);\n          }\n          return;\n        }\n        sincos_sin = sin_kernf(sign ? x + s4pio2 : x - s4pio2);\n        sincos_cos = cos_kernf(sign ? x + s4pio2 : x - s4pio2);\n        return;\n      }\n    }\n    // sin(Inf or NaN) is NaN\n    if (ux >= 0x7F800000) {\n      let xx = x - x;\n      sincos_sin = xx;\n      sincos_cos = xx;\n      return;\n    }\n    // general argument reduction needed\n    let n = rempio2f(x, ux, sign);\n    let y = rempio2f_y;\n    let s = sin_kernf(y);\n    let c = cos_kernf(y);\n    let sin = s, cos = c;\n    if (n & 1) {\n      sin =  c;\n      cos = -s;\n    }\n    if (n & 2) {\n      sin = -sin;\n      cos = -cos;\n    }\n    sincos_sin = sin;\n    sincos_cos = cos;\n  }\n}\n\nexport function ipow32(x: i32, e: i32): i32 {\n  let out = 1;\n  if (ASC_SHRINK_LEVEL < 1) {\n    if (x == 2) {\n      return select<i32>(1 << e, 0, <u32>e < 32);\n    }\n    if (e <= 0) {\n      if (x == -1) return select<i32>(-1, 1, e & 1);\n      return i32(e == 0) | i32(x == 1);\n    }\n    else if (e == 1) return x;\n    else if (e == 2) return x * x;\n    else if (e < 32) {\n      let log = 32 - clz(e);\n      // 32 = 2 ^ 5, so need only five cases.\n      // But some extra cases needs for properly overflowing\n      switch (log) {\n        case 5: {\n          if (e & 1) out *= x;\n          e >>>= 1;\n          x *= x;\n        }\n        case 4: {\n          if (e & 1) out *= x;\n          e >>>= 1;\n          x *= x;\n        }\n        case 3: {\n          if (e & 1) out *= x;\n          e >>>= 1;\n          x *= x;\n        }\n        case 2: {\n          if (e & 1) out *= x;\n          e >>>= 1;\n          x *= x;\n        }\n        case 1: {\n          if (e & 1) out *= x;\n        }\n      }\n      return out;\n    }\n  }\n  while (e) {\n    if (e & 1) out *= x;\n    e >>>= 1;\n    x *= x;\n  }\n  return out;\n}\n\nexport function ipow64(x: i64, e: i64): i64 {\n  let out: i64 = 1;\n  if (ASC_SHRINK_LEVEL < 1) {\n    if (x == 2) {\n      return select<i64>(1 << e, 0, <u64>e < 64);\n    }\n    if (e <= 0) {\n      if (x == -1) return select<i64>(-1, 1, e & 1);\n      return i64(e == 0) | i64(x == 1);\n    }\n    else if (e == 1) return x;\n    else if (e == 2) return x * x;\n    else if (e < 64) {\n      let log = 64 - <i32>clz(e);\n      // 64 = 2 ^ 6, so need only six cases.\n      // But some extra cases needs for properly overflowing\n      switch (log) {\n        case 6: {\n          if (e & 1) out *= x;\n          e >>>= 1;\n          x *= x;\n        }\n        case 5: {\n          if (e & 1) out *= x;\n          e >>>= 1;\n          x *= x;\n        }\n        case 4: {\n          if (e & 1) out *= x;\n          e >>>= 1;\n          x *= x;\n        }\n        case 3: {\n          if (e & 1) out *= x;\n          e >>>= 1;\n          x *= x;\n        }\n        case 2: {\n          if (e & 1) out *= x;\n          e >>>= 1;\n          x *= x;\n        }\n        case 1: {\n          if (e & 1) out *= x;\n        }\n      }\n      return out;\n    }\n  }\n  while (e) {\n    if (e & 1) out *= x;\n    e >>>= 1;\n    x *= x;\n  }\n  return out;\n}\n\n/*\nTODO:\nIn compile time if only exponent is constant we could replace ipow32/ipow64 by shortest addition chains\nwhich usually faster than exponentiation by squaring\n\nfor ipow32 and e < 32:\n\nlet b: i32, c: i32, d: i32, h: i32, k: i32, g: i32;\nswitch (e) {\n  case  1: return x;\n  case  2: return x * x;\n  case  3: return x * x * x;\n  case  4: return (b = x * x) * b;\n  case  5: return (b = x * x) * b * x;\n  case  6: return (b = x * x) * b * b;\n  case  7: return (b = x * x) * b * b * x;\n  case  8: return (d = (b = x * x) * b) * d;\n  case  9: return (c = x * x * x) * c * c;\n  case 10: return (d = (b = x * x) * b) * d * b;\n  case 11: return (d = (b = x * x) * b) * d * b * x;\n  case 12: return (d = (b = x * x) * b) * d * d;\n  case 13: return (d = (b = x * x) * b) * d * d * x;\n  case 14: return (d = (b = x * x) * b) * d * d * b;\n  case 15: return (k = (b = x * x) * b * x) * k * k;\n  case 16: return (h = (d = (b = x * x) * b) * d) * h;\n  case 17: return (h = (d = (b = x * x) * b) * d) * h * x;\n  case 18: return (h = (d = (b = x * x) * b) * d * x) * h;\n  case 19: return (h = (d = (b = x * x) * b) * d * x) * h * x;\n  case 20: return (h = (k = (b = x * x) * b * x) * k) * h;\n  case 21: return (h = (k = (b = x * x) * b * x) * k) * h * x;\n  case 22: return (g = (h = (k = (b = x * x) * b * x) * k) * x) * g;\n  case 23: return (h = (d = (c = (b = x * x) * x) * b) * d) * h * c;\n  case 24: return (h = (d = (c = x * x * x) * c) * d) * h;\n  case 25: return (h = (d = (c = x * x * x) * c) * d) * h * x;\n  case 26: return (g = (h = (d = (c = x * x * x) * c) * d) * x) * g;\n  case 27: return (h = (d = (c = x * x * x) * c) * d) * h * c;\n  case 28: return (h = (d = (c = x * x * x) * c * x) * d) * h;\n  case 29: return (h = (d = (c = x * x * x) * c * x) * d) * h * x;\n  case 30: return (h = (d = (c = x * x * x) * c) * d * c) * h;\n  case 31: return (h = (d = (c = x * x * x) * c) * d * c) * h * x;\n}\n\nfor ipow64: TODO\nswitch (e) {\n  case 32:\n  ...\n  case 63:\n}\n*/\n","export type Int = i32;\n\nexport type Float = f32;\n\nexport type Vec = StaticArray<Float>;\n\nexport type ReadonlyVec = Vec;\n\nexport type Vec2 = Vec;\n\nexport type Vec3 = Vec;\n\nexport type Vec4 = Vec;\n\nexport type ReadonlyVec2 = Vec;\n\nexport type ReadonlyVec3 = Vec;\n\nexport type ReadonlyVec4 = Vec;\n\nexport type Mat2 = Vec;\n\nexport type Mat3 = Vec;\n\nexport type Mat4 = Vec;\n\nexport type ReadonlyMat2 = Vec;\n\nexport type ReadonlyMat3 = Vec;\n\nexport type ReadonlyMat4 = Vec;\n\nexport type Quat = Vec4;\n\nexport type ReadonlyQuat = ReadonlyVec4;\n\nexport type Plane = Vec4;\n\nexport type ReadonlyPlane = ReadonlyVec4;\n\nexport type Frustum = StaticArray<Plane>;\n\nexport type ReadonlyFrustum = StaticArray<ReadonlyPlane>;\n\nexport class AABB {\n  public constructor(\n    public readonly min: Vec3,\n    public readonly max: Vec3) {\n  }\n};\n\nexport type ReadonlyAABB = AABB;\n","import { Float } from './types';\n\n/**\n * The float epsilon.\n */\nexport const EPSILON: Float = 0.000001;\n\n/**\n * Check if 2 floats are equal within an epsilon.\n */\nexport function fequal(a: Float, b: Float, epsilon: Float = EPSILON): boolean {\n  return Math.abs(a - b) < epsilon;\n}\n\n/**\n * Composes a float from the magnitude of a and the sign of b, i.e. copysign(a, b) = sgn(b)|a|.\n */\nexport function copysign(a: Float, b: Float): Float {\n  return (Math.sign(b) * Math.abs(a)) as Float;\n}\n\n/**\n * Clamp a float to [min, max].\n */\nexport function clamp(x: Float, min: Float, max: Float): Float {\n  return x < min ? min : x > max ? max : x;\n}\n\n/**\n* Linear interpolates between 2 floats.\n*/\nexport function lerp(a: Float, b: Float, t: Float): Float {\n  return a * (1 - t) + b * t;\n}\n","import { Float, Int, ReadonlyVec, Vec } from './types';\nimport { EPSILON, fequal as fequalNum, lerp as lerpNum } from './scalar';\n\n// Temp variables\nconst m = new Array<Float>(16);\n\n/**\n * Generic function to copy elements from any array-like object to another.\n * @returns dst\n */\nexport function copy<T, U>(\n  src: T, dst: U, srcOffset: Int = 0, dstOffset: Int = 0,\n  // @ts-ignore: Skip type checking\n  count: Int = src.length - srcOffset\n): U {\n  for (let i = 0; i < count; ++i) {\n    // @ts-ignore: Skip type checking\n    unchecked(dst[dstOffset + i] = src[srcOffset + i]);\n  }\n  return dst;\n}\n\n/**\n * Checks if 2 number arrays have equal length and equal values within an epsilon.\n * @returns a == b\n */\nexport function fequal(a: ReadonlyVec, b: ReadonlyVec, epsilon: Float = EPSILON): boolean {\n  if (a.length - b.length) {\n    return false;\n  }\n  for (let i = 0; i < a.length; ++i) {\n    if (!unchecked(fequalNum(a[i], b[i], epsilon))) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Sums 2 vectors.\n * @returns out = a + b\n */\nexport function add(a: ReadonlyVec, b: ReadonlyVec, out: Vec): Vec {\n  for (let i = 0; i < a.length; ++i) {\n    unchecked(out[i] = a[i] + b[i]);\n  }\n  return out;\n}\n\n/**\n * Subtracts 2 vectors.\n * @returns out = a - b\n */\nexport function sub(a: ReadonlyVec, b: ReadonlyVec, out: Vec): Vec {\n  for (let i = 0; i < a.length; ++i) {\n    unchecked(out[i] = a[i] - b[i]);\n  }\n  return out;\n}\n\n/**\n * Scales a vector by a constant.\n * @returns out = s * a\n */\nexport function scale(a: ReadonlyVec, s: Float, out: Vec): Vec {\n  for (let i = 0; i < a.length; ++i) {\n    unchecked(out[i] = a[i] * s);\n  }\n  return out;\n}\n\n/**\n * Calculates matrix multiplication of a * b, where size of a is (rr * n), and b is (n * rc).\n * @param n matrix order\n * @param a matrix of size rr * n\n * @param b matrix of size n * rc\n * @param out the output matrix of size rr * rc\n * @returns out = a * b\n */\n export function mul(n: Int, a: ReadonlyVec, b: ReadonlyVec, out: Vec): Vec {\n  const rr = (a.length / n) as Int;\n  const rc = (b.length / n) as Int;\n  let f: Float = 0;\n  m.length = rr * rc;\n\n  for (let i = 0; i < rc; ++i) {\n    for (let j = 0; j < rr; ++j) {\n      f = 0;\n      for (let k = 0; k < n; ++k) {\n        f += unchecked(a[k * rr + j] * b[i * n + k]);\n      }\n      unchecked(m[i * rr + j] = f);\n    }\n  }\n  copy(m, out, 0, 0, m.length);\n\n  return out;\n}\n\n/**\n * Lerp 2 vectors.\n * @returns out = lerp(a, b, t)\n */\nexport function lerp(a: ReadonlyVec, b: ReadonlyVec, t: Float, out: Vec): Vec {\n  for (let i = 0; i < a.length; ++i) {\n    unchecked(out[i] = lerpNum(a[i], b[i], t));\n  }\n  return out;\n}\n\n/**\n * Calculates the dot product of a 2 vectors.\n * @returns a * b\n */\nexport function dot(a: ReadonlyVec, b: ReadonlyVec): Float {\n  let f: Float = 0;\n  for (let i = 0; i < a.length; ++i) {\n    f += unchecked(a[i] * b[i]);\n  }\n  return f;\n}\n\n/**\n * Transposes a matrix.\n * @param n matrix order\n * @param m the matrix\n * @param out the output matrix\n * @returns out = [M]T\n */\nexport function transpose(n: Int, m: ReadonlyVec, out: Vec): Vec {\n  let f: Float = 0;\n  for (let i = 0; i < n; ++i) {\n    for (let j = i; j < n; ++j) {\n      // Swap mij and mji\n      f = unchecked(m[j * n + i]);\n      unchecked(out[j * n + i] = m[i * n + j]);\n      unchecked(out[i * n + j] = f);\n    }\n  }\n  return out;\n}\n","import { Float, ReadonlyMat3, ReadonlyMat4, ReadonlyVec3, Vec3, Vec4 } from './types';\nimport * as mat from './mat';\nimport * as vec4 from './vec4';\n\n// Temp variables\nconst v: Vec3 = create();\nconst v4a: Vec4 = vec4.create();\nconst v4b: Vec4 = vec4.create();\n\n/**\n * Create a new {@link Vec3}.\n * @param x defaults to 0\n * @param y defaults to 0\n * @param z defaults to 0\n * @returns [x, y, z]\n */\nexport function create(x: Float = 0, y: Float = 0, z: Float = 0): Vec3 {\n  return [x, y, z];\n}\n\n/**\n * Set values of a {@link Vec3}.\n * @param v the vec\n * @param x defaults to 0\n * @param y defaults to 0\n * @param z defaults to 0\n * @returns v\n */\nexport function set(v: Vec3, x: Float = 0, y: Float = 0, z: Float = 0): Vec3 {\n  unchecked(v[0] = x);\n  unchecked(v[1] = y);\n  unchecked(v[2] = z);\n  return v;\n}\n\n/**\n * Copy a {@link Vec3}.\n * @returns out\n */\nexport function copy(v: ReadonlyVec3, out: Vec3 = create()): Vec3 {\n  return mat.copy(v, out) as Vec3;\n}\n\n/**\n * Sum 2 {@link Vec3}.\n * @returns out = a + b\n */\nexport function add(a: ReadonlyVec3, b: ReadonlyVec3, out: Vec3 = create()): Vec3 {\n  return mat.add(a, b, out) as Vec3;\n}\n\n/**\n * Subtract 2 {@link Vec3}.\n * @returns out = a - b\n */\nexport function sub(a: ReadonlyVec3, b: ReadonlyVec3, out: Vec3 = create()): Vec3 {\n  return mat.sub(a, b, out) as Vec3;\n}\n\n/**\n * Multiply a {@link Vec3} by a constant.\n * @returns out = s * v\n */\nexport function scale(v: ReadonlyVec3, s: Float, out: Vec3 = create()): Vec3 {\n  return mat.scale(v, s, out) as Vec3;\n}\n\n/**\n * Multiply a {@link ReadonlyMat3} with a {@link Vec3}.\n * @returns out = m * v\n */\nexport function mmul(a: ReadonlyMat3, b: ReadonlyVec3, out: Vec3 = create()): Vec3 {\n  return mat.mul(3, a, b, out) as Vec3;\n}\n\n/**\n * Transform a {@link ReadonlyVec3} by a {@link ReadonlyMat4}.\n * @returns out = m * [x 1]\n */\nexport function mmul4(m: ReadonlyMat4, x: ReadonlyVec3, out: Vec3 = create()): Vec3 {\n  unchecked(vec4.set(v4a, x[0], x[1], x[2], 1));\n  return mat.copy(mat.mul(4, m, v4a, v4b), out, 0, 0, 3) as Vec3;\n}\n\n/**\n * Calculate the dot product of 2 {@link Vec3}.\n * @returns a * b\n */\nexport function dot(a: ReadonlyVec3, b: ReadonlyVec3): Float {\n  return mat.dot(a, b);\n}\n\n/**\n * Linear interpolate 2 {@link Vec3}.\n * @returns out = lerp(a, b, t)\n */\nexport function lerp(a: ReadonlyVec3, b: ReadonlyVec3, t: Float, out: Vec3 = create()): Vec3 {\n  return mat.lerp(a, b, t, out) as Vec3;\n}\n\n/**\n * Calculate squared length of a {@link Vec3}.\n * @returns dot(v, v)\n */\nexport function sqrLen(v: ReadonlyVec3): Float {\n  return dot(v, v);\n}\n\n/**\n * Calculate length of a {@link Vec3}.\n * @returns |v|\n */\nexport function len(v: ReadonlyVec3): Float {\n  return Math.sqrt(dot(v, v)) as Float;\n}\n\n/**\n * Calculate Euclidean distance of 2 {@link Vec3}.\n * @returns |a - b|\n */\nexport function dist(a: ReadonlyVec3, b: ReadonlyVec3): Float {\n  return len(sub(a, b, v));\n}\n\n/**\n * Normalize a {@link Vec3} and optionally stores result to the out param.\n * @returns v/|v|\n */\nexport function norm(v: ReadonlyVec3, out: Vec3 = create()): Vec3 {\n  return mat.scale(v, 1 / (len(v) || 1), out) as Vec3;\n}\n\n/**\n * Calculate cross product of 2 {@link Vec3}.\n * @returns out = a x b\n */\nexport function cross(a: ReadonlyVec3, b: ReadonlyVec3, out: Vec3 = create()): Vec3 {\n  const y: Float = unchecked(a[2] * b[0] - b[2] * a[0]);\n  const z: Float = unchecked(a[0] * b[1] - b[0] * a[1]);\n  unchecked(out[0] = a[1] * b[2] - b[1] * a[2]);\n  unchecked(out[1] = y);\n  unchecked(out[2] = z);\n  return out;\n}\n","/// <reference path=\"./rt/index.d.ts\" />\n\nimport { OBJECT, BLOCK_MAXSIZE, TOTAL_OVERHEAD } from \"./rt/common\";\nimport { Runtime } from \"shared/runtime\";\nimport { COMPARATOR, SORT } from \"./util/sort\";\nimport { REVERSE, FILL } from \"./util/bytes\";\nimport { idof } from \"./builtins\";\nimport { Array } from \"./array\";\nimport { E_INDEXOUTOFRANGE, E_INVALIDLENGTH, E_HOLEYARRAY } from \"./util/error\";\nimport { joinBooleanArray, joinIntegerArray, joinFloatArray, joinStringArray, joinReferenceArray } from \"./util/string\";\n\n@final\nexport class StaticArray<T> {\n  [key: number]: T;\n\n  // Note that the interface of StaticArray instances must be a semantically\n  // compatible subset of Array<T> in order for syntax highlighting to work\n  // properly, for instance when creating static arrays from array literals.\n  // The additionally provided static methods take care of dealing with static\n  // arrays exclusively, without having to convert to Array<T> first.\n\n  static fromArray<T>(source: Array<T>): StaticArray<T> {\n    let length = source.length;\n    let outSize = <usize>length << alignof<T>();\n    let out = changetype<StaticArray<T>>(__new(outSize, idof<StaticArray<T>>()));\n    if (isManaged<T>()) {\n      let sourcePtr = source.dataStart;\n      for (let i = 0; i < length; ++i) {\n        let off = <usize>i << alignof<T>();\n        let ref = load<usize>(sourcePtr + off);\n        store<usize>(changetype<usize>(out) + off, ref);\n        __link(changetype<usize>(out), ref, true);\n      }\n    } else {\n      memory.copy(changetype<usize>(out), source.dataStart, outSize);\n    }\n    return out;\n  }\n\n  /** @deprecated Please use source.concat<StaticArray<T>> instead. */\n  static concat<T>(source: StaticArray<T>, other: StaticArray<T>): StaticArray<T> {\n    return source.concat<StaticArray<T>>(other);\n  }\n\n  /** @deprecated Please use source.slice<StaticArray<T>> instead. */\n  static slice<T>(source: StaticArray<T>, start: i32 = 0, end: i32 = i32.MAX_VALUE): StaticArray<T> {\n    return source.slice<StaticArray<T>>(start, end);\n  }\n\n  constructor(length: i32) {\n    if (<u32>length > <u32>BLOCK_MAXSIZE >>> alignof<T>()) throw new RangeError(E_INVALIDLENGTH);\n    let outSize = <usize>length << alignof<T>();\n    let out = changetype<StaticArray<T>>(__new(outSize, idof<StaticArray<T>>()));\n    if (ASC_RUNTIME != Runtime.Incremental) {\n      memory.fill(changetype<usize>(out), 0, outSize);\n    }\n    return out;\n  }\n\n  get length(): i32 {\n    return changetype<OBJECT>(changetype<usize>(this) - TOTAL_OVERHEAD).rtSize >>> alignof<T>();\n  }\n\n  at(index: i32): T {\n    let len = this.length;\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    let value = load<T>(changetype<usize>(this) + (<usize>index << alignof<T>()));\n    if (isReference<T>()) {\n      if (!isNullable<T>()) {\n        if (!changetype<usize>(value)) throw new Error(E_HOLEYARRAY);\n      }\n    }\n    return value;\n  }\n\n  @operator(\"[]\") private __get(index: i32): T {\n    if (<u32>index >= <u32>this.length) throw new RangeError(E_INDEXOUTOFRANGE);\n    let value = load<T>(changetype<usize>(this) + (<usize>index << alignof<T>()));\n    if (isReference<T>()) {\n      if (!isNullable<T>()) {\n        if (!changetype<usize>(value)) throw new Error(E_HOLEYARRAY);\n      }\n    }\n    return value;\n  }\n\n  @unsafe @operator(\"{}\") private __uget(index: i32): T {\n    return load<T>(changetype<usize>(this) + (<usize>index << alignof<T>()));\n  }\n\n  @operator(\"[]=\") private __set(index: i32, value: T): void {\n    if (<u32>index >= <u32>this.length) throw new RangeError(E_INDEXOUTOFRANGE);\n    this.__uset(index, value);\n  }\n\n  @unsafe @operator(\"{}=\") private __uset(index: i32, value: T): void {\n    store<T>(changetype<usize>(this) + (<usize>index << alignof<T>()), value);\n    if (isManaged<T>()) {\n      __link(changetype<usize>(this), changetype<usize>(value), true);\n    }\n  }\n\n  fill(value: T, start: i32 = 0, end: i32 = i32.MAX_VALUE): StaticArray<T> {\n    if (isManaged<T>()) {\n      FILL<usize>(changetype<usize>(this), this.length, changetype<usize>(value), start, end);\n      __link(changetype<usize>(this), changetype<usize>(value), false);\n    } else {\n      FILL<T>(changetype<usize>(this), this.length, value, start, end);\n    }\n    return this;\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): StaticArray<T> {\n    let ptr = changetype<usize>(this);\n    let len = this.length;\n\n    end = min<i32>(end, len);\n\n    let to    = target < 0 ? max(len + target, 0) : min(target, len);\n    let from  = start < 0 ? max(len + start, 0) : min(start, len);\n    let last  = end < 0 ? max(len + end, 0) : min(end, len);\n    let count = min(last - from, len - to);\n\n    memory.copy( // is memmove\n      ptr + (<usize>to << alignof<T>()),\n      ptr + (<usize>from << alignof<T>()),\n      <usize>count << alignof<T>()\n    );\n    return this;\n  }\n\n  includes(value: T, fromIndex: i32 = 0): bool {\n    if (isFloat<T>()) {\n      let length = this.length;\n      if (length == 0 || fromIndex >= length) return false;\n      if (fromIndex < 0) fromIndex = max(length + fromIndex, 0);\n      while (fromIndex < length) {\n        let elem = load<T>(changetype<usize>(this) + (<usize>fromIndex << alignof<T>()));\n        // @ts-ignore\n        if (elem == value || isNaN(elem) & isNaN(value)) return true;\n        ++fromIndex;\n      }\n      return false;\n    } else {\n      return this.indexOf(value, fromIndex) >= 0;\n    }\n  }\n\n  indexOf(value: T, fromIndex: i32 = 0): i32 {\n    let length = this.length;\n    if (length == 0 || fromIndex >= length) return -1;\n    if (fromIndex < 0) fromIndex = max(length + fromIndex, 0);\n    while (fromIndex < length) {\n      if (load<T>(changetype<usize>(this) + (<usize>fromIndex << alignof<T>())) == value) return fromIndex;\n      ++fromIndex;\n    }\n    return -1;\n  }\n\n  lastIndexOf(value: T, fromIndex: i32 = this.length): i32 {\n    let length = this.length;\n    if (length == 0) return -1;\n    if (fromIndex < 0) fromIndex = length + fromIndex;\n    else if (fromIndex >= length) fromIndex = length - 1;\n    while (fromIndex >= 0) {\n      if (load<T>(changetype<usize>(this) + (<usize>fromIndex << alignof<T>())) == value) return fromIndex;\n      --fromIndex;\n    }\n    return -1;\n  }\n\n  concat<U extends ArrayLike<T> = Array<T>>(other: U): U {\n    let sourceLen = this.length;\n    let otherLen = other.length;\n    let outLen = sourceLen + otherLen;\n    if (<u32>outLen > <u32>BLOCK_MAXSIZE >>> alignof<T>()) {\n      throw new Error(E_INVALIDLENGTH);\n    }\n    let sourceSize = <usize>sourceLen << alignof<T>();\n    let out = changetype<U>(this); // FIXME: instanceof needs *some* value\n\n    if (out instanceof Array<T>) {\n      out = changetype<U>(__newArray(outLen, alignof<T>(), idof<Array<T>>()));\n      // ^ FIXME: Function returns type U, but can't __newArray(U extends Array<T>)\n      let outStart = changetype<Array<T>>(out).dataStart;\n      let otherStart = changetype<Array<T>>(other).dataStart;\n      let thisStart = changetype<usize>(this);\n\n      if (isManaged<T>()) {\n        for (let offset: usize = 0; offset < sourceSize; offset += sizeof<T>()) {\n          let ref = load<usize>(thisStart + offset);\n          store<usize>(outStart + offset, ref);\n          __link(changetype<usize>(out), ref, true);\n        }\n        outStart += sourceSize;\n        let otherSize = <usize>otherLen << alignof<T>();\n        for (let offset: usize = 0; offset < otherSize; offset += sizeof<T>()) {\n          let ref = load<usize>(otherStart + offset);\n          store<usize>(outStart + offset, ref);\n          __link(changetype<usize>(out), ref, true);\n        }\n      } else {\n        memory.copy(outStart, thisStart, sourceSize);\n        memory.copy(outStart + sourceSize, otherStart, <usize>otherLen << alignof<T>());\n      }\n    } else if (out instanceof StaticArray<T>) {\n      out = changetype<U>(__new(<usize>outLen << alignof<T>(), idof<StaticArray<T>>()));\n      let outStart = changetype<usize>(out);\n      let otherStart = changetype<usize>(other);\n      let thisStart = changetype<usize>(this);\n\n      if (isManaged<T>()) {\n        for (let offset: usize = 0; offset < sourceSize; offset += sizeof<T>()) {\n          let ref = load<usize>(thisStart + offset);\n          store<usize>(outStart + offset, ref);\n          __link(outStart, ref, true);\n        }\n        outStart += sourceSize;\n        let otherSize = <usize>otherLen << alignof<T>();\n        for (let offset: usize = 0; offset < otherSize; offset += sizeof<T>()) {\n          let ref = load<usize>(otherStart + offset);\n          store<usize>(outStart + offset, ref);\n          __link(outStart, ref, true);\n        }\n      } else {\n        memory.copy(outStart, thisStart, sourceSize);\n        memory.copy(outStart + sourceSize, otherStart, <usize>otherLen << alignof<T>());\n      }\n    } else {\n      ERROR(\"Only Array<T> and StaticArray<T> accept for 'U' parameter\");\n    }\n    return out;\n  }\n\n  slice<U extends ArrayLike<T> = Array<T>>(start: i32 = 0, end: i32 = i32.MAX_VALUE): U {\n    let length = this.length;\n    start = start < 0 ? max(start + length, 0) : min(start, length);\n    end   = end   < 0 ? max(end   + length, 0) : min(end,   length);\n    length = max(end - start, 0);\n\n    let sourceStart = changetype<usize>(this) + (<usize>start << alignof<T>());\n    let size = <usize>length << alignof<T>();\n    let out = changetype<U>(this); // FIXME: instanceof needs *some* value\n\n    if (out instanceof Array<T>) {\n      // return Array\n      out = changetype<U>(__newArray(length, alignof<T>(), idof<Array<T>>()));\n      // ^ FIXME: Function returns type U, but can't __newArray(U extends Array<T>)\n      let outStart = changetype<Array<T>>(out).dataStart;\n      if (isManaged<T>()) {\n        let off: usize = 0;\n        while (off < size) {\n          let ref = load<usize>(sourceStart + off);\n          store<usize>(outStart + off, ref);\n          __link(changetype<usize>(out), ref, true);\n          off += sizeof<usize>();\n        }\n      } else {\n        memory.copy(outStart, sourceStart, size);\n      }\n    } else if (out instanceof StaticArray<T>) {\n      // return StaticArray\n      out = changetype<U>(__new(size, idof<StaticArray<T>>()));\n      let outStart = changetype<usize>(out);\n      if (isManaged<T>()) {\n        let off: usize = 0;\n        while (off < size) {\n          let ref = load<usize>(sourceStart + off);\n          store<usize>(outStart + off, ref);\n          __link(outStart, ref, true);\n          off += sizeof<usize>();\n        }\n      } else {\n        memory.copy(outStart, sourceStart, size);\n      }\n    } else {\n      ERROR(\"Only Array<T> and StaticArray<T> accept for 'U' parameter\");\n    }\n    return out;\n  }\n\n  findIndex(fn: (value: T, index: i32, array: StaticArray<T>) => bool): i32 {\n    for (let i = 0, len = this.length; i < len; ++i) {\n      if (fn(load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this)) return i;\n    }\n    return -1;\n  }\n\n  findLastIndex(fn: (value: T, index: i32, array: StaticArray<T>) => bool): i32 {\n    for (let i = this.length - 1; i >= 0; --i) {\n      if (fn(load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this)) return i;\n    }\n    return -1;\n  }\n\n  forEach(fn: (value: T, index: i32, array: StaticArray<T>) => void): void {\n    for (let i = 0, len = this.length; i < len; ++i) {\n      fn(load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this);\n    }\n  }\n\n  map<U>(fn: (value: T, index: i32, array: StaticArray<T>) => U): Array<U> {\n    let len = this.length;\n    let out = changetype<Array<U>>(__newArray(len, alignof<U>(), idof<Array<U>>()));\n    let outStart = out.dataStart;\n    for (let i = 0; i < len; ++i) {\n      let result = fn(load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this);\n      store<U>(outStart + (<usize>i << alignof<U>()), result);\n      if (isManaged<U>()) {\n        __link(changetype<usize>(out), changetype<usize>(result), true);\n      }\n    }\n    return out;\n  }\n\n  filter(fn: (value: T, index: i32, array: StaticArray<T>) => bool): Array<T> {\n    let result = changetype<Array<T>>(__newArray(0, alignof<T>(), idof<Array<T>>()));\n    for (let i = 0, len = this.length; i < len; ++i) {\n      let value = load<T>(changetype<usize>(this) + (<usize>i << alignof<T>()));\n      if (fn(value, i, this)) result.push(value);\n    }\n    return result;\n  }\n\n  reduce<U>(\n    fn: (previousValue: U, currentValue: T, currentIndex: i32, array: StaticArray<T>) => U,\n    initialValue: U\n  ): U {\n    let acc = initialValue;\n    for (let i = 0, len = this.length; i < len; ++i) {\n      acc = fn(acc, load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this);\n    }\n    return acc;\n  }\n\n  reduceRight<U>(\n    fn: (previousValue: U, currentValue: T, currentIndex: i32, array: StaticArray<T>) => U,\n    initialValue: U\n  ): U {\n    let acc = initialValue;\n    for (let i = this.length - 1; i >= 0; --i) {\n      acc = fn(acc, load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this);\n    }\n    return acc;\n  }\n\n  every(fn: (value: T, index: i32, array: StaticArray<T>) => bool): bool {\n    for (let i = 0, len = this.length; i < len; ++i) {\n      if (!fn(load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this)) return false;\n    }\n    return true;\n  }\n\n  some(fn: (value: T, index: i32, array: StaticArray<T>) => bool): bool {\n    for (let i = 0, len = this.length; i < len; ++i) {\n      if (fn(load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this)) return true;\n    }\n    return false;\n  }\n\n  sort(comparator: (a: T, b: T) => i32 = COMPARATOR<T>()): StaticArray<T> {\n    SORT<T>(changetype<usize>(this), this.length, comparator);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    if (isBoolean<T>())   return joinBooleanArray(changetype<usize>(this), this.length, separator);\n    if (isInteger<T>())   return joinIntegerArray<T>(changetype<usize>(this), this.length, separator);\n    if (isFloat<T>())     return joinFloatArray<T>(changetype<usize>(this), this.length, separator);\n    if (ASC_SHRINK_LEVEL < 1) {\n      if (isString<T>())  return joinStringArray(changetype<usize>(this), this.length, separator);\n    }\n    if (isReference<T>()) return joinReferenceArray<T>(changetype<usize>(this), this.length, separator);\n    ERROR(\"unspported element type\");\n    return <string>unreachable();\n  }\n\n  reverse(): StaticArray<T> {\n    REVERSE<T>(changetype<usize>(this), this.length);\n    return this;\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  // RT integration\n\n  @unsafe private __visit(cookie: u32): void {\n    if (isManaged<T>()) {\n      let cur = changetype<usize>(this);\n      let end = cur + changetype<OBJECT>(changetype<usize>(this) - TOTAL_OVERHEAD).rtSize;\n      while (cur < end) {\n        let val = load<usize>(cur);\n        if (val) __visit(val, cookie);\n        cur += sizeof<usize>();\n      }\n    }\n  }\n}\n","import { Float, ReadonlyMat4, ReadonlyVec3, ReadonlyVec4, Vec4 } from './types';\nimport * as mat from './mat';\n\n/**\n * Create a new {@link Vec4}.\n * @param x defaults to 0\n * @param y defaults to 0\n * @param z defaults to 0\n * @param w defaults to 0\n * @returns [x, y, z, w]\n */\nexport function create(x: Float = 0, y: Float = 0, z: Float = 0, w: Float = 0): Vec4 {\n  return [x, y, z, w];\n}\n\n/**\n * Set values of a {@link Vec4}.\n * @param v the vec\n * @param x defaults to 0\n * @param y defaults to 0\n * @param z defaults to 0\n * @param w defaults to 0\n * @returns v\n */\n export function set(v: Vec4, x: Float = 0, y: Float = 0, z: Float = 0, w: Float = 0): Vec4 {\n  unchecked(v[0] = x);\n  unchecked(v[1] = y);\n  unchecked(v[2] = z);\n  unchecked(v[3] = w);\n  return v;\n}\n\n/**\n * Create a {@link Vec4} from {@link ReadonlyVec3}.\n * @param v Vec3\n * @param out output Vec4\n * @returns [v[0], v[1], v[2], w]\n */\nexport function fromVec3(v: ReadonlyVec3, out: Vec4 = create()): Vec4 {\n  unchecked(out[0] = v[0]);\n  unchecked(out[1] = v[1]);\n  unchecked(out[2] = v[2]);\n  unchecked(out[3] = 0);\n  return out;\n}\n\n/**\n * Copy a {@link Vec4}.\n * @returns out\n */\nexport function copy(v: ReadonlyVec4, out: Vec4 = create()): Vec4 {\n  return mat.copy(v, out) as Vec4;\n}\n\n/**\n * Sum 2 {@link Vec4}.\n * @returns out = a + b\n */\nexport function add(a: ReadonlyVec4, b: ReadonlyVec4, out: Vec4 = create()): Vec4 {\n  return mat.add(a, b, out) as Vec4;\n}\n\n/**\n * Subtract 2 {@link Vec4}.\n * @returns out = a - b\n */\nexport function sub(a: ReadonlyVec4, b: ReadonlyVec4, out: Vec4 = create()): Vec4 {\n  return mat.sub(a, b, out) as Vec4;\n}\n\n/**\n * Multiply a {@link Vec4} by a constant.\n * @returns out = s * v\n */\nexport function scale(v: ReadonlyVec4, s: Float, out: Vec4 = create()): Vec4 {\n  return mat.scale(v, s, out) as Vec4;\n}\n\n/**\n * Multiply a {@link ReadonlyMat4} with a {@link Vec4}.\n * @returns out = m * v\n */\nexport function mmul(a: ReadonlyMat4, b: ReadonlyVec4, out: Vec4 = create()): Vec4 {\n  return mat.mul(4, a, b, out) as Vec4;\n}\n\n/**\n * Calculate the dot product of 2 {@link Vec4}.\n * @returns a * b\n */\nexport function dot(a: ReadonlyVec4, b: ReadonlyVec4): Float {\n  return mat.dot(a, b);\n}\n\n/**\n * Linear interpolate 2 {@link Vec4}.\n * @returns out = lerp(a, b, t)\n */\nexport function lerp(a: ReadonlyVec4, b: ReadonlyVec4, t: Float, out: Vec4 = create()): Vec4 {\n  return mat.lerp(a, b, t, out) as Vec4;\n}\n\n/**\n * Calculate squared length of a {@link Vec4}.\n * @returns dot(v, v)\n */\nexport function sqrLen(v: ReadonlyVec4): Float {\n  return dot(v, v);\n}\n\n/**\n * Calculate length of a {@link Vec4}.\n * @returns |v|\n */\nexport function len(v: ReadonlyVec4): Float {\n  return Math.sqrt(dot(v, v)) as Float;\n}\n\n/**\n * Normalize a {@link Vec4} and optionally stores result to the out param.\n * @returns v/|v|\n */\nexport function norm(v: ReadonlyVec4, out: Vec4 = create()): Vec4 {\n  return mat.scale(v, 1 / (len(v) || 1), out) as Vec4;\n}\n","import { AABB, Float, ReadonlyAABB, ReadonlyMat4, ReadonlyVec3, Vec3 } from './types';\nimport * as mat from './mat';\nimport * as vec3 from './vec3';\n\nconst v0: Vec3 = vec3.create();\nconst v1: Vec3 = vec3.create();\n\n/**\n * Create a new {@link AABB}.\n */\nexport function create(min: Vec3 = vec3.create(), max: Vec3 = vec3.create()): AABB {\n  return new AABB(min, max);\n}\n\n/**\n * Copy an {@link AABB}.\n */\nexport function copy(a: ReadonlyAABB, out: AABB = create()): AABB {\n  mat.copy(a.min, out.min);\n  mat.copy(a.max, out.max);\n  return out;\n}\n\n/**\n * Set values of an {@link AABB}.\n */\nexport function set(a: AABB, min: Vec3 = vec3.create(), max: Vec3 = vec3.create()): AABB {\n  mat.copy(min, a.min);\n  mat.copy(max, a.max);\n  return a;\n}\n\n/**\n * Calculate the union of 2 {@link ReadonlyAABB}s.\n */\nexport function union(a: ReadonlyAABB, b: ReadonlyAABB, out: AABB = create()): AABB {\n  unchecked(out.min[0] = Math.min(a.min[0], b.min[0]) as Float);\n  unchecked(out.min[1] = Math.min(a.min[1], b.min[1]) as Float);\n  unchecked(out.min[2] = Math.min(a.min[2], b.min[2]) as Float);\n  unchecked(out.max[0] = Math.max(a.max[0], b.max[0]) as Float);\n  unchecked(out.max[1] = Math.max(a.max[1], b.max[1]) as Float);\n  unchecked(out.max[2] = Math.max(a.max[2], b.max[2]) as Float);\n  return out;\n}\n\n/**\n * Calculate the intersection of 2 {@link ReadonlyAABB}s.\n */\nexport function intersection(a: ReadonlyAABB, b: ReadonlyAABB, out: AABB = create()): AABB {\n  unchecked(out.min[0] = Math.max(a.min[0], b.min[0]) as Float);\n  unchecked(out.min[1] = Math.max(a.min[1], b.min[1]) as Float);\n  unchecked(out.min[2] = Math.max(a.min[2], b.min[2]) as Float);\n  unchecked(out.max[0] = Math.min(a.max[0], b.max[0]) as Float);\n  unchecked(out.max[1] = Math.min(a.max[1], b.max[1]) as Float);\n  unchecked(out.max[2] = Math.min(a.max[2], b.max[2]) as Float);\n\n  // ensure max[i] >= min[i]\n  unchecked(out.max[0] = Math.max(out.min[0], out.max[0]) as Float);\n  unchecked(out.max[1] = Math.max(out.min[1], out.max[1]) as Float);\n  unchecked(out.max[2] = Math.max(out.min[2], out.max[2]) as Float);\n\n  return out;\n}\n\n/**\n * Efficient algorithm for transforming an {@link ReadonlyAABB}, taken from Graphics Gems.\n */\nexport function transform(a: ReadonlyAABB, m: ReadonlyMat4, out: AABB = create()): AABB {\n  // min: v0, max: v1\n  for (let i = 0; i < 3; ++i) {\n    unchecked(v0[i] = m[3 * 4 + i]);\n    unchecked(v1[i] = m[3 * 4 + i]);\n\n    for (let j = 0; j < 3; ++j) {\n      const x: Float = unchecked(a.min[j] * m[j * 4 + i]);\n      const y: Float = unchecked(a.max[j] * m[j * 4 + i]);\n      unchecked(v0[i] += Math.min(x, y) as Float);\n      unchecked(v1[i] += Math.max(x, y) as Float);\n    }\n  }\n\n  mat.copy(v0, out.min);\n  mat.copy(v1, out.max);\n  return out;\n}\n\n/**\n * Calculate the shortest signed displacement (vector distance) between the\n * {@link AABB} and the given point.\n */\nexport function displacement(box: ReadonlyAABB, point: ReadonlyVec3, out: Vec3 = vec3.create()): Vec3 {\n  // center: v0, extent: v1\n  vec3.add(box.min, box.max, v0);\n  vec3.sub(box.max, box.min, v1);\n  vec3.scale(v0, 0.5, v0);\n  vec3.scale(v1, 0.5, v1);\n\n  unchecked(out[0] = Math.abs(point[0] - v0[0]) - v1[0] as Float);\n  unchecked(out[1] = Math.abs(point[1] - v0[1]) - v1[1] as Float);\n  unchecked(out[2] = Math.abs(point[2] - v0[2]) - v1[2] as Float);\n  return out;\n}\n\n/**\n * Calculate the shortest signed distance between the {@link AABB} and the given point.\n */\nexport function dist(box: ReadonlyAABB, point: ReadonlyVec3): Float {\n  displacement(box, point, v0);\n\n  // If point is inside of the AABB, the shortest distance is the distance to closest plane\n  if (unchecked(v0[0] <= 0 && v0[1] <= 0 && v0[2] <= 0)) {\n    const dxy = Math.max(v0[0], v0[1]);\n    return Math.max(dxy, v0[2]) as Float;\n  }\n\n  unchecked(v0[0] = Math.max(0, v0[0]) as Float);\n  unchecked(v0[1] = Math.max(0, v0[1]) as Float);\n  unchecked(v0[2] = Math.max(0, v0[2]) as Float);\n  return vec3.len(v0);\n}\n\n/**\n * Checks whether the given point / sphere defined by center and radius intersects with given {@link ReadonlyAABB}.\n */\nexport function containsPoint(box: ReadonlyAABB, center: ReadonlyVec3, radius: Float = 0): boolean {\n  return dist(box, center) <= radius;\n}\n\n/**\n * Check whether 2 {@link ReadonlyAABB} intersect.\n */\nexport function intersect(a: ReadonlyAABB, b: ReadonlyAABB): boolean {\n  for (let i = 0; i < 3; ++i) {\n    if (unchecked(a.min[i] > b.max[i] || b.min[i] > a.max[i])) {\n      return false;\n    }\n  }\n  return true;\n}\n","import { Float, Plane, ReadonlyPlane, ReadonlyVec3, Vec3 } from './types';\nimport * as mat from './mat';\nimport * as vec3 from './vec3';\nimport * as vec4 from './vec4';\n\n// Temp variables\nconst v1: Vec3 = vec3.create();\nconst v2: Vec3 = vec3.create();\n\nexport { create, copy, set } from './vec4';\n\n/**\n * Build a normalized {@link Plane} from a normal and a point on plane.\n * Normalized plane has len(a, b, c) = 1.\n */\nexport function fromPointNormal(point: ReadonlyVec3, normal: ReadonlyVec3, out: Plane = vec4.create()): Plane {\n  vec3.norm(normal, v1);\n  unchecked(out[3] = -vec3.dot(v1, point));\n  return mat.copy(v1, out) as Plane;\n}\n\n/**\n * Build a normalized {@link Plane} from 3 points on plane.\n * The counter-clockwise face of triangle formed by a, b, c is considered the front face of the plane.\n * Normalized plane has len(a, b, c) = 1.\n */\nexport function fromPoints(a: ReadonlyVec3, b: ReadonlyVec3, c: ReadonlyVec3, out: Plane = vec4.create()): Plane {\n  return fromPointNormal(a, vec3.cross(vec3.sub(b, a, v1), vec3.sub(c, a, v2), v2), out);\n}\n\n/**\n * Normalize a {@link Plane} equation for correct distance calculation.\n * Normalized plane has len(a, b, c) = 1.\n */\nexport function norm(p: ReadonlyPlane, out: Plane = vec4.create()): Plane {\n  return unchecked(vec4.scale(p, 1 / ((Math.sqrt(p[0] * p[0] + p[1] * p[1] + p[2] * p[2]) as Float) || 1), out));\n}\n\n/**\n * Calculates the shortest signed distance from the given point q to a normalized {@link Plane} p.\n * Positive if q is on the same side of the plane as the plane normal; negative if it is on the opposite side.\n * Normalized plane has len(a, b, c) = 1.\n */\nexport function dist(p: ReadonlyPlane, q: ReadonlyVec3): Float {\n  return unchecked(p[0] * q[0] + p[1] * q[1] + p[2] * q[2] + p[3]);\n}\n","import {\n  Float, Frustum, Plane, ReadonlyAABB, ReadonlyFrustum, ReadonlyMat4, ReadonlyVec3, Vec3\n} from './types';\nimport * as vec3 from './vec3';\nimport * as plane from './plane';\n\nconst FRUSTUM_PLANES = 6;\n\n// Temp variables\nconst v0: Vec3 = vec3.create();\n\n/**\n * Create a new {@link Frustum} from the 6 normalized planes: left, right, bottom, top, near, far.\n */\nexport function create(\n  left: Plane = plane.create(), right: Plane = plane.create(),\n  bottom: Plane = plane.create(), top: Plane = plane.create(),\n  near: Plane = plane.create(), far: Plane = plane.create()\n): Frustum {\n  return [left, right, bottom, top, near, far];\n}\n\n/**\n * Copy a {@link Frustum}.\n */\n export function copy(a: ReadonlyFrustum, out: Frustum = create()): Frustum {\n  for (let i = 0; i < FRUSTUM_PLANES; ++i) {\n    plane.copy(a[i], out[i]);\n  }\n  return out;\n}\n\n/**\n * Build a {@link Frustum} in world space from a view-projection matrix (viewProj = proj * view) using Gribb/Hartmann method.\n * @see http://www8.cs.umu.se/kurser/5DV051/HT12/lab/plane_extraction.pdf\n */\nexport function fromViewProj(m: ReadonlyMat4, out: Frustum = create()): Frustum {\n  unchecked(plane.set(out[0], m[3] + m[0], m[7] + m[4], m[11] + m[8], m[15] + m[12])); // left\n  unchecked(plane.set(out[1], m[3] - m[0], m[7] - m[4], m[11] - m[8], m[15] - m[12])); // right\n\n  unchecked(plane.set(out[2], m[3] + m[1], m[7] + m[5], m[11] + m[9], m[15] + m[13])); // bottom\n  unchecked(plane.set(out[3], m[3] - m[1], m[7] - m[5], m[11] - m[9], m[15] - m[13])); // top\n\n  unchecked(plane.set(out[4], m[3] + m[2], m[7] + m[6], m[11] + m[10], m[15] + m[14])); // near\n  unchecked(plane.set(out[5], m[3] - m[2], m[7] - m[6], m[11] - m[10], m[15] - m[14])); // far\n\n  for (let i = 0; i < FRUSTUM_PLANES; ++i) {  // normalize all planes\n    plane.norm(out[i], out[i]);\n  }\n\n  return out;\n}\n\n/**\n * Checks whether the given point / sphere defined by center and radius intersects with given {@link ReadonlyFrustum}.\n */\nexport function containsPoint(f: ReadonlyFrustum, center: ReadonlyVec3, radius: Float = 0): boolean {\n  // Check the distance of the center to the planes\n  // Point is outside frustum if it falls into the negative half-space of any plane\n  for (let i = 0; i < FRUSTUM_PLANES; ++i) {\n    if (plane.dist(f[i], center) < -radius) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Checks whether the given {@link AABB} intersects with given {@link ReadonlyFrustum}.\n */\nexport function containsAABB(f: ReadonlyFrustum, box: ReadonlyAABB): boolean {\n  for (let i = 0; i < FRUSTUM_PLANES; ++i) {\n    // Find the corner at max distance\n    unchecked(v0[0] = (f[i][0] > 0) ? box.max[0] : box.min[0]);\n    unchecked(v0[1] = (f[i][1] > 0) ? box.max[1] : box.min[1]);\n    unchecked(v0[2] = (f[i][2] > 0) ? box.max[2] : box.min[2]);\n    if (plane.dist(f[i], v0) < 0) { // max point is still outside the plane\n      return false;\n    }\n  }\n  return true;\n}\n","import { Float, ReadonlyMat2, Mat2, ReadonlyMat3 } from './types';\nimport * as mat from './mat';\n\n// Temp variables\nconst m: Mat2 = create();\n\n/**\n * Create a new identity {@link Mat2}.\n * @returns identity Mat2\n */\nexport function create(): Mat2 {\n  return [1, 0, 0, 1];\n}\n\n/**\n * Set a {@link Mat2} to identity.\n * @returns out = I2\n */\nexport function id(out: Mat2): Mat2 {\n  unchecked(out[0] = out[3] = 1);\n  unchecked(out[1] = out[2] = 0);\n  return out;\n}\n\n/**\n * Create a {@link Mat2} from {@link ReadonlyMat3}.\n * @returns identity Mat2\n */\nexport function fromMat3(m: ReadonlyMat3, out: Mat2 = create()): Mat2 {\n  unchecked(out[0] = m[0]);\n  unchecked(out[1] = m[1]);\n  unchecked(out[2] = m[3]);\n  unchecked(out[3] = m[4]);\n  return out;\n}\n\n/**\n * Copy a {@link Mat2}.\n * @returns out\n */\nexport function copy(v: ReadonlyMat2, out: Mat2 = create()): Mat2 {\n  return mat.copy(v, out) as Mat2;\n}\n\n/**\n * Sum 2 {@link Mat2}.\n * @returns out = a + b\n */\nexport function add(a: ReadonlyMat2, b: ReadonlyMat2, out: Mat2 = create()): Mat2 {\n  return mat.add(a, b, out) as Mat2;\n}\n\n/**\n * Subtract 2 {@link Mat2}.\n * @returns out = a - b\n */\nexport function sub(a: ReadonlyMat2, b: ReadonlyMat2, out: Mat2 = create()): Mat2 {\n  return mat.sub(a, b, out) as Mat2;\n}\n\n/**\n * Multiply a {@link Mat2} by a constant.\n * @returns out = s * M\n */\nexport function scale(m: ReadonlyMat2, s: Float, out: Mat2 = create()): Mat2 {\n  return mat.scale(m, s, out) as Mat2;\n}\n\n/**\n * Transpose a {@link Mat2}.\n * @returns [M]T\n */\nexport function transpose(m: ReadonlyMat2, out: Mat2 = create()): Mat2 {\n  return mat.transpose(2, m, out) as Mat2;\n}\n\n/**\n * Multiply 2 {@link Mat2}.\n * @returns out = a * b\n */\nexport function mul(a: ReadonlyMat2, b: ReadonlyMat2, out: Mat2 = create()): Mat2 {\n  return mat.mul(2, a, b, out) as Mat2;\n}\n\n/**\n * Calculate the determinant of a {@link Mat2}.\n */\nexport function det(m: ReadonlyMat2): Float {\n  return unchecked(m[0] * m[3] - m[2] * m[1]);\n}\n\n/**\n * Returns inverse of a {@link Mat2}, or null if matrix is not invertible.\n * @param a input matrix\n * @param out output matrix\n * @returns out = M^-1, or null if matrix is not invertible\n */\nexport function invert(a: ReadonlyMat2, out: Mat2 = create()): Mat2 | null {\n  const detA: Float = det(a);\n  if (!detA) {\n    return null;\n  }\n\n  unchecked(m[0] = a[3]);\n  unchecked(m[1] = -a[1]);\n  unchecked(m[2] = -a[2]);\n  unchecked(m[3] = a[0]);\n\n  return scale(m, 1 / detA, out);\n}\n","import { Float, ReadonlyMat3, Mat3 } from './types';\nimport * as mat from './mat';\n\n// Temp variables\nconst m: Mat3 = create();\n\n/**\n * Create a new identity {@link Mat3}.\n * @returns identity mat3\n */\nexport function create(): Mat3 {\n  return [1, 0, 0, 0, 1, 0, 0, 0, 1];\n}\n\n/**\n * Set a {@link Mat3} to identity.\n * @returns out = I3\n */\nexport function id(out: Mat3): Mat3 {\n  for (let i = 0; i < 9; ++i) {\n    unchecked(out[i] = (i % 4) ? 0 : 1);\n  }\n  return out;\n}\n\n/**\n * Copy a {@link Mat3}.\n * @returns out\n */\nexport function copy(v: ReadonlyMat3, out: Mat3 = create()): Mat3 {\n  return mat.copy(v, out) as Mat3;\n}\n\n/**\n * Sum 2 {@link Mat3}.\n * @returns out = a + b\n */\nexport function add(a: ReadonlyMat3, b: ReadonlyMat3, out: Mat3 = create()): Mat3 {\n  return mat.add(a, b, out) as Mat3;\n}\n\n/**\n * Subtract 2 {@link Mat3}.\n * @returns out = a - b\n */\nexport function sub(a: ReadonlyMat3, b: ReadonlyMat3, out: Mat3 = create()): Mat3 {\n  return mat.sub(a, b, out) as Mat3;\n}\n\n/**\n * Multiply a {@link Mat3} by a constant.\n * @returns out = s * M\n */\nexport function scale(m: ReadonlyMat3, s: Float, out: Mat3 = create()): Mat3 {\n  return mat.scale(m, s, out) as Mat3;\n}\n\n/**\n * Transpose a {@link Mat3}.\n * @returns [M]T\n */\nexport function transpose(m: ReadonlyMat3, out: Mat3 = create()): Mat3 {\n  return mat.transpose(3, m, out) as Mat3;\n}\n\n/**\n * Multiply 2 {@link Mat3}.\n * @returns out = a * b\n */\nexport function mul(a: ReadonlyMat3, b: ReadonlyMat3, out: Mat3 = create()): Mat3 {\n  return mat.mul(3, a, b, out) as Mat3;\n}\n\n/**\n * Calculate the determinant of a {@link Mat3}.\n */\nexport function det(m: ReadonlyMat3): Float {\n  return unchecked(\n    m[0] * +(m[4] * m[8] - m[7] * m[5]) +\n    m[3] * -(m[1] * m[8] - m[7] * m[2]) +\n    m[6] * +(m[1] * m[5] - m[4] * m[2])\n  );\n}\n\n/**\n * Returns inverse of a {@link Mat3}, or null if matrix is not invertible.\n * @see https://en.wikipedia.org/wiki/Invertible_matrix#Inversion_of_3_%C3%97_3_matrices\n * @param a input matrix\n * @param out output matrix\n * @returns out = M^-1, or null if matrix is not invertible\n */\nexport function invert(a: ReadonlyMat3, out: Mat3 = create()): Mat3 | null {\n  const detA: Float = det(a);\n  if (!detA) {\n    return null;\n  }\n\n  unchecked(m[0] = +(a[4] * a[8] - a[7] * a[5]));\n  unchecked(m[1] = -(a[1] * a[8] - a[7] * a[2]));\n  unchecked(m[2] = +(a[1] * a[5] - a[4] * a[2]));\n  unchecked(m[3] = -(a[3] * a[8] - a[6] * a[5]));\n  unchecked(m[4] = +(a[0] * a[8] - a[6] * a[2]));\n  unchecked(m[5] = -(a[0] * a[5] - a[3] * a[2]));\n  unchecked(m[6] = +(a[3] * a[7] - a[6] * a[4]));\n  unchecked(m[7] = -(a[0] * a[7] - a[6] * a[1]));\n  unchecked(m[8] = +(a[0] * a[4] - a[3] * a[1]));\n\n  return scale(m, 1 / detA, out);\n}\n\n/**\n * Returns the normal matrix, which is the inverse transpose matrix, from a {@link ReadonlyMat3}.\n * @param a input matrix\n * @param out output matrix\n * @returns out = (M^-1)T, or null if matrix is not invertible\n */\nexport function nmat(a: ReadonlyMat3, out: Mat3 = create()): Mat3 | null {\n  if (!invert(a, out)) {\n    return null;\n  }\n  return transpose(out, out);\n}\n","import { Float, Mat3, Mat4, ReadonlyMat3, ReadonlyMat4 } from './types';\nimport * as mat3 from './mat3';\nimport * as mat from './mat';\n\n// Temp variables\nconst m: Mat4 = create();\n\n/**\n * Create a new identity {@link Mat4}.\n * @returns identity mat4\n */\nexport function create(): Mat4 {\n  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\n}\n\n/**\n * Set a {@link Mat4} to identity.\n * @returns out = I4\n */\nexport function id(out: Mat4): Mat4 {\n  for (let i = 0; i < 16; ++i) {\n    unchecked(out[i] = (i % 5) ? 0 : 1);\n  }\n  return out;\n}\n\n/**\n * Create a {@link Mat4} from {@link ReadonlyMat3}.\n * @param m input mat3\n * @param out output mat4\n * @returns out = [M 0 0 1]\n */\nexport function fromMat3(m: ReadonlyMat3, out: Mat4 = create()): Mat4 {\n  for (let i = 0; i < 3; ++i) {\n    for (let j = 0; j < 3; ++j) {\n      unchecked(out[i * 4 + j] = m[i * 3 + j]);\n    }\n    unchecked(out[i * 4 + 3] = 0);\n  }\n  unchecked(out[12] = out[13] = out[14] = 0);\n  unchecked(out[15] = 1);\n  return out;\n}\n\n/**\n * Create a {@link Mat3} from upper-left 3x3 of a {@link ReadonlyMat4}.\n * @param m input mat4\n * @param out output mat3\n * @returns out = mat3(M)\n */\nexport function toMat3(m: ReadonlyMat4, out: Mat3 = mat3.create()): Mat3 {\n  for (let i = 0; i < 3; ++i) {\n    for (let j = 0; j < 3; ++j) {\n      unchecked(out[i * 3 + j] = m[i * 4 + j]);\n    }\n  }\n  return out;\n}\n\n/**\n * Copy a {@link Mat4}.\n * @returns out\n */\nexport function copy(v: ReadonlyMat4, out: Mat4 = create()): Mat4 {\n  return mat.copy(v, out) as Mat4;\n}\n\n/**\n * Sum 2 {@link Mat4}.\n * @returns out = a + b\n */\nexport function add(a: ReadonlyMat4, b: ReadonlyMat4, out: Mat4 = create()): Mat4 {\n  return mat.add(a, b, out) as Mat4;\n}\n\n/**\n * Subtract 2 {@link Mat4}.\n * @returns out = a - b\n */\nexport function sub(a: ReadonlyMat4, b: ReadonlyMat4, out: Mat4 = create()): Mat4 {\n  return mat.sub(a, b, out) as Mat4;\n}\n\n/**\n * Multiply a {@link Mat4} by a constant.\n * @returns out = s * M\n */\nexport function scale(m: ReadonlyMat4, s: Float, out: Mat4 = create()): Mat4 {\n  return mat.scale(m, s, out) as Mat4;\n}\n\n/**\n * Transpose a {@link Mat4}.\n * @returns [M]T\n */\nexport function transpose(m: ReadonlyMat4, out: Mat4 = create()): Mat4 {\n  return mat.transpose(4, m, out) as Mat4;\n}\n\n/**\n * Multiply 2 {@link Mat4}.\n * @returns out = a * b\n */\nexport function mul(a: ReadonlyMat4, b: ReadonlyMat4, out: Mat4 = create()): Mat4 {\n  return mat.mul(4, a, b, out) as Mat4;\n}\n\n/**\n * Returns inverse of a {@link Mat4}, or null if matrix is not invertible.\n * @param a input matrix\n * @param out output matrix\n * @returns out = M^-1, or null if matrix is not invertible\n */\nexport function invert(a: ReadonlyMat4, out: Mat4 = create()): Mat4 | null {\n  const fA0: Float = unchecked(a[0] * a[5] - a[4] * a[1]);\n  const fA1: Float = unchecked(a[0] * a[9] - a[8] * a[1]);\n  const fA2: Float = unchecked(a[0] * a[13] - a[12] * a[1]);\n  const fA3: Float = unchecked(a[4] * a[9] - a[8] * a[5]);\n  const fA4: Float = unchecked(a[4] * a[13] - a[12] * a[5]);\n  const fA5: Float = unchecked(a[8] * a[13] - a[12] * a[9]);\n  const fB0: Float = unchecked(a[2] * a[7] - a[6] * a[3]);\n  const fB1: Float = unchecked(a[2] * a[11] - a[10] * a[3]);\n  const fB2: Float = unchecked(a[2] * a[15] - a[14] * a[3]);\n  const fB3: Float = unchecked(a[6] * a[11] - a[10] * a[7]);\n  const fB4: Float = unchecked(a[6] * a[15] - a[14] * a[7]);\n  const fB5: Float = unchecked(a[10] * a[15] - a[14] * a[11]);\n\n  const detA: Float = fA0 * fB5 - fA1 * fB4 + fA2 * fB3 + fA3 * fB2 - fA4 * fB1 + fA5 * fB0;\n\n  if (!detA) {\n    return null;\n  }\n\n  unchecked(m[0] = +a[5] * fB5 - a[9] * fB4 + a[13] * fB3);\n  unchecked(m[1] = -a[1] * fB5 + a[9] * fB2 - a[13] * fB1);\n  unchecked(m[2] = +a[1] * fB4 - a[5] * fB2 + a[13] * fB0);\n  unchecked(m[3] = -a[1] * fB3 + a[5] * fB1 - a[9] * fB0);\n  unchecked(m[4] = -a[4] * fB5 + a[8] * fB4 - a[12] * fB3);\n  unchecked(m[5] = +a[0] * fB5 - a[8] * fB2 + a[12] * fB1);\n  unchecked(m[6] = -a[0] * fB4 + a[4] * fB2 - a[12] * fB0);\n  unchecked(m[7] = +a[0] * fB3 - a[4] * fB1 + a[8] * fB0);\n  unchecked(m[8] = +a[7] * fA5 - a[11] * fA4 + a[15] * fA3);\n  unchecked(m[9] = -a[3] * fA5 + a[11] * fA2 - a[15] * fA1);\n  unchecked(m[10] = +a[3] * fA4 - a[7] * fA2 + a[15] * fA0);\n  unchecked(m[11] = -a[3] * fA3 + a[7] * fA1 - a[11] * fA0);\n  unchecked(m[12] = -a[6] * fA5 + a[10] * fA4 - a[14] * fA3);\n  unchecked(m[13] = +a[2] * fA5 - a[10] * fA2 + a[14] * fA1);\n  unchecked(m[14] = -a[2] * fA4 + a[6] * fA2 - a[14] * fA0);\n  unchecked(m[15] = +a[2] * fA3 - a[6] * fA1 + a[10] * fA0);\n\n  return scale(m, 1 / detA, out);\n}\n\n/**\n * Returns the 3x3 normal matrix, which is the inverse transpose matrix, from a {@link ReadonlyMat4}.\n * Returns null if original matrix is not invertible.\n * @param a input matrix\n * @param out output matrix\n * @returns out = (mat3(M)^-1)T, or null if matrix is not invertible\n */\nexport function nmat3(a: ReadonlyMat4, out: Mat3 = mat3.create()): Mat3 | null {\n  return mat3.nmat(toMat3(a, out), out)\n}\n","import { Float, Mat4, Quat, ReadonlyQuat, ReadonlyVec3, Vec, Vec3 } from './types';\nimport * as mat from './mat';\nimport * as mat4 from './mat4';\nimport * as vec3 from './vec3';\nimport * as vec4 from './vec4';\nimport { EPSILON, fequal } from './scalar';\n\n// Temp variables\nconst q1: Quat = create();\nconst q2: Quat = create();\n\n/**\n * Create a new identity {@link Quat}.\n * @returns [0, 0, 0, 1]\n */\nexport function create(): Quat {\n  return [0, 0, 0, 1];\n}\n\n/**\n * Create a {@link Quat} from a unit axis vector and rotation angle in couterclockwise direction.\n */\nexport function fromAxisAngle(axis: ReadonlyVec3, angle: Float, out: Quat = create()): Quat {\n  mat.scale(axis, Math.sin(angle / 2) as Float, out);\n  unchecked(out[3] = Math.cos(angle / 2) as Float);\n  return out;\n}\n\n/**\n * Returns a {@link Quat} from a rotation around x-axis in couterclockwise direction.\n * @returns the quat representing the rotation\n */\nexport function fromAngleX(angle: Float, out: Quat = create()): Quat {\n  unchecked(out[0] = Math.sin(angle / 2) as Float);\n  unchecked(out[3] = Math.cos(angle / 2) as Float);\n  unchecked(out[1] = out[2] = 0);\n  return out;\n}\n\n/**\n * Returns a {@link Quat} from a rotation around y-axis in couterclockwise direction.\n * @returns the quat representing the rotation\n */\nexport function fromAngleY(angle: Float, out: Quat = create()): Quat {\n  unchecked(out[1] = Math.sin(angle / 2) as Float);\n  unchecked(out[3] = Math.cos(angle / 2) as Float);\n  unchecked(out[0] = out[2] = 0);\n  return out;\n}\n\n/**\n * Returns a {@link Quat} from a rotation around z-axis in couterclockwise direction.\n * @returns the quat representing the rotation\n */\nexport function fromAngleZ(angle: Float, out: Quat = create()): Quat {\n  unchecked(out[2] = Math.sin(angle / 2) as Float);\n  unchecked(out[3] = Math.cos(angle / 2) as Float);\n  unchecked(out[0] = out[1] = 0);\n  return out;\n}\n\n/**\n * Returns a {@link Quat} that represents the shortest arc rotation between 2 unit vectors.\n * @returns the quat representing the rotation\n */\nexport function fromUnitVecs(from: ReadonlyVec3, to: ReadonlyVec3, out: Quat = create()): Quat {\n  const dot: Float = vec3.dot(from, to);\n\n  if (fequal(dot, -1)) { // vectors are in parallel but opposite direction\n    // use arbitrary perpendicular vector = (0, z, -y)\n    unchecked(out[0] = 0);\n    unchecked(out[1] = from[2]);\n    unchecked(out[2] = -from[1]);\n    return fromAxisAngle(out as Vec as Vec3, Math.PI as Float, out);\n  } else if (fequal(dot, 1)) { // vectors are in same direction\n    unchecked(out[0] = out[1] = out[2] = 0);\n    unchecked(out[3] = 1);\n    return out;\n  }\n\n  // store perpendicular vector to the xyz of out.\n  vec3.cross(from, to, out as Vec as Vec3);\n  unchecked(out[3] = 1 + dot);\n  return norm(out, out);\n}\n\n/**\n * Convert a {@link Quat} to a {@link Mat4}.\n * @returns Mat4\n */\nexport function toMat4(q: ReadonlyQuat, out: Mat4 = mat4.create()): Mat4 {\n  const\n    xx: Float = unchecked(q[0] * q[0]),\n    xy: Float = unchecked(q[0] * q[1]),\n    xz: Float = unchecked(q[0] * q[2]),\n    yy: Float = unchecked(q[1] * q[1]),\n    yz: Float = unchecked(q[1] * q[2]),\n    zz: Float = unchecked(q[2] * q[2]),\n    wx: Float = unchecked(q[3] * q[0]),\n    wy: Float = unchecked(q[3] * q[1]),\n    wz: Float = unchecked(q[3] * q[2]);\n\n  unchecked(out[0] = 1 - 2 * (yy + zz));\n  unchecked(out[1] = 2 * (xy + wz));\n  unchecked(out[2] = 2 * (xz - wy));\n  unchecked(out[4] = 2 * (xy - wz));\n  unchecked(out[5] = 1 - 2 * (xx + zz));\n  unchecked(out[6] = 2 * (yz + wx));\n  unchecked(out[8] = 2 * (xz + wy));\n  unchecked(out[9] = 2 * (yz - wx));\n  unchecked(out[10] = 1 - 2 * (xx + yy));\n\n  unchecked(out[3] = out[7] = out[11] = out[12] = out[13] = out[14] = 0);\n  unchecked(out[15] = 1);\n  return out;\n}\n\n/**\n * Copy a {@link Quat}.\n * @returns out\n */\nexport function copy(q: ReadonlyQuat, out: Quat = create()): Quat {\n  return mat.copy(q, out) as Quat;\n}\n\n/**\n * Calculate dot product between 2 {@link Quat}.\n * @returns a * b\n */\nexport const dot: (a: ReadonlyQuat, b: ReadonlyQuat) => Float = mat.dot;\n\n/**\n * Calculate squared length of a {@link ReadonlyQuat}.\n * @returns dot(v, v)\n */\nexport const sqrLen: (v: ReadonlyQuat) => Float = vec4.sqrLen;\n\n/**\n * Calculate length of a {@link Quat}.\n * @returns |v|\n */\nexport const len: (v: ReadonlyQuat) => Float = vec4.len;\n\n/**\n* Normalize a {@link Quat}.\n*/\nexport const norm: (q: ReadonlyQuat, out?: Quat) => Quat = vec4.norm;\n\n/**\n* Calculates the conjugate of a {@link Quat}.\n*/\nexport function conj(q: ReadonlyQuat, out: Quat = create()): Quat {\n  unchecked(out[0] = -q[0]);\n  unchecked(out[1] = -q[1]);\n  unchecked(out[2] = -q[2]);\n  unchecked(out[3] = q[3]);\n  return out;\n}\n\n/**\n* Calculate the inverse of a {@link Quat}.\n*/\nexport function invert(q: ReadonlyQuat, out: Quat = create()): Quat {\n  const l: Float = 1 / (sqrLen(q) || 1);\n  unchecked(out[0] = -q[0] * l);\n  unchecked(out[1] = -q[1] * l);\n  unchecked(out[2] = -q[2] * l);\n  unchecked(out[3] = q[3] * l);\n  return out;\n}\n\n/**\n * Calculate the Hamilton product of 2 {@link Quat}.\n * @returns out = a * b\n */\nexport function mul(a: ReadonlyQuat, b: ReadonlyQuat, out: Quat = create()): Quat {\n  const\n    ax: Float = unchecked(a[0]),\n    ay: Float = unchecked(a[1]),\n    az: Float = unchecked(a[2]),\n    aw: Float = unchecked(a[3]),\n    bx: Float = unchecked(b[0]),\n    by: Float = unchecked(b[1]),\n    bz: Float = unchecked(b[2]),\n    bw: Float = unchecked(b[3]);\n  unchecked(out[0] = aw * bx + ax * bw + ay * bz - az * by);\n  unchecked(out[1] = aw * by + ay * bw + az * bx - ax * bz);\n  unchecked(out[2] = aw * bz + az * bw + ax * by - ay * bx);\n  unchecked(out[3] = aw * bw - ax * bx - ay * by - az * bz);\n  return out;\n}\n\n/**\n * Rotate a {@link ReadonlyVec3} using a {@link ReadonlyQuat}, by the formula v' = q * v * q^-1\n * @see https://en.wikipedia.org/wiki/Quaternions_and_spatial_rotation#Using_quaternion_as_rotations\n * @returns out = q * v * q^-1\n */\nexport function rotateVec3(q: ReadonlyQuat, v: ReadonlyVec3, out: Vec3 = vec3.create()): Vec3 {\n  mat.copy(v, q1, 0, 0, 3);\n  unchecked(q1[3] = 0);\n  mul(mul(q, q1, q1), invert(q, q2), q1);\n  return mat.copy(q1, out, 0, 0, 3) as Vec3;\n}\n\n/**\n * Linear interpolate between 2 {@link Quat}.\n * @returns out = lerp(a, b, t)\n */\nexport function lerp(a: ReadonlyQuat, b: ReadonlyQuat, t: Float, out: Quat = create()): Quat {\n  const cosTheta: Float = dot(a, b);  // calculate cosine from dot product\n  const magB: Float = (cosTheta < 0) ? -1 : 1;\n\n  // use the shortest path and interpolate linearly\n  unchecked(out[0] = a[0] * (1 - t) + b[0] * magB * t);\n  unchecked(out[1] = a[1] * (1 - t) + b[1] * magB * t);\n  unchecked(out[2] = a[2] * (1 - t) + b[2] * magB * t);\n  unchecked(out[3] = a[3] * (1 - t) + b[3] * magB * t);\n\n  return norm(out);\n}\n\n/**\n * Spherical linear interpolate between 2 {@link Quat}.\n */\nexport function slerp(a: ReadonlyQuat, b: ReadonlyQuat, t: Float, out: Quat = create()): Quat {\n  let cosTheta: Float = dot(a, b);  // calculate cosine from dot product\n  let magB: Float = 1;\n  // use the shortest path\n  if (cosTheta < 0) {\n    cosTheta *= -1;\n    magB = -1;\n  }\n\n  // initialize with linear interpolation\n  let scale0: Float = 1 - t;\n  let scale1: Float = t;\n\n  // use spherical interpolation only if the quaternions are not very close\n  if (1 - cosTheta > EPSILON) {\n    const theta: Float = Math.acos(cosTheta) as Float;\n    const sinTheta: Float = Math.sin(theta) as Float;\n    scale0 = (Math.sin((1 - t) * theta) as Float) / sinTheta;\n    scale1 = (Math.sin(t * theta) as Float) / sinTheta;\n  }\n  scale1 *= magB;\n\n  unchecked(out[0] = a[0] * scale0 + b[0] * scale1);\n  unchecked(out[1] = a[1] * scale0 + b[1] * scale1);\n  unchecked(out[2] = a[2] * scale0 + b[2] * scale1);\n  unchecked(out[3] = a[3] * scale0 + b[3] * scale1);\n  return out;\n}\n","import { Float, ReadonlyMat2, ReadonlyMat3, ReadonlyVec2, Vec2, Vec3 } from './types';\nimport * as mat from './mat';\nimport * as vec3 from './vec3';\n\n// Temp variables\nconst v: Vec2 = create();\nconst v3a: Vec3 = vec3.create();\nconst v3b: Vec3 = vec3.create();\n\n/**\n * Create a new {@link Vec2}.\n * @param x defaults to 0\n * @param y defaults to 0\n * @returns [x, y]\n */\nexport function create(x: Float = 0, y: Float = 0): Vec2 {\n  return [x, y];\n}\n\n/**\n * Set values of a {@link Vec2}.\n * @param v the vec\n * @param x defaults to 0\n * @param y defaults to 0\n * @returns v\n */\nexport function set(v: Vec2, x: Float = 0, y: Float = 0): Vec2 {\n  unchecked(v[0] = x);\n  unchecked(v[1] = y);\n  return v;\n}\n\n/**\n * Copy a {@link Vec2}.\n * @returns out\n */\nexport function copy(v: ReadonlyVec2, out: Vec2 = create()): Vec2 {\n  return mat.copy(v, out) as Vec2;\n}\n\n/**\n * Sum 2 {@link Vec2}.\n * @returns out = a + b\n */\nexport function add(a: ReadonlyVec2, b: ReadonlyVec2, out: Vec2 = create()): Vec2 {\n  return mat.add(a, b, out) as Vec2;\n}\n\n/**\n * Subtract 2 {@link Vec2}.\n * @returns out = a - b\n */\nexport function sub(a: ReadonlyVec2, b: ReadonlyVec2, out: Vec2 = create()): Vec2 {\n  return mat.sub(a, b, out) as Vec2;\n}\n\n/**\n * Multiply a {@link Vec2} by a constant.\n * @returns out = s * v\n */\nexport function scale(v: ReadonlyVec2, s: Float, out: Vec2 = create()): Vec2 {\n  return mat.scale(v, s, out) as Vec2;\n}\n\n/**\n * Multiply a {@link ReadonlyMat2} with a {@link ReadonlyVec2}.\n * @returns out = m * x\n */\nexport function mul(m: ReadonlyMat2, x: ReadonlyVec2, out: Vec2 = create()): Vec2 {\n  return mat.mul(2, m, x, out) as Vec2;\n}\n\n/**\n * Transform a {@link ReadonlyVec2} by a {@link ReadonlyMat3}.\n * @returns out = m * [x 1]\n */\nexport function mmul3(m: ReadonlyMat3, x: ReadonlyVec2, out: Vec2 = create()): Vec2 {\n  unchecked(vec3.set(v3a, x[0], x[1], 1));\n  return mat.copy(mat.mul(3, m, v3a, v3b), out, 0, 0, 2) as Vec2;\n}\n\n/**\n * Calculate the dot product of 2 {@link Vec2}.\n * @returns a * b\n */\nexport function dot(a: ReadonlyVec2, b: ReadonlyVec2): Float {\n  return mat.dot(a, b);\n}\n\n/**\n * Linear interpolate 2 {@link Vec2}.\n * @returns out = lerp(a, b, t)\n */\nexport function lerp(a: ReadonlyVec2, b: ReadonlyVec2, t: Float, out: Vec2 = create()): Vec2 {\n  return mat.lerp(a, b, t, out) as Vec2;\n}\n\n/**\n * Calculate squared length of a {@link Vec2}.\n * @returns dot(v, v)\n */\nexport function sqrLen(v: ReadonlyVec2): Float {\n  return dot(v, v);\n}\n\n/**\n * Calculate length of a {@link Vec2}.\n * @returns |v|\n */\nexport function len(v: ReadonlyVec2): Float {\n  return Math.hypot(v[0], v[1]) as Float;\n}\n\n/**\n * Calculate Euclidean distance of 2 {@link Vec2}.\n * @returns |a - b|\n */\nexport function dist(a: ReadonlyVec2, b: ReadonlyVec2): Float {\n  return len(sub(a, b, v));\n}\n\n/**\n * Normalize a {@link Vec2} and optionally stores result to the out param.\n * @returns v/|v|\n */\nexport function norm(v: ReadonlyVec2, out: Vec2 = create()): Vec2 {\n  return mat.scale(v, 1 / (len(v) || 1), out) as Vec2;\n}\n","import { Float, Mat4, Quat, ReadonlyMat4, ReadonlyQuat, ReadonlyVec3, Vec3 } from './types';\nimport * as mat from './mat';\nimport * as mat4 from './mat4';\nimport * as quat from './quat';\nimport * as vec3 from './vec3';\nimport { copysign } from './scalar';\n\n// Temp variables\nconst v0: Vec3 = vec3.create();\nconst v1: Vec3 = vec3.create();\nconst v2: Vec3 = vec3.create();\n\n/**\n * Return a {@link Mat4} for a 3D point translated by (x, y, z).\n */\nexport function translate(v: ReadonlyVec3, out: Mat4 = mat4.create()): Mat4 {\n  mat4.id(out);\n  mat.copy(v, out, 0, 12, 3);\n  return out;\n}\n\n/**\n * Return a {@link Mat4} for a 3D point scaled by (x, y, z).\n */\nexport function scale(s: ReadonlyVec3, out: Mat4 = mat4.create()): Mat4 {\n  mat4.id(out);\n  unchecked(out[0] = s[0]);\n  unchecked(out[5] = s[1]);\n  unchecked(out[10] = s[2]);\n  return out;\n}\n\n/**\n * Returns a {@link Mat4} for a rotation by a {@link Quat}.\n */\nexport function rotate(q: ReadonlyQuat, out: Mat4 = mat4.create()): Mat4 {\n  return quat.toMat4(q, out);\n}\n\n/**\n * Returns a {@link Mat4} for a 3D rotation about the x-axis in couterclockwise direction.\n * @see https://en.wikipedia.org/wiki/Rotation_matrix#Basic_rotations\n */\nexport function rotateX(theta: Float, out: Mat4 = mat4.create()): Mat4 {\n  mat4.id(out);\n  unchecked(out[5] = out[10] = Math.cos(theta) as Float);\n  unchecked(out[6] = out[9] = Math.sin(theta) as Float);\n  unchecked(out[9] *= -1);\n  return out;\n}\n\n/**\n * Returns a {@link Mat4} for a 3D rotation about the y-axis in couterclockwise direction.\n * @see https://en.wikipedia.org/wiki/Rotation_matrix#Basic_rotations\n */\nexport function rotateY(theta: Float, out: Mat4 = mat4.create()): Mat4 {\n  mat4.id(out);\n  unchecked(out[0] = out[10] = Math.cos(theta) as Float);\n  unchecked(out[2] = out[8] = Math.sin(theta) as Float);\n  unchecked(out[2] *= -1);\n  return out;\n}\n\n/**\n * Returns a {@link Mat4} for a 3D rotation about the z-axis in couterclockwise direction.\n * @see https://en.wikipedia.org/wiki/Rotation_matrix#Basic_rotations\n */\nexport function rotateZ(theta: Float, out: Mat4 = mat4.create()): Mat4 {\n  mat4.id(out);\n  unchecked(out[0] = out[5] = Math.cos(theta) as Float);\n  unchecked(out[1] = out[4] = Math.sin(theta) as Float);\n  unchecked(out[4] *= -1);\n  return out;\n}\n\n/**\n * Returns a {@link Mat4} for a 3D rotation about a given unit axis in couterclockwise direction.\n * @see https://en.wikipedia.org/wiki/Rotation_matrix#Basic_rotations\n */\nexport function rotateAxis(axis: ReadonlyVec3, theta: Float, out: Mat4 = mat4.create()): Mat4 {\n  const\n    x: Float = unchecked(axis[0]),\n    y: Float = unchecked(axis[1]),\n    z: Float = unchecked(axis[2]);\n  const s: Float = Math.sin(theta) as Float;\n  const c: Float = Math.cos(theta) as Float;\n  const omc: Float = 1 - c;\n\n  unchecked(out[0] = x * x * omc + c);\n  unchecked(out[1] = x * y * omc + z * s);\n  unchecked(out[2] = x * z * omc - y * s);\n  unchecked(out[4] = y * x * omc - z * s);\n  unchecked(out[5] = y * y * omc + c);\n  unchecked(out[6] = y * z * omc + x * s);\n  unchecked(out[8] = z * x * omc + y * s);\n  unchecked(out[9] = z * y * omc - x * s);\n  unchecked(out[10] = z * z * omc + c);\n  unchecked(out[3] = out[7] = out[11] = out[12] = out[13] = out[14] = 0);\n  unchecked(out[15] = 1);\n  return out;\n}\n\n/**\n * Returns a {@link Mat4} for transformation in TRS order (= translation * rotation * scale).\n * @returns out = translation * rotation * scale\n */\nexport function transform(translation: ReadonlyVec3, rotation: ReadonlyQuat, scaling: ReadonlyVec3, out: Mat4 = mat4.create()): Mat4 {\n  // Apply rotation\n  rotate(rotation, out);\n\n  // Apply scaling\n  for (let i = 0; i < 3; ++i) {\n    for (let j = 0; j < 3; ++j) {\n      unchecked(out[4 * i + j] *= scaling[i]);\n    }\n  }\n\n  // Apply translation\n  mat.copy(translation, out, 0, 12, 3);\n\n  return out;\n}\n\n/**\n * Returns the inverse of a {@link ReadonlyMat4} that represents a valid transformation in TRS order (= translation * rotation * scale).\n * This function is more efficient than {@link mat4.invert} by using the properties of a TRS matrix.\n * @returns out = M^-1\n */\nexport function inverseTransform(m: ReadonlyMat4, out: Mat4 = mat4.create()): Mat4 {\n  // Assume M is a TRS matrix:\n  // M = T * R * S = [RS  t]\n  //                 [0   1]\n  // Then the inverse of M is:\n  // M^-1 = [(RS)^-1  (RS)^-1 * -t]\n  //        [   0           1     ]\n  // Where: (RS)^-1 = S^-1 * R^-1 = S^-1 * RT = S^-1 * ((RS)(S^-1))T = S^-1 * (S^-1)T * (RS)T = S^-1 * S^-1 * (RS)T\n\n  // Calculate output = (RS)T\n  mat4.transpose(m, out);\n  unchecked(out[3] = out[7] = out[11] = 0);\n\n  // Extract S and premultiply S^-2 = 1/(S*S) to output\n  scaleOf(m, v1);\n  for (let i = 0; i < 3; ++i) {\n    for (let j = 0; j < 3; ++j) {\n      unchecked(out[4 * i + j] *= 1 / (v1[j] * v1[j]));\n    }\n  }\n\n  // With output = (RS)^-1, apply translation = (output * -t) to output\n  mat.copy(\n    vec3.mmul4(out, vec3.scale(mat.copy(m, v0, 12, 0, 3) as Vec3, -1)),\n    out,\n    0, 12, 3\n  );\n\n  return out;\n}\n\n// -- Transformation matrix decomposition --\n\n/**\n * Extract the {@link Vec3} translation component from a transformation matrix.\n */\nexport function translationOf(m: ReadonlyMat4, out: Vec3 = vec3.create()): Vec3 {\n  return mat.copy(m, out, 12, 0, 3) as Vec3;\n}\n\n/**\n * Extract the {@link Vec3} scaling components from a transformation matrix in TRS order (= translation * rotation * scale).\n */\nexport function scaleOf(m: ReadonlyMat4, out: Vec3 = vec3.create()): Vec3 {\n  for (let i = 0; i < 3; ++i) {\n    for (let j = 0; j < 3; ++j) {\n      unchecked(v0[j] = m[4 * i + j]);\n    }\n    unchecked(out[i] = vec3.len(v0));\n  }\n  return out;\n}\n\n/**\n * Extract the {@link Quat} rotation components from a transformation matrix in TRS order (= translation * rotation * scale).\n * @see https://en.wikipedia.org/wiki/Rotation_matrix#Quaternion\n */\nexport function rotationOf(m: ReadonlyMat4, out: Quat = quat.create()): Quat {\n  scaleOf(m, v1);\n  const\n    m00: Float = unchecked(m[0] / v1[0]),\n    m11: Float = unchecked(m[5] / v1[1]),\n    m22: Float = unchecked(m[10] / v1[2]);\n\n  unchecked(out[3] = (Math.sqrt(Math.max(0, 1 + m00 + m11 + m22)) as Float) / 2);\n  unchecked(out[0] = copysign((Math.sqrt(Math.max(0, 1 + m00 - m11 - m22)) as Float) / 2, m[6] / v1[1] - m[9] / v1[2]));\n  unchecked(out[1] = copysign((Math.sqrt(Math.max(0, 1 - m00 + m11 - m22)) as Float) / 2, m[8] / v1[2] - m[2] / v1[0]));\n  unchecked(out[2] = copysign((Math.sqrt(Math.max(0, 1 - m00 - m11 + m22)) as Float) / 2, m[1] / v1[0] - m[4] / v1[1]));\n\n  return out;\n}\n\n// -- Camera matrices --\n\n/**\n * Calculate the {@link Mat4} orthographic projection matrix.\n * To apply a glTF orthographic camera, use: left = -xmag, right = xmag, bottom = -ymag, top = ymag.\n * @see https://en.wikipedia.org/wiki/Orthographic_projection\n * @see https://github.com/KhronosGroup/glTF/tree/master/specification/2.0\n */\nexport function ortho(\n  left: Float, right: Float, bottom: Float, top: Float, znear: Float, zfar: Float,\n  out: Mat4 = mat4.create()\n): Mat4 {\n  const x: Float = 1 / (right - left);\n  const y: Float = 1 / (top - bottom);\n  const z: Float = 1 / (znear - zfar);\n\n  mat4.id(out);\n  unchecked(out[0] = 2 * x);\n  unchecked(out[5] = 2 * y);\n  unchecked(out[10] = 2 * z);\n  unchecked(out[12] = -(right + left) * x);\n  unchecked(out[13] = -(top + bottom) * y);\n  unchecked(out[14] = (znear + zfar) * z);\n  return out;\n}\n\n/**\n * Calculate the {@link Mat4} perspective projection using glTF's formula. Use infinite projection if zfar = Infinity.\n * @see https://github.com/KhronosGroup/glTF/tree/master/specification/2.0\n * @param zfar defaults to Infinity\n */\nexport function perspective(\n  aspectRatio: Float, yfov: Float, znear: Float, zfar: Float = Infinity,\n  out: Mat4 = mat4.create()\n): Mat4 {\n  const f: Float = 1 / (Math.tan(yfov / 2) as Float);\n\n  mat4.id(out);\n  unchecked(out[0] = f / aspectRatio);\n  unchecked(out[5] = f);\n  unchecked(out[11] = -1);\n  unchecked(out[15] = 0);\n\n  if (isFinite(zfar)) {\n    const rangeInv: Float = 1 / (znear - zfar);\n    unchecked(out[10] = (znear + zfar) * rangeInv);\n    unchecked(out[14] = 2 * znear * zfar * rangeInv);\n  } else {\n    unchecked(out[10] = -1);\n    unchecked(out[14] = -2 * znear);\n  }\n\n  return out;\n}\n\n/**\n * Calculate the {@link Mat4} model matrix for a camera at eye position looking at the center\n * position with a given up direction.\n */\nexport function targetTo(\n  eye: ReadonlyVec3, center: ReadonlyVec3, up: ReadonlyVec3 = vec3.create(0, 1, 0),\n  out: Mat4 = mat4.create()\n): Mat4 {\n  const v: Vec3 = vec3.sub(eye, center, v0); // front\n  vec3.norm(v, v);\n  const n: Vec3 = vec3.cross(up, v, v1); // right\n  vec3.norm(n, n);\n  const u: Vec3 = vec3.cross(v, n, v2); // up\n  vec3.norm(u, u);\n\n  mat.copy(n, out, 0, 0, 3);\n  mat.copy(u, out, 0, 4, 3);\n  mat.copy(v, out, 0, 8, 3);\n  mat.copy(eye, out, 0, 12, 3);\n  unchecked(out[3] = out[7] = out[11] = 0);\n  unchecked(out[15] = 1);\n  return out;\n}\n\n/**\n * Calculate the {@link Mat4} view matrix for a camera at eye position looking at the center\n * position with a given up direction.\n * @param center defaults to the origin, i.e. [0, 0, 0]\n * @param up defaults to the positive y-axis, i.e. [0, 1, 0]\n */\nexport function lookAt(\n  eye: ReadonlyVec3,\n  center: ReadonlyVec3 = vec3.create(),\n  up: ReadonlyVec3 = vec3.create(0, 1, 0),\n  out: Mat4 = mat4.create()\n): Mat4 {\n  const v: Vec3 = vec3.sub(center, eye, v0); // front\n  vec3.norm(v, v);\n  const n: Vec3 = vec3.cross(v, up, v1); // right\n  vec3.norm(n, n);\n  const u: Vec3 = vec3.cross(n, v, v2); // up\n  vec3.norm(u, u);\n\n  unchecked(out[0] = n[0]);\n  unchecked(out[1] = u[0]);\n  unchecked(out[2] = -v[0]);\n  unchecked(out[4] = n[1]);\n  unchecked(out[5] = u[1]);\n  unchecked(out[6] = -v[1]);\n  unchecked(out[8] = n[2]);\n  unchecked(out[9] = u[2]);\n  unchecked(out[10] = -v[2]);\n  unchecked(out[12] = -vec3.dot(n, eye));\n  unchecked(out[13] = -vec3.dot(u, eye));\n  unchecked(out[14] = vec3.dot(v, eye));\n  unchecked(out[3] = out[7] = out[11] = 0);\n  unchecked(out[15] = 1);\n  return out;\n}\n\n/**\n * Calculate the look-at direction {@link Vec3} vector from pitch (up/down) and yaw (left/right) angles in radians.\n * It looks towards -Z axis when pitch = 0 and yaw = 0.\n * This can be used with lookAt method to build an FPS camera view matrix by:\n * viewMatrix = lookAt(eye, add(eye, direction(yaw, pitch)), [0, 1, 0])\n */\nexport function direction(pitch: Float, yaw: Float, out: Vec3 = vec3.create()): Vec3 {\n  const negCosPitch: Float = -Math.cos(pitch) as Float;\n  unchecked(out[0] = negCosPitch * Math.sin(yaw) as Float);\n  unchecked(out[1] = Math.sin(pitch) as Float);\n  unchecked(out[2] = negCosPitch * Math.cos(yaw) as Float);\n  return out;\n}\n","import { lookAt, mat, mat4, perspective, scale, translate, vec3 } from 'munum/assembly';\nimport {\n  BindGroup, BindingType, Buffer, BufferUsage, CompareFunction, CullMode, Device,\n  FilterMode, Float, RenderPipeline, RenderPass, Sampler, ShaderStage, Texture,\n  TextureFormat, TextureUsage, vertexBufferLayouts, VertexFormat, WebGL\n} from '../interop/mugl';\nimport { BaseExample, createBuffer, Cube, Model, Quad, toIndices, toVertices } from '../common';\n\nconst sampleCount = 4;\nconst texSize = 512;\n\nconst vertCube = `#version 300 es\nprecision mediump float;\nlayout(std140) uniform Data {\n  mat4 model, vp;\n  vec3 color;\n};\nlayout(location = 0) in vec3 position;\nlayout(location = 1) in vec2 uv;\nout vec3 vPosition;\nout vec2 vUv;\nvoid main(void) {\n  vec4 worldPos = model * vec4(position, 1.0);\n  vPosition = worldPos.xyz;\n  vUv = uv;\n  gl_Position = vp * worldPos;\n}`;\n\nconst fragCube = `#version 300 es\nprecision mediump float;\nlayout(std140) uniform Data {\n  mat4 model;\n  mat4 vp;\n  vec3 color;\n};\nin vec3 vPosition;\nin vec2 vUv;\nlayout(location = 0) out vec4 out0;\nlayout(location = 1) out vec4 out1;\nlayout(location = 2) out vec4 out2;\nvoid main(void) {\n  out0 = vec4(color, 1.0);\n  out1 = vec4(vUv, 0.0, 0.0);\n  out2 = vec4(vPosition, 0.0);\n}`;\n\nconst vertQuad = `#version 300 es\nlayout (location=0) in vec3 position;\nlayout (location=1) in vec2 uv;\nout vec2 vUv;\nvoid main(void) {\n  gl_Position = vec4(position, 1.0);\n  vUv = uv;\n}\n`;\n\nconst fragQuad = `#version 300 es\nprecision mediump float;\nuniform sampler2D tex0, tex1, tex2;\nin vec2 vUv;\nout vec4 outColor;\nvoid main(void) {\n  vec4 colorSum =\n    texture(tex0, vUv * 2.0 - vec2(0.0, 1.0)) * step(0.5, 1.0 - vUv.x) * step(0.5, vUv.y) +\n    texture(tex1, vUv * 2.0 - vec2(0.0, 0.0)) * step(0.5, 1.0 - vUv.x) * step(0.5, 1.0 - vUv.y) +\n    texture(tex2, vUv * 2.0 - vec2(1.0, 1.0)) * step(0.5, vUv.x) * step(0.5, vUv.y);\n    outColor = vec4(colorSum.rgb, 1.0);\n}\n`;\n\nconst cubeVertices = toVertices({\n  positions: Cube.positions,\n  uvs: Cube.uvs\n} as Model);\nconst cubeIndices = toIndices(Cube);\n\nconst quadVertices = toVertices(Quad);\n\nexport class MRTExample extends BaseExample {\n  pass: RenderPass | null = null;\n  offscreenPass: RenderPass | null = null;\n  vertBuffer: Buffer | null = null;\n  indexBuffer: Buffer | null = null;\n  quadVertBuffer: Buffer | null = null;\n  cubeDataBuffer: Buffer | null = null;\n  cubePipeline: RenderPipeline | null = null;\n  quadPipeline: RenderPipeline | null = null;\n  colorTex: Texture | null = null;\n  uvTex: Texture | null = null;\n  positionTex: Texture | null = null;\n  depthTex: Texture | null = null;\n  offscreenTexSampler: Sampler | null = null;\n  offscreenTexBindGroup: BindGroup | null = null;\n  cubeBindGroup: BindGroup | null = null;\n\n  cubeData: Float32Array = new Float32Array(40);\n\n  constructor(\n    private readonly device: Device\n  ) {\n    super();\n  }\n\n  init(): void {\n    // Create shaders\n    const cubeVs = WebGL.createShader(this.device, { code: vertCube, usage: ShaderStage.Vertex });\n    const cubeFs = WebGL.createShader(this.device, { code: fragCube, usage: ShaderStage.Fragment });\n    const quadVs = WebGL.createShader(this.device, { code: vertQuad, usage: ShaderStage.Vertex });\n    const quadFs = WebGL.createShader(this.device, { code: fragQuad, usage: ShaderStage.Fragment });\n\n    const dataLayout = WebGL.createBindGroupLayout(this.device, {\n      entries: [{ label: 'Data', type: BindingType.Buffer }]\n    });\n\n    // Setup the cube\n    {\n      this.vertBuffer = createBuffer(this.gpu, this.device, cubeVertices);\n      this.indexBuffer = createBuffer(this.gpu, this.device, cubeIndices, BufferUsage.Index);\n      this.cubeDataBuffer = createBuffer(this.gpu, this.device, this.cubeData, BufferUsage.Uniform | BufferUsage.Stream);\n\n      this.cubeBindGroup = WebGL.createBindGroup(this.device, {\n        layout: dataLayout,\n        entries: [{ buffer: this.cubeDataBuffer }]\n      });\n\n      this.cubePipeline = WebGL.createRenderPipeline(this.device, {\n        vertex: cubeVs,\n        fragment: cubeFs,\n        buffers: vertexBufferLayouts([\n          { attributes: [/* position */ VertexFormat.F32x3, /* uv */ VertexFormat.F32x2] }\n        ]),\n        bindGroups: [dataLayout],\n        depthStencil: {\n          depthCompare: CompareFunction.LessEqual,\n          depthWrite: true\n        },\n        primitive: {\n          cullMode: CullMode.Back\n        }\n      });\n    }\n\n    // Setup the fullscreen quad\n    const offscreenTexLayout = WebGL.createBindGroupLayout(this.device, {\n      entries: [\n        { binding: 0, label: 'tex0', type: BindingType.Texture }, { binding: 1, label: 'tex0', type: BindingType.Sampler },\n        { binding: 2, label: 'tex1', type: BindingType.Texture }, { binding: 3, label: 'tex1', type: BindingType.Sampler },\n        { binding: 4, label: 'tex2', type: BindingType.Texture }, { binding: 5, label: 'tex2', type: BindingType.Sampler },\n      ]\n    });\n    {\n      this.quadVertBuffer = createBuffer(this.gpu, this.device, quadVertices);\n      this.colorTex = WebGL.createTexture(this.device, { size: [texSize, texSize, 1], sampleCount });\n      this.uvTex = WebGL.createTexture(this.device, { size: [texSize, texSize, 1], sampleCount });\n      this.positionTex = WebGL.createTexture(this.device, { size: [texSize, texSize, 1], sampleCount });\n      this.offscreenTexSampler = WebGL.createSampler(this.device, {\n        magFilter: FilterMode.Linear,\n        minFilter: FilterMode.Linear,\n      });\n\n      this.offscreenTexBindGroup = WebGL.createBindGroup(this.device, {\n        layout: offscreenTexLayout,\n        entries: [\n          { binding: 0, texture: this.colorTex }, { binding: 1, sampler: this.offscreenTexSampler },\n          { binding: 2, texture: this.uvTex }, { binding: 3, sampler: this.offscreenTexSampler },\n          { binding: 4, texture: this.positionTex }, { binding: 5, sampler: this.offscreenTexSampler },\n        ]\n      });\n\n      this.quadPipeline = WebGL.createRenderPipeline(this.device, {\n        vertex: quadVs,\n        fragment: quadFs,\n        bindGroups: [offscreenTexLayout],\n        buffers: vertexBufferLayouts([\n          { attributes: [/* position */ VertexFormat.F32x3, /* uv */ VertexFormat.F32x2] }\n        ]),\n      });\n    }\n\n    // Setup the offscreen pass\n    {\n      this.depthTex = WebGL.createTexture(this.device, {\n        format: TextureFormat.Depth16,\n        size: [texSize, texSize, 1],\n        usage: TextureUsage.RenderAttachment,\n        sampleCount\n      });\n\n      this.offscreenPass = WebGL.createRenderPass(this.device, {\n        colors: [\n          { view: { texture: this.colorTex! }, clear: [0.1, 0.2, 0.3, 1] },\n          { view: { texture: this.uvTex! }, clear: [0.3, 0.1, 0.2, 1] },\n          { view: { texture: this.positionTex! }, clear: [0.1, 0.3, 0.2, 1] }\n        ],\n        depthStencil: { texture: this.depthTex! },\n        clearDepth: 1\n      });\n    }\n\n    this.pass = WebGL.createRenderPass(this.device, {\n      clearColor: [0, 0, 0, 1],\n      clearDepth: 1\n    });\n\n    this.register([\n      this.pass!, this.offscreenPass!,\n      this.cubePipeline!, this.vertBuffer!, this.indexBuffer!, this.cubeDataBuffer!, this.cubeBindGroup!,\n      this.quadPipeline!, this.quadVertBuffer!, this.offscreenTexBindGroup!,\n      this.colorTex!, this.uvTex!, this.positionTex!, this.depthTex!, this.offscreenTexSampler!,\n      cubeFs, cubeVs, quadFs, quadVs, dataLayout, offscreenTexLayout\n    ]);\n  }\n\n  render(t: Float): boolean {\n    // Update cube mvp\n    {\n      const pos = vec3.create(.5, .5, .5);\n      const proj = perspective((this.width as Float) / (this.height as Float), Math.PI / 4 as Float, 0.01, 100);\n      const view = lookAt(vec3.add([5 * Math.cos(t) as Float, 2.5 * Math.sin(t) as Float, 5 * Math.sin(t) as Float], pos), pos);\n      const vp = mat4.mul(proj, view);\n\n      let model = translate(pos);\n      model = mat4.mul(model, scale([.5, .5, .5]), model);\n\n      mat.copy(model, this.cubeData, 0, 0, 16);\n      mat.copy(vp, this.cubeData, 0, 16, 16);\n      mat.copy([1 as Float, 1, 1], this.cubeData, 0, 32, 3);\n      WebGL.writeBuffer(this.device, this.cubeDataBuffer!, this.cubeData);\n    }\n\n    // Draw cube to textures\n    WebGL.beginRenderPass(this.device, this.offscreenPass!);\n    {\n      WebGL.setRenderPipeline(this.device, this.cubePipeline!);\n      WebGL.setIndex(this.device, this.indexBuffer!);\n      WebGL.setVertex(this.device, 0, this.vertBuffer!);\n      WebGL.setBindGroup(this.device, 0, this.cubeBindGroup!);\n      WebGL.drawIndexed(this.device, cubeIndices.length);\n    }\n    WebGL.submitRenderPass(this.device);\n\n    // Draw to screen\n    WebGL.beginRenderPass(this.device, this.pass!);\n    {\n      WebGL.setRenderPipeline(this.device, this.quadPipeline!);\n      WebGL.setVertex(this.device, 0, this.quadVertBuffer!);\n      WebGL.setBindGroup(this.device, 0, this.offscreenTexBindGroup!);\n      WebGL.draw(this.device, 6);\n    }\n    WebGL.submitRenderPass(this.device);\n\n    return true;\n  }\n}\n","import { lookAt, mat, mat4, perspective, scale, vec3 } from 'munum/assembly';\nimport {\n  BindGroup, BindingType, Buffer, BufferUsage, CompareFunction, CullMode, Device,\n  FilterMode, Float, RenderPipeline, RenderPipelineDescriptor, Sampler, ShaderStage, Texture,\n  TextureDimension, vertexBufferLayouts, VertexFormat, WebGL, getImage, RenderPass\n} from '../interop/mugl';\nimport { BaseExample, createBuffer, createFloat32Array, Cube, Model, TEX_SIZE, toIndices, toVertices } from '../common';\n\nconst texSize = TEX_SIZE;\n\nconst cubeVertices = toVertices({\n  positions: Cube.positions,\n  normals: Cube.normals,\n  uvs: Cube.uvs\n} as Model);\nconst cubeIndices = toIndices(Cube);\n\nconst vert = `#version 300 es\nprecision mediump float;\nlayout(std140) uniform Data {\n  mat4 model, viewProj;\n  vec4 camPos;\n};\nlayout (location=0) in vec3 position;\nlayout (location=1) in vec2 uv;\nlayout (location=2) in vec3 normal;\nout vec3 vPosition;\nout vec2 vUv;\nout vec3 vNormal;\n\nvoid main(void) {\n  vec4 worldPos = model * vec4(position, 1.0);\n  vPosition = worldPos.xyz / worldPos.w;\n  vNormal = mat3(model) * normalize(normal);\n  vUv = uv;\n  gl_Position = viewProj * worldPos;\n}\n`\n\nconst fragCube = `#version 300 es\nprecision mediump float;\nuniform sampler2D tex;\nlayout(std140) uniform Data {\n  mat4 model, viewProj;\n  vec4 camPos;\n};\nlayout(std140) uniform Material {\n  vec4 albedo;\n  vec2 metallicRoughness;\n};\nlayout(std140) uniform Env {\n  vec4 ambient;\n  vec4 lightDir;\n  vec4 lightColor;\n};\n\nin vec3 vPosition;\nin vec2 vUv;\nin vec3 vNormal;\nout vec4 color;\n\nconst float PI = 3.14159265359;\n\nvec3 toSrgb(vec3 color) {\n  return pow(color, vec3(1.0/2.2));\n}\n\nvec4 toLinear(vec4 srgbIn) {\n  return vec4(pow(srgbIn.rgb, vec3(2.2)), srgbIn.a);\n}\n\nvec3 diffuse(vec3 color) {\n  return color / PI;\n}\n\nfloat specularD(float aSqr, float nDotH) {\n  float f = (nDotH * nDotH) * (aSqr - 1.0) + 1.0;\n  return aSqr / (PI * f * f);\n}\n\nvec3 specularF(vec3 r0, vec3 r90, float vDotH) {\n  return r0 + (r90 - r0) * pow(clamp(1.0 - vDotH, 0.0, 1.0), 5.0);\n}\n\nfloat specularG(float aSqr, float nDotL, float nDotV) {\n  float gl = 2.0 * nDotL / (nDotL + sqrt(aSqr + (1.0 - aSqr) * (nDotL * nDotL)));\n  float gv = 2.0 * nDotV / (nDotV + sqrt(aSqr + (1.0 - aSqr) * (nDotV * nDotV)));\n  return gl * gv;\n}\n\nvoid main () {\n  vec3 n = normalize(vNormal);\n  vec3 v = normalize(camPos.xyz - vPosition);\n  vec3 l = normalize(-lightDir.xyz);\n  vec3 h = normalize(l + v);\n\n  float nDotL = clamp(dot(n, l), 0.001, 1.0);\n  float nDotV = clamp(abs(dot(n, v)), 0.001, 1.0);\n  float nDotH = clamp(dot(n, h), 0.0, 1.0);\n  float vDotH = clamp(dot(v, h), 0.0, 1.0);\n\n  vec4 baseColor = toLinear(texture(tex, vUv)) * albedo;\n\n  vec3 f0 = vec3(0.04);\n  vec3 diffuseColor = baseColor.rgb * (vec3(1.0) - f0) * (1.0 - metallicRoughness.x);\n  vec3 specularColor = mix(f0, baseColor.rgb, metallicRoughness.x);\n\n  float r0 = max(max(specularColor.r, specularColor.g), specularColor.b);\n  float r90 = clamp(r0 * 25.0, 0.0, 1.0);\n  vec3 specularEnvR0 = specularColor.rgb;\n  vec3 specularEnvR90 = vec3(1.0, 1.0, 1.0) * r90;\n\n  float a = clamp(metallicRoughness.y, 0.04, 1.0);\n  a *= a;\n  float aSqr = a * a;\n\n  vec3 color0 = vec3(0.0);\n\n  vec3 F = specularF(specularEnvR0, specularEnvR90, vDotH);\n  float D = specularD(aSqr, nDotH);\n  float G = specularG(aSqr, nDotL, nDotV);\n\n  vec3 diffuse = (1.0 - F) * diffuse(diffuseColor);\n  vec3 specular = F * G * D / (4.0 * nDotL * nDotV);\n\n  color0 += nDotL * lightColor.rgb * lightColor.a * (diffuse + specular);\n  color0 += ambient.rgb * diffuseColor;\n\n  color = vec4(toSrgb(color0), baseColor.a);\n}`;\n\nconst fragSky = `#version 300 es\nprecision mediump float;\nuniform samplerCube tex;\nin vec3 vPosition;\nout vec4 color;\nvoid main () {\n  color = texture(tex, normalize(vPosition));\n}`;\n\nexport class PbrExample extends BaseExample {\n  pass: RenderPass | null = null;\n  vertBuffer: Buffer | null = null;\n  indexBuffer: Buffer | null = null;\n  matBuffer: Buffer | null = null;\n  envBuffer: Buffer | null = null;\n  cubeDataBuffer: Buffer | null = null;\n  skyDataBuffer: Buffer | null = null;\n  cubePipeline: RenderPipeline | null = null;\n  cubeTex: Texture | null = null;\n  skyPipeline: RenderPipeline | null = null;\n  skyTex: Texture | null = null;\n  sampler: Sampler | null = null;\n  envBindGroup: BindGroup | null = null;\n  cubeTexBindGroup: BindGroup | null = null;\n  cubeDataBindGroup: BindGroup | null = null;\n  skyTexBindGroup: BindGroup | null = null;\n  skyDataBindGroup: BindGroup | null = null;\n\n  cubeData: Float32Array = new Float32Array(36);\n  skyData: Float32Array = new Float32Array(36);\n\n  constructor(\n    private readonly device: Device\n  ) {\n    super();\n  }\n\n  init(): void {\n    // Get texture images\n    const airplane = getImage('airplane');\n    const sky0 = getImage('sky0');\n    const sky1 = getImage('sky1');\n    const sky2 = getImage('sky2');\n\n    // Create shaders\n    const vs = WebGL.createShader(this.device, { code: vert, usage: ShaderStage.Vertex });\n    const cubeFs = WebGL.createShader(this.device, { code: fragCube, usage: ShaderStage.Fragment });\n    const skyFs = WebGL.createShader(this.device, { code: fragSky, usage: ShaderStage.Fragment });\n\n    // Create buffers\n    this.matBuffer = createBuffer(this.gpu, this.device, createFloat32Array([\n      1.0, 1.0, 1.0, 1.0, // albedo\n      0.5, // metallic\n      0.5, // roughness\n      0, 0 // padding\n    ]), BufferUsage.Uniform);\n    this.envBuffer = createBuffer(this.gpu, this.device, createFloat32Array([\n      0xdf / 0xff * .75, 0xf6 / 0xff * .75, 0xf5 / 0xff * .75, 1.0, // ambient\n      1.0, -2.0, 1.0, 0.0, // lightDir\n      0xfc / 0xff, 0xcb / 0xff, 0xcb / 0xff, 5.0, // lightColor / intensity\n    ]), BufferUsage.Uniform);\n    this.vertBuffer = createBuffer(this.gpu, this.device, cubeVertices);\n    this.indexBuffer = createBuffer(this.gpu, this.device, cubeIndices, BufferUsage.Index);\n    this.cubeDataBuffer = createBuffer(this.gpu, this.device, this.cubeData, BufferUsage.Uniform | BufferUsage.Stream);\n    this.skyDataBuffer = createBuffer(this.gpu, this.device, this.skyData, BufferUsage.Uniform | BufferUsage.Stream);\n\n    // Create bind groups\n    const textureLayout = WebGL.createBindGroupLayout(this.device, {\n      entries: [\n        { binding: 0, label: 'tex', type: BindingType.Texture },\n        { binding: 1, label: 'tex', type: BindingType.Sampler },\n      ]\n    });\n    const envLayout = WebGL.createBindGroupLayout(this.device, {\n      entries: [\n        { binding: 0, label: 'Material', type: BindingType.Buffer },\n        { binding: 1, label: 'Env', type: BindingType.Buffer },\n      ]\n    });\n    const dataLayout = WebGL.createBindGroupLayout(this.device, {\n      entries: [{ label: 'Data', type: BindingType.Buffer }]\n    });\n\n    // Setup the cube\n    this.cubeTex = WebGL.createTexture(this.device, { size: [texSize, texSize, 1] });\n    if (airplane) {\n      WebGL.copyExternalImageToTexture(this.device, { src: airplane }, { texture: this.cubeTex! });\n      // TODO: no auto mipmap for WebGPU\n      // WebGL.generateMipmap(this.device, this.cubeTex!);\n    }\n\n    this.sampler = WebGL.createSampler(this.device, {\n      magFilter: FilterMode.Linear,\n      minFilter: FilterMode.Linear,\n      mipmapFilter: FilterMode.Linear,\n      maxAnisotropy: 16\n    });\n\n    this.cubeTexBindGroup = WebGL.createBindGroup(this.device, {\n      layout: textureLayout,\n      entries: [{ binding: 0, texture: this.cubeTex }, { binding: 1, sampler: this.sampler }]\n    });\n    this.envBindGroup = WebGL.createBindGroup(this.device, {\n      layout: envLayout,\n      entries: [{ binding: 0, buffer: this.matBuffer }, { binding: 1, buffer: this.envBuffer }]\n    });\n    this.cubeDataBindGroup = WebGL.createBindGroup(this.device, {\n      layout: dataLayout,\n      entries: [{ buffer: this.cubeDataBuffer }]\n    });\n\n    const cubePipelineDesc: RenderPipelineDescriptor = {\n      vertex: vs,\n      fragment: cubeFs,\n      buffers: vertexBufferLayouts([\n        { attributes: [/* position */ VertexFormat.F32x3, /* uv */ VertexFormat.F32x2, /* normal */ VertexFormat.F32x3] }\n      ]),\n      bindGroups: [textureLayout, envLayout, dataLayout],\n      depthStencil: {\n        depthWrite: true,\n        depthCompare: CompareFunction.LessEqual\n      },\n      primitive: {\n        cullMode: CullMode.Back\n      }\n    };\n    this.cubePipeline = WebGL.createRenderPipeline(this.device, cubePipelineDesc);\n\n    // Setup the sky box\n    {\n      this.skyTex = WebGL.createTexture(this.device, {\n        dimension: TextureDimension.CubeMap,\n        size: [texSize, texSize, 1]\n      });\n      if (sky0 && sky1 && sky2) {\n        const cubeImages = [sky0, sky0, sky1, sky2, sky0, sky0];\n        for (let z = 0; z < 6; ++z) {\n          WebGL.copyExternalImageToTexture(this.device, { src: cubeImages[z] }, { texture: this.skyTex!, origin: [0, 0, z] });\n        }\n        // TODO: no auto mipmap for WebGPU\n        // WebGL.generateMipmap(this.device, this.skyTex!);\n      }\n\n      this.skyTexBindGroup = WebGL.createBindGroup(this.device, {\n        layout: textureLayout,\n        entries: [{ binding: 0, texture: this.skyTex }, { binding: 1, sampler: this.sampler }]\n      });\n      this.skyDataBindGroup = WebGL.createBindGroup(this.device, {\n        layout: dataLayout,\n        entries: [{ buffer: this.skyDataBuffer }]\n      });\n\n      this.skyPipeline = WebGL.createRenderPipeline(this.device, {\n        vertex: vs,\n        fragment: skyFs,\n        buffers: cubePipelineDesc.buffers,\n        bindGroups: [textureLayout, dataLayout],\n        depthStencil: cubePipelineDesc.depthStencil,\n        primitive: {\n          cullMode: CullMode.Front // Render back face for sky box\n        }\n      });\n    }\n\n    this.pass = WebGL.createRenderPass(this.device, { clearColor: [0, 0, 0, 1], clearDepth: 1 });\n\n    this.register([\n      this.vertBuffer!, this.indexBuffer!, this.matBuffer!, this.envBuffer!, this.cubeDataBuffer!, this.skyDataBuffer!,\n      this.cubePipeline!, this.cubeTex!, this.skyPipeline!, this.skyTex!, this.sampler!,\n      this.envBindGroup!, this.cubeDataBindGroup!, this.cubeTexBindGroup!, this.skyDataBindGroup!, this.skyTexBindGroup!,\n      this.pass!, vs, cubeFs, skyFs, textureLayout, envLayout, dataLayout\n    ]);\n  }\n\n  render(t: Float): boolean {\n    // Write matrices\n    {\n      const camPos = vec3.create(10 * Math.cos(t) as Float, 5 * Math.sin(t) as Float, 10 * Math.sin(t) as Float);\n      const model = mat4.create();\n      const proj = perspective((this.width as Float) / (this.height as Float), Math.PI / 4 as Float, 0.01, 100);\n      const view = lookAt(camPos, [0, 0, 0]);\n      const vp = mat4.mul(proj, view);\n\n      mat.copy(model, this.cubeData, 0, 0, 16);\n      mat.copy(vp, this.cubeData, 0, 16, 16);\n      mat.copy(camPos, this.cubeData, 0, 32, 3);\n      WebGL.writeBuffer(this.device, this.cubeDataBuffer!, this.cubeData);\n\n      mat.copy(scale([10, 10, 10]), this.skyData, 0, 0, 16);\n      mat.copy(vp, this.skyData, 0, 16, 16);\n      mat.copy(camPos, this.skyData, 0, 32, 3);\n      WebGL.writeBuffer(this.device, this.skyDataBuffer!, this.skyData);\n    }\n\n    WebGL.beginRenderPass(this.device, this.pass!);\n\n    // Draw cube\n    WebGL.setRenderPipeline(this.device, this.cubePipeline!);\n    WebGL.setIndex(this.device, this.indexBuffer!);\n    WebGL.setVertex(this.device, 0, this.vertBuffer!);\n    WebGL.setBindGroup(this.device, 0, this.cubeTexBindGroup!);\n    WebGL.setBindGroup(this.device, 1, this.envBindGroup!);\n    WebGL.setBindGroup(this.device, 2, this.cubeDataBindGroup!);\n    WebGL.drawIndexed(this.device, cubeIndices.length);\n\n    // Draw skybox\n    WebGL.setRenderPipeline(this.device, this.skyPipeline!);\n    WebGL.setIndex(this.device, this.indexBuffer!);\n    WebGL.setVertex(this.device, 0, this.vertBuffer!);\n    WebGL.setBindGroup(this.device, 0, this.skyTexBindGroup!);\n    WebGL.setBindGroup(this.device, 1, this.skyDataBindGroup!);\n    WebGL.drawIndexed(this.device, cubeIndices.length);\n\n    WebGL.submitRenderPass(this.device);\n\n    return true;\n  }\n}\n","import { lookAt, mat, mat4, perspective, ReadonlyMat4 } from 'munum/assembly';\nimport {\n  BindGroup, BindingType, Buffer, BufferUsage, CompareFunction, CullMode, Device,\n  FilterMode, Float, Int, RenderPipeline, RenderPass, Sampler, ShaderStage, Texture,\n  TextureFormat, TextureUsage, vertexBufferLayouts, VertexFormat, WebGL\n} from '../interop/mugl';\nimport { BaseExample, createBuffer, Cube, Model, Quad, toIndices, toVertices } from '../common';\n\nconst sampleCount = 1;\nconst texSize = 512;\n\n// 3x3 kernels with padding\n// See: https://en.wikipedia.org/wiki/Kernel_(image_processing)\nconst kernels: ReadonlyMat4[] = [\n  // edge detection\n  [\n    -1, -1, -1, 0,\n    -1, 8, -1, 0,\n    -1, -1, -1, 0,\n    0, 0, 0, 0,\n  ],\n  // emboss\n  [\n    -2, -1, 0, 0,\n    -1, 1, 1, 0,\n    0, 1, 2, 0,\n    0, 0, 0, 0,\n  ],\n  // edge detection 2\n  [\n    0, -1, 0, 0,\n    -1, 4, -1, 0,\n    0, -1, 0, 0,\n    0, 0, 0, 0,\n  ],\n  // identity\n  [\n    0, 0, 0, 0,\n    0, 1, 0, 0,\n    0, 0, 0, 0,\n    0, 0, 0, 0,\n  ],\n];\n\nconst vertCube = `#version 300 es\nlayout(std140) uniform Data {\n  mat4 mvp;\n};\nlayout (location=0) in vec4 position;\nlayout (location=1) in vec4 color;\nout vec4 vColor;\nvoid main(void) {\n  gl_Position = mvp * position;\n  vColor = color;\n}`;\n\nconst fragCube = `#version 300 es\nprecision mediump float;\nin vec4 vColor;\nout vec4 outColor;\nvoid main(void) {\n  outColor = vColor;\n}`;\n\nconst vertQuad = `#version 300 es\nlayout (location=0) in vec4 position;\nlayout (location=1) in vec2 uv;\nout vec2 vUv;\nvoid main(void) {\n  gl_Position = position;\n  vUv = uv;\n}`;\n\nconst fragQuad = `#version 300 es\nprecision mediump float;\nuniform sampler2D tex;\nlayout(std140) uniform Data {\n  mat4 kernel;\n  vec2 texSize;\n  float kernelWeight;\n};\nin vec2 vUv;\nout vec4 outColor;\nvoid main(void) {\n  vec2 onePixel = vec2(1.0, 1.0) / texSize;\n  vec4 colorSum =\n    texture(tex, vUv + onePixel * vec2(-1, -1)) * kernel[0][0] +\n    texture(tex, vUv + onePixel * vec2( 0, -1)) * kernel[0][1] +\n    texture(tex, vUv + onePixel * vec2( 1, -1)) * kernel[0][2] +\n    texture(tex, vUv + onePixel * vec2(-1,  0)) * kernel[1][0] +\n    texture(tex, vUv + onePixel * vec2( 0,  0)) * kernel[1][1] +\n    texture(tex, vUv + onePixel * vec2( 1,  0)) * kernel[1][2] +\n    texture(tex, vUv + onePixel * vec2(-1,  1)) * kernel[2][0] +\n    texture(tex, vUv + onePixel * vec2( 0,  1)) * kernel[2][1] +\n    texture(tex, vUv + onePixel * vec2( 1,  1)) * kernel[2][2] ;\n    outColor = vec4((colorSum / kernelWeight).rgb, 1);\n}`;\n\nconst cubeVertices = toVertices({\n  positions: Cube.positions,\n  colors: Cube.colors\n} as Model);\nconst cubeIndices = toIndices(Cube);\n\nconst quadVertices = toVertices(Quad);\n\nexport class PostprocessExample extends BaseExample {\n  pass: RenderPass | null = null;\n  offscreenPass: RenderPass | null = null;\n  vertBuffer: Buffer | null = null;\n  indexBuffer: Buffer | null = null;\n  quadVertBuffer: Buffer | null = null;\n  cubeDataBuffer: Buffer | null = null;\n  kernelDataBuffer: Buffer | null = null;\n  cubePipeline: RenderPipeline | null = null;\n  quadPipeline: RenderPipeline | null = null;\n  offscreenTex: Texture | null = null;\n  offscreenTexSampler: Sampler | null = null;\n  depthTex: Texture | null = null;\n  offscreenTexBindGroup: BindGroup | null = null;\n  cubeBindGroup: BindGroup | null = null;\n  kernelBindGroup: BindGroup | null = null;\n\n  cubeData: Float32Array = new Float32Array(16);\n  kernelData: Float32Array = new Float32Array(20);\n\n  constructor(\n    private readonly device: Device\n  ) {\n    super();\n  }\n\n  init(): void {\n    // Create shaders\n    const cubeVs = WebGL.createShader(this.device, { code: vertCube, usage: ShaderStage.Vertex });\n    const cubeFs = WebGL.createShader(this.device, { code: fragCube, usage: ShaderStage.Fragment });\n    const quadVs = WebGL.createShader(this.device, { code: vertQuad, usage: ShaderStage.Vertex });\n    const quadFs = WebGL.createShader(this.device, { code: fragQuad, usage: ShaderStage.Fragment });\n\n    const dataLayout = WebGL.createBindGroupLayout(this.device, {\n      entries: [{ label: 'Data', type: BindingType.Buffer }]\n    });\n\n    // Setup the cube\n    {\n      this.vertBuffer = createBuffer(this.gpu, this.device, cubeVertices);\n      this.indexBuffer = createBuffer(this.gpu, this.device, cubeIndices, BufferUsage.Index);\n      this.cubeDataBuffer = createBuffer(this.gpu, this.device, this.cubeData, BufferUsage.Uniform | BufferUsage.Stream);\n\n      this.cubeBindGroup = WebGL.createBindGroup(this.device, {\n        layout: dataLayout,\n        entries: [{ buffer: this.cubeDataBuffer }]\n      });\n\n      this.cubePipeline = WebGL.createRenderPipeline(this.device, {\n        vertex: cubeVs,\n        fragment: cubeFs,\n        buffers: vertexBufferLayouts([\n          { attributes: [/* position */ VertexFormat.F32x3, /* color */ VertexFormat.F32x4] }\n        ]),\n        bindGroups: [dataLayout],\n        depthStencil: {\n          depthCompare: CompareFunction.LessEqual,\n          depthWrite: true\n        },\n        primitive: {\n          cullMode: CullMode.Back\n        }\n      });\n    }\n\n    // Setup the fullscreen quad\n    const offscreenTexLayout = WebGL.createBindGroupLayout(this.device, {\n      entries: [\n        { binding: 0, label: 'tex', type: BindingType.Texture },\n        { binding: 1, label: 'tex', type: BindingType.Sampler },\n      ]\n    });\n    {\n      this.quadVertBuffer = createBuffer(this.gpu, this.device, quadVertices);\n      this.kernelDataBuffer = createBuffer(this.gpu, this.device, this.kernelData, BufferUsage.Uniform | BufferUsage.Stream);\n\n      this.offscreenTex = WebGL.createTexture(this.device, { size: [texSize, texSize, 1], sampleCount });\n      this.offscreenTexSampler = WebGL.createSampler(this.device, {\n        magFilter: FilterMode.Linear,\n        minFilter: FilterMode.Linear,\n      });\n\n      this.offscreenTexBindGroup = WebGL.createBindGroup(this.device, {\n        layout: offscreenTexLayout,\n        entries: [\n          { binding: 0, texture: this.offscreenTex },\n          { binding: 1, sampler: this.offscreenTexSampler }\n        ]\n      });\n\n      this.kernelBindGroup = WebGL.createBindGroup(this.device, {\n        layout: dataLayout,\n        entries: [{ buffer: this.kernelDataBuffer }]\n      });\n\n      this.quadPipeline = WebGL.createRenderPipeline(this.device, {\n        vertex: quadVs,\n        fragment: quadFs,\n        bindGroups: [offscreenTexLayout, dataLayout],\n        buffers: vertexBufferLayouts([\n          { attributes: [/* position */ VertexFormat.F32x3, /* uv */ VertexFormat.F32x2] }\n        ]),\n      });\n    }\n\n    // Setup the offscreen pass\n    {\n      this.depthTex = WebGL.createTexture(this.device, {\n        format: TextureFormat.Depth16,\n        size: [texSize, texSize, 1],\n        usage: TextureUsage.RenderAttachment,\n        sampleCount\n      });\n\n      this.offscreenPass = WebGL.createRenderPass(this.device, {\n        colors: [{\n          view: { texture: this.offscreenTex! },\n          clear: [0.25, 0.25, 0.25, 1],\n        }],\n        depthStencil: { texture: this.depthTex! },\n        clearDepth: 1\n      });\n    }\n\n    this.pass = WebGL.createRenderPass(this.device, {\n      clearColor: [0, 0, 0, 1],\n      clearDepth: 1\n    });\n\n    this.register([\n      this.cubePipeline!, this.vertBuffer!, this.indexBuffer!, this.cubeDataBuffer!, this.kernelDataBuffer!,\n      this.quadPipeline!, this.quadVertBuffer!, this.offscreenTex!, this.offscreenTexSampler!, this.depthTex!,\n      this.pass!, this.offscreenPass!, this.cubeBindGroup!, this.offscreenTexBindGroup!, this.kernelBindGroup!,\n      cubeFs, cubeVs, quadFs, quadVs, offscreenTexLayout, dataLayout,\n    ]);\n  }\n\n  render(t: Float): boolean {\n    // Update cube mvp\n    {\n      const proj = perspective((this.width as Float) / (this.height as Float), Math.PI / 4 as Float, 0.01, 100);\n      const view = lookAt([10 * Math.cos(t) as Float, 5 * Math.sin(t) as Float, 10 * Math.sin(t) as Float], [0, 0, 0]);\n      const mvp = mat4.mul(proj, view);\n      mat.copy(mvp, this.cubeData, 0, 0, 16);\n      WebGL.writeBuffer(this.device, this.cubeDataBuffer!, this.cubeData);\n    }\n\n    // Update kernel\n    {\n      const kernel = kernels[Math.floor(t / 2) as Int % kernels.length];\n      let kernelWeight: Float = 0;\n      for (let i = 0; i < kernel.length; ++i) {\n        kernelWeight += kernel[i];\n      }\n      kernelWeight = kernelWeight <= 0 ? 1 : kernelWeight;\n\n      mat.copy(kernel, this.kernelData, 0, 0, 16);\n      this.kernelData[16] = texSize as Float;\n      this.kernelData[17] = texSize as Float;\n      this.kernelData[18] = kernelWeight;\n      WebGL.writeBuffer(this.device, this.kernelDataBuffer!, this.kernelData);\n    }\n\n    // Draw cube to texture\n    WebGL.beginRenderPass(this.device, this.offscreenPass!);\n    {\n      WebGL.setRenderPipeline(this.device, this.cubePipeline!);\n      WebGL.setIndex(this.device, this.indexBuffer!);\n      WebGL.setVertex(this.device, 0, this.vertBuffer!);\n      WebGL.setBindGroup(this.device, 0, this.cubeBindGroup!);\n      WebGL.drawIndexed(this.device, cubeIndices.length);\n    }\n    WebGL.submitRenderPass(this.device);\n\n    // Draw to screen\n    WebGL.beginRenderPass(this.device, this.pass!);\n    {\n      WebGL.setRenderPipeline(this.device, this.quadPipeline!);\n      WebGL.setVertex(this.device, 0, this.quadVertBuffer!);\n      WebGL.setBindGroup(this.device, 0, this.offscreenTexBindGroup!);\n      WebGL.setBindGroup(this.device, 1, this.kernelBindGroup!);\n      WebGL.draw(this.device, 6);\n    }\n    WebGL.submitRenderPass(this.device);\n\n    return true;\n  }\n}\n","import { lookAt, mat, mat4, perspective, scale } from 'munum/assembly';\nimport {\n  BindGroup, BindingType, Buffer, BufferUsage, CompareFunction, CullMode, Device,\n  Float, RenderPipeline, RenderPipelineDescriptor, Sampler, ShaderStage, StencilOperation,\n  Texture, vertexBufferLayouts, VertexFormat, getImage, RenderPass, TextureFormat, TextureUsage\n} from '../interop/mugl';\nimport { BaseExample, createBuffer, Cube, Model, TEX_SIZE, toIndices, toVertices } from '../common';\n\nconst cubeVertices = toVertices({\n  positions: Cube.positions,\n  uvs: Cube.uvs\n} as Model);\nconst cubeIndices = toIndices(Cube);\nconst indexCount = cubeIndices.length;\n\n// Reverse face winding for skybox so that we can reuse the same pipeline\n// Store both index lists in the same buffer\nconst indices = new Uint16Array(indexCount * 2);\nfor (let i = 0; i < indexCount; ++i) {\n  indices[i] = cubeIndices[i];\n}\nfor (let i = 0; i < indexCount; i += 3) {\n  indices[indexCount + i] = cubeIndices[i + 2];\n  indices[indexCount + i + 1] = cubeIndices[i + 1];\n  indices[indexCount + i + 2] = cubeIndices[i];\n}\n\nconst texSize = TEX_SIZE;\n\nconst dataBufferSize = 64; // 20 floats, padding for 256 bytes alignment\nconst dataBufferByteSize = dataBufferSize * 4; // 4 bytes per float\n\nconst vert = `#version 300 es\nprecision mediump float;\nlayout(std140) uniform Data {\n  mat4 mvp;\n  vec4 outline;\n};\nlayout (location=0) in vec3 position;\nlayout (location=1) in vec2 uv;\nout vec2 vUv;\nvoid main(void) {\n  vUv = uv;\n  gl_Position = mvp * vec4(position, 1.0);\n}\n`;\n\nconst fragCube = `#version 300 es\nprecision mediump float;\nin vec2 vUv;\nout vec4 outColor;\nuniform sampler2D tex;\nvoid main () {\n  outColor = texture(tex, vUv);\n}\n`;\n\nconst fragColor = `#version 300 es\nprecision mediump float;\nlayout(std140) uniform Data {\n  mat4 mvp;\n  vec4 outline;\n};\nout vec4 outColor;\nvoid main () {\n  outColor = outline;\n}\n`;\n\nconst dataUniformWGPU = `\nstruct Data {\n  mvp: mat4x4<f32>,\n  outline: vec4<f32>,\n};\n@group(0) @binding(0) var<uniform> data: Data;\n`;\n\nconst vertOutWGPU = `\nstruct VertexOutput {\n  @builtin(position) clip_position: vec4<f32>,\n  @location(0) uv: vec2<f32>,\n  @location(1) normal: vec3<f32>,\n};\n`;\n\nconst vertWGPU = `\n${dataUniformWGPU}\n${vertOutWGPU}\n\nstruct VertexInput {\n  @location(0) position: vec3<f32>,\n  @location(1) uv: vec2<f32>,\n};\n\n@vertex\nfn vs_main(model: VertexInput) -> VertexOutput {\n  var out: VertexOutput;\n  out.clip_position = data.mvp * vec4<f32>(model.position, 1.0);\n  out.uv = model.uv;\n  out.normal = normalize(model.position);\n  return out;\n}\n`;\n\nconst fragCubeWGPU = `\n${vertOutWGPU}\n\n@group(1) @binding(0) var tex: texture_2d<f32>;\n@group(1) @binding(1) var tex_sampler: sampler;\n\n@fragment\nfn fs_main(in: VertexOutput) -> @location(0) vec4<f32> {\n    return textureSample(tex, tex_sampler, in.uv);\n}\n`;\n\nconst fragColorWGPU = `\n${dataUniformWGPU}\n${vertOutWGPU}\n\n@fragment\nfn fs_main(in: VertexOutput) -> @location(0) vec4<f32> {\n  return data.outline;\n}\n`;\n\nexport class StencilExample extends BaseExample {\n  pass: RenderPass | null = null;\n\n  vertBuffer: Buffer | null = null;\n  indexBuffer: Buffer | null = null;\n  // Store data for all 3 data bind groups in the same buffer and use dynamic offset to reference them\n  data: Float32Array = new Float32Array(dataBufferSize * 3);\n  dataBuffer: Buffer | null = null;\n\n  texture: Texture | null = null;\n  sampler: Sampler | null = null;\n\n  cubePipeline: RenderPipeline | null = null;\n  cubeOutlinePipeline: RenderPipeline | null = null;\n\n  textureBindGroup: BindGroup | null = null;\n  dataBindGroup: BindGroup | null = null;\n\n  constructor(\n    private readonly device: Device,\n    useWebGPU: boolean\n  ) {\n    super(useWebGPU);\n  }\n\n  init(): void {\n    // Create shaders\n    const vs = this.gpu.createShader(this.device, { code: this.useWebGPU ? vertWGPU : vert, usage: ShaderStage.Vertex });\n    const cubeFs = this.gpu.createShader(this.device, { code: this.useWebGPU ? fragCubeWGPU : fragCube, usage: ShaderStage.Fragment });\n    const outlineFs = this.gpu.createShader(this.device, { code: this.useWebGPU ? fragColorWGPU : fragColor, usage: ShaderStage.Fragment });\n\n    // Create buffers\n    this.vertBuffer = createBuffer(this.gpu, this.device, cubeVertices);\n    this.indexBuffer = createBuffer(this.gpu, this.device, indices, BufferUsage.Index);\n    this.dataBuffer = createBuffer(this.gpu, this.device, this.data, BufferUsage.Uniform | BufferUsage.Stream);\n\n    // Create cube texture\n    this.texture = this.gpu.createTexture(this.device, {\n      size: [texSize, texSize, 1],\n      usage: TextureUsage.TextureBinding | TextureUsage.RenderAttachment,\n    });\n    const image = getImage('airplane');\n    if (image) {\n      this.gpu.copyExternalImageToTexture(this.device, { src: image }, { texture: this.texture! });\n    }\n    this.sampler = this.gpu.createSampler(this.device, {});\n\n    const textureLayout = this.gpu.createBindGroupLayout(this.device, {\n      entries: [\n        { binding: 0, label: 'tex', type: BindingType.Texture },\n        { binding: 1, label: 'tex', type: BindingType.Sampler },\n      ]\n    });\n    const dataLayout = this.gpu.createBindGroupLayout(this.device, {\n      entries: [{ label: 'Data', type: BindingType.Buffer, bufferDynamicOffset: true }]\n    });\n\n    this.textureBindGroup = this.gpu.createBindGroup(this.device, {\n      layout: textureLayout,\n      entries: [{ binding: 0, texture: this.texture }, { binding: 1, sampler: this.sampler }]\n    });\n\n    this.dataBindGroup = this.gpu.createBindGroup(this.device, {\n      layout: dataLayout,\n      entries: [{ buffer: this.dataBuffer, bufferSize: dataBufferByteSize }]\n    });\n\n    const cubePipelineDesc: RenderPipelineDescriptor = {\n      vertex: vs,\n      fragment: cubeFs,\n      buffers: vertexBufferLayouts([\n        { attributes: [/* position */ VertexFormat.F32x3, /* uv */ VertexFormat.F32x2] }\n      ]),\n      bindGroups: [dataLayout, textureLayout],\n      depthStencil: {\n        format: TextureFormat.Depth24Stencil8,\n        depthWrite: true,\n        depthCompare: CompareFunction.LessEqual,\n        stencilBack: {\n          compare: CompareFunction.Always,\n          passOp: StencilOperation.Replace,\n        },\n        stencilFront: {\n          compare: CompareFunction.Always,\n          passOp: StencilOperation.Replace\n        }\n      },\n      primitive: {\n        cullMode: CullMode.Back\n      }\n    };\n    this.cubePipeline = this.gpu.createRenderPipeline(this.device, cubePipelineDesc);\n\n    this.cubeOutlinePipeline = this.gpu.createRenderPipeline(this.device, {\n      vertex: vs,\n      fragment: outlineFs,\n      buffers: cubePipelineDesc.buffers,\n      bindGroups: [dataLayout],\n      depthStencil: {\n        format: TextureFormat.Depth24Stencil8,\n        depthWrite: true,\n        stencilBack: {\n          compare: CompareFunction.NotEqual,\n        },\n        stencilFront: {\n          compare: CompareFunction.NotEqual,\n        },\n        stencilWriteMask: 0,\n      },\n      primitive: cubePipelineDesc.primitive,\n    });\n\n    this.pass = this.gpu.createRenderPass(this.device, {\n      clearDepth: 1,\n      clearStencil: 0\n    });\n\n    this.register([\n      this.vertBuffer!, this.indexBuffer!, this.dataBuffer!, this.texture!, this.sampler!,\n      this.textureBindGroup!, this.dataBindGroup!, this.cubePipeline!, this.cubeOutlinePipeline!,\n      this.pass!, vs, cubeFs, outlineFs, textureLayout, dataLayout\n    ]);\n  }\n\n  render(t: Float): boolean {\n    // Set uniforms\n    {\n      const proj = perspective((this.width as Float) / (this.height as Float), Math.PI / 4 as Float, 0.01, 100);\n      const view = lookAt([10 * Math.cos(t) as Float, 5 * Math.sin(t) as Float, 10 * Math.sin(t) as Float], [0, 0, 0]);\n      const vp = mat4.mul(proj, view);\n\n      let mvp = vp; // Cube at (0, 0, 0)\n      mat.copy(mvp, this.data, 0, 0, 16);\n\n      mvp = mat4.mul(vp, scale([1.1, 1.1, 1.1])); // Scale up for outline\n      mat.copy(mvp, this.data, 0, dataBufferSize, 16);\n      mat.copy([0.1 as Float, 0.3, 0.2, 1.0], this.data, 0, dataBufferSize + 16, 4); // Set outline color\n\n      mvp = mat4.mul(vp, scale([10, 10, 10])); // Scale up even more for skybox\n      mat.copy(mvp, this.data, 0, dataBufferSize * 2, 16);\n    }\n    this.gpu.writeBuffer(this.device, this.dataBuffer!, this.data);\n\n    this.gpu.beginRenderPass(this.device, this.pass!);\n\n    // Draw cube\n    this.gpu.setRenderPipeline(this.device, this.cubePipeline!);\n    this.gpu.setIndex(this.device, this.indexBuffer!);\n    this.gpu.setVertex(this.device, 0, this.vertBuffer!);\n    this.gpu.setBindGroup(this.device, 0, this.dataBindGroup!, [0]);\n    this.gpu.setBindGroup(this.device, 1, this.textureBindGroup!);\n    this.gpu.setStencilRef(this.device, 1);\n    this.gpu.drawIndexed(this.device, indexCount);\n\n    // Draw skybox, reusing the same pipeline and buffers\n    this.gpu.setBindGroup(this.device, 0, this.dataBindGroup!, [dataBufferByteSize * 2]);\n    this.gpu.setStencilRef(this.device, 0); // Use a different stencil value so that the outline can be drawn on top of it\n    this.gpu.drawIndexed(this.device, indexCount, 1, indexCount); // Use the reversed indices\n\n    // Draw outline\n    this.gpu.setRenderPipeline(this.device, this.cubeOutlinePipeline!);\n    this.gpu.setIndex(this.device, this.indexBuffer!);\n    this.gpu.setVertex(this.device, 0, this.vertBuffer!);\n    this.gpu.setBindGroup(this.device, 0, this.dataBindGroup!, [dataBufferByteSize]);\n    this.gpu.setStencilRef(this.device, 1);\n    this.gpu.drawIndexed(this.device, indexCount);\n\n    this.gpu.submitRenderPass(this.device);\n\n    return true;\n  }\n}\n","/// <reference path=\"./rt/index.d.ts\" />\n\nimport { OBJECT, BLOCK_MAXSIZE, TOTAL_OVERHEAD } from \"./rt/common\";\nimport { compareImpl, strtol, strtod, isSpace, isAscii, isFinalSigma, toLower8, toUpper8 } from \"./util/string\";\nimport { SPECIALS_UPPER, casemap, bsearch } from \"./util/casemap\";\nimport { E_INDEXOUTOFRANGE, E_INVALIDLENGTH, E_UNPAIRED_SURROGATE } from \"./util/error\";\nimport { idof } from \"./builtins\";\nimport { Array } from \"./array\";\n\n@final export abstract class String {\n\n  @lazy static readonly MAX_LENGTH: i32 = <i32>(BLOCK_MAXSIZE >>> alignof<u16>());\n\n  static fromCharCode(unit: i32, surr: i32 = -1): String {\n    let hasSur = surr > 0;\n    let out = changetype<String>(__new(2 << i32(hasSur), idof<String>()));\n    store<u16>(changetype<usize>(out), <u16>unit);\n    if (hasSur) store<u16>(changetype<usize>(out), <u16>surr, 2);\n    return out;\n  }\n\n  static fromCharCodes(units: Array<i32>): String {\n    let length = units.length;\n    let out = changetype<String>(__new(<usize>length << 1, idof<String>()));\n    let ptr = units.dataStart;\n    for (let i = 0; i < length; ++i) {\n      store<u16>(changetype<usize>(out) + (<usize>i << 1), load<i32>(ptr + (<usize>i << 2)));\n    }\n    return out;\n  }\n\n  static fromCodePoint(code: i32): String {\n    let hasSur = <u32>code > 0xFFFF;\n    let out = changetype<String>(__new(2 << i32(hasSur), idof<String>()));\n    if (!hasSur) {\n      store<u16>(changetype<usize>(out), <u16>code);\n    } else {\n      // Checks valid code point range\n      assert(<u32>code <= 0x10FFFF);\n      code -= 0x10000;\n      let hi = (code & 0x03FF) | 0xDC00;\n      let lo = code >>> 10 | 0xD800;\n      store<u32>(changetype<usize>(out), lo | hi << 16);\n    }\n    return out;\n  }\n\n  @builtin static raw(parts: TemplateStringsArray, ...args: unknown[]): string { return unreachable(); }\n\n  get length(): i32 {\n    return changetype<OBJECT>(changetype<usize>(this) - TOTAL_OVERHEAD).rtSize >> 1;\n  }\n\n  at(pos: i32): String {\n    let len = this.length;\n    pos += select(0, len, pos >= 0);\n    if (<u32>pos >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    let out = __new(2, idof<String>());\n    store<u16>(out, load<u16>(changetype<usize>(this) + (<usize>pos << 1)));\n    return changetype<String>(out); // retains\n  }\n\n  @operator(\"[]\") charAt(pos: i32): String {\n    if (<u32>pos >= <u32>this.length) return changetype<String>(\"\");\n    let out = changetype<String>(__new(2, idof<String>()));\n    store<u16>(changetype<usize>(out), load<u16>(changetype<usize>(this) + (<usize>pos << 1)));\n    return out;\n  }\n\n  charCodeAt(pos: i32): i32 {\n    if (<u32>pos >= <u32>this.length) return -1; // (NaN)\n    return load<u16>(changetype<usize>(this) + (<usize>pos << 1));\n  }\n\n  codePointAt(pos: i32): i32 {\n    let len = this.length;\n    if (<u32>pos >= <u32>len) return -1; // (undefined)\n    let first = <i32>load<u16>(changetype<usize>(this) + (<usize>pos << 1));\n    if ((first & 0xFC00) != 0xD800 || pos + 1 == len) return first;\n    let second = <i32>load<u16>(changetype<usize>(this) + (<usize>pos << 1), 2);\n    if ((second & 0xFC00) != 0xDC00) return first;\n    return (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;\n  }\n\n  @operator(\"+\") private static __concat(left: String, right: String): String {\n    return left.concat(right);\n  }\n\n  concat(other: String): String {\n    let thisSize: isize = this.length << 1;\n    let otherSize: isize = other.length << 1;\n    let outSize: usize = thisSize + otherSize;\n    if (outSize == 0) return changetype<String>(\"\");\n    let out = changetype<String>(__new(outSize, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this), thisSize);\n    memory.copy(changetype<usize>(out) + thisSize, changetype<usize>(other), otherSize);\n    return out;\n  }\n\n  endsWith(search: String, end: i32 = String.MAX_LENGTH): bool {\n    end = min(max(end, 0), this.length);\n    let searchLength = <isize>search.length;\n    let searchStart = <isize>end - searchLength;\n    if (searchStart < 0) return false;\n    // @ts-ignore: string <-> String\n    return !compareImpl(this, searchStart, search, 0, searchLength);\n  }\n\n  @operator(\"==\") private static __eq(left: String | null, right: String | null): bool {\n    if (changetype<usize>(left) == changetype<usize>(right)) return true;\n    if (changetype<usize>(left) == 0 || changetype<usize>(right) == 0) return false;\n    let leftLength = changetype<string>(left).length;\n    if (leftLength != changetype<string>(right).length) return false;\n    // @ts-ignore: string <-> String\n    return !compareImpl(left, 0, right, 0, leftLength);\n  }\n\n  @operator.prefix(\"!\")\n  private static __not(str: String | null): bool {\n    return changetype<usize>(str) == 0 || !changetype<string>(str).length;\n  }\n\n  @operator(\"!=\")\n  private static __ne(left: String | null, right: String | null): bool {\n    return !this.__eq(left, right);\n  }\n\n  @operator(\">\") private static __gt(left: String, right: String): bool {\n    if (changetype<usize>(left) == changetype<usize>(right)) return false;\n    let leftLength  = left.length;\n    if (!leftLength) return false;\n    let rightLength = right.length;\n    if (!rightLength) return true;\n    // @ts-ignore: string <-> String\n    let res = compareImpl(left, 0, right, 0, min(leftLength, rightLength));\n    return res ? res > 0 : leftLength > rightLength;\n  }\n\n  @operator(\">=\") private static __gte(left: String, right: String): bool {\n    return !this.__lt(left, right);\n  }\n\n  @operator(\"<\") private static __lt(left: String, right: String): bool {\n    if (changetype<usize>(left) == changetype<usize>(right)) return false;\n    let rightLength = right.length;\n    if (!rightLength) return false;\n    let leftLength  = left.length;\n    if (!leftLength) return true;\n    // @ts-ignore: string <-> String\n    let res = compareImpl(left, 0, right, 0, min(leftLength, rightLength));\n    return res ? res < 0 : leftLength < rightLength;\n  }\n\n  @operator(\"<=\") private static __lte(left: String, right: String): bool {\n    return !this.__gt(left, right);\n  }\n\n  includes(search: String, start: i32 = 0): bool {\n    return this.indexOf(search, start) != -1;\n  }\n\n  indexOf(search: String, start: i32 = 0): i32 {\n    let searchLen = <isize>search.length;\n    if (!searchLen) return 0;\n    let len = <isize>this.length;\n    if (!len) return -1;\n    let searchStart = min(max(<isize>start, 0), len);\n    for (len -= searchLen; searchStart <= len; ++searchStart) {\n      // @ts-ignore: string <-> String\n      if (!compareImpl(this, searchStart, search, 0, searchLen)) return <i32>searchStart;\n    }\n    return -1;\n  }\n\n  lastIndexOf(search: String, start: i32 = i32.MAX_VALUE): i32 {\n    let searchLen = <isize>search.length;\n    if (!searchLen) return this.length;\n    let len = this.length;\n    if (!len) return -1;\n    let searchStart = min(max(<isize>start, 0), <isize>len - searchLen);\n    for (; searchStart >= 0; --searchStart) {\n      // @ts-ignore: string <-> String\n      if (!compareImpl(this, searchStart, search, 0, searchLen)) return <i32>searchStart;\n    }\n    return -1;\n  }\n\n  // TODO: implement full locale comparison with locales and Collator options\n  localeCompare(other: String): i32 {\n    if (changetype<usize>(other) == changetype<usize>(this)) return 0;\n    let alen = this.length;\n    let blen = other.length;\n    // @ts-ignore: string <-> String\n    let res = compareImpl(this, 0, other, 0, <usize>min(alen, blen));\n    res = res ? res : alen - blen;\n    // normalize to [-1, 1] range\n    return i32(res > 0) - i32(res < 0);\n  }\n\n  startsWith(search: String, start: i32 = 0): bool {\n    let len = <isize>this.length;\n    let searchStart = min(max(<isize>start, 0), len);\n    let searchLength = <isize>search.length;\n    if (searchLength + searchStart > len) return false;\n    // @ts-ignore: string <-> String\n    return !compareImpl(this, searchStart, search, 0, searchLength);\n  }\n\n  substr(start: i32, length: i32 = i32.MAX_VALUE): String { // legacy\n    let intStart: isize = start;\n    let end: isize = length;\n    let len: isize = this.length;\n    if (intStart < 0) intStart = max(len + intStart, 0);\n    let size = min(max(end, 0), len - intStart) << 1;\n    if (size <= 0) return changetype<String>(\"\");\n    let out = changetype<String>(__new(size, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this) + (intStart << 1), size);\n    return out;\n  }\n\n  substring(start: i32, end: i32 = i32.MAX_VALUE): String {\n    let len: isize = this.length;\n    let finalStart = min<isize>(max(start, 0), len);\n    let finalEnd = min<isize>(max(end, 0), len);\n    let fromPos = min<isize>(finalStart, finalEnd) << 1;\n    let toPos = max<isize>(finalStart, finalEnd) << 1;\n    let size = toPos - fromPos;\n    if (!size) return changetype<String>(\"\");\n    if (!fromPos && toPos == len << 1) return this;\n    let out = changetype<String>(__new(size, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this) + fromPos, size);\n    return out;\n  }\n\n  trim(): String {\n    let len = this.length;\n    let size: usize = len << 1;\n    while (size && isSpace(load<u16>(changetype<usize>(this) + size - 2))) {\n      size -= 2;\n    }\n    let offset: usize = 0;\n    while (offset < size && isSpace(load<u16>(changetype<usize>(this) + offset))) {\n      offset += 2; size -= 2;\n    }\n    if (!size) return changetype<String>(\"\");\n    if (!offset && size == len << 1) return this;\n    let out = changetype<String>(__new(size, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this) + offset, size);\n    return out;\n  }\n\n  @inline\n  trimLeft(): String {\n    return this.trimStart();\n  }\n\n  @inline\n  trimRight(): String {\n    return this.trimEnd();\n  }\n\n  trimStart(): String {\n    let size = <usize>this.length << 1;\n    let offset: usize = 0;\n    while (offset < size && isSpace(load<u16>(changetype<usize>(this) + offset))) {\n      offset += 2;\n    }\n    if (!offset) return this;\n    size -= offset;\n    if (!size) return changetype<String>(\"\");\n    let out = changetype<String>(__new(size, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this) + offset, size);\n    return out;\n  }\n\n  trimEnd(): String {\n    let originalSize = <usize>this.length << 1;\n    let size = originalSize;\n    while (size && isSpace(load<u16>(changetype<usize>(this) + size - 2))) {\n      size -= 2;\n    }\n    if (!size) return changetype<String>(\"\");\n    if (size == originalSize) return this;\n    let out = changetype<String>(__new(size, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this), size);\n    return out;\n  }\n\n  padStart(length: i32, pad: string = \" \"): String {\n    let thisSize = <usize>this.length << 1;\n    let targetSize = <usize>length << 1;\n    let padSize = <usize>pad.length << 1;\n    if (targetSize < thisSize || !padSize) return this;\n    let prependSize = targetSize - thisSize;\n    let out = changetype<String>(__new(targetSize, idof<String>()));\n    if (prependSize > padSize) {\n      let repeatCount = (prependSize - 2) / padSize;\n      let restBase = repeatCount * padSize;\n      let restSize = prependSize - restBase;\n      memory.repeat(changetype<usize>(out), changetype<usize>(pad), padSize, repeatCount);\n      memory.copy(changetype<usize>(out) + restBase, changetype<usize>(pad), restSize);\n    } else {\n      memory.copy(changetype<usize>(out), changetype<usize>(pad), prependSize);\n    }\n    memory.copy(changetype<usize>(out) + prependSize, changetype<usize>(this), thisSize);\n    return out;\n  }\n\n  padEnd(length: i32, pad: string = \" \"): String {\n    let thisSize = <usize>this.length << 1;\n    let targetSize = <usize>length << 1;\n    let padSize = <usize>pad.length << 1;\n    if (targetSize < thisSize || !padSize) return this;\n    let appendSize = targetSize - thisSize;\n    let out = changetype<String>(__new(targetSize, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this), thisSize);\n    if (appendSize > padSize) {\n      let repeatCount = (appendSize - 2) / padSize;\n      let restBase = repeatCount * padSize;\n      let restSize = appendSize - restBase;\n      memory.repeat(changetype<usize>(out) + thisSize, changetype<usize>(pad), padSize, repeatCount);\n      memory.copy(changetype<usize>(out) + thisSize + restBase, changetype<usize>(pad), restSize);\n    } else {\n      memory.copy(changetype<usize>(out) + thisSize, changetype<usize>(pad), appendSize);\n    }\n    return out;\n  }\n\n  repeat(count: i32 = 0): String {\n    let length = this.length;\n\n    // Most browsers can't handle strings 1 << 28 chars or longer\n    if (count < 0 || <u64>length * count > (1 << 28)) {\n      throw new RangeError(E_INVALIDLENGTH);\n    }\n\n    if (count == 0 || !length) return changetype<String>(\"\");\n    if (count == 1) return this;\n    let out = changetype<String>(__new((length * count) << 1, idof<String>()));\n    memory.repeat(changetype<usize>(out), changetype<usize>(this), <usize>length << 1, count);\n    return out;\n  }\n\n  replace(search: String, replacement: String): String {\n    let len: usize = this.length;\n    let slen: usize = search.length;\n    if (len <= slen) {\n      return len < slen ? this : select<String>(replacement, this, search == this);\n    }\n    let index: isize = this.indexOf(search);\n    if (~index) {\n      let rlen: usize = replacement.length;\n      len -= slen;\n      let olen = len + rlen;\n      if (olen) {\n        let out = changetype<String>(__new(olen << 1, idof<String>()));\n        memory.copy(changetype<usize>(out), changetype<usize>(this), index << 1);\n        memory.copy(\n          changetype<usize>(out) + (index << 1),\n          changetype<usize>(replacement),\n          rlen << 1\n        );\n        memory.copy(\n          changetype<usize>(out) + ((index + rlen) << 1),\n          changetype<usize>(this) + ((index + slen) << 1),\n          (len - index) << 1\n        );\n        return out;\n      }\n    }\n    return this;\n  }\n\n  replaceAll(search: String, replacement: String): String {\n    let thisLen: usize = this.length;\n    let searchLen: usize = search.length;\n    if (thisLen <= searchLen) {\n      return thisLen < searchLen\n        ? this\n        : select<String>(replacement, this, search == this);\n    }\n    let replaceLen: usize = replacement.length;\n    if (!searchLen) {\n      if (!replaceLen) return this;\n      // Special case: 'abc'.replaceAll('', '-') -> '-a-b-c-'\n      let out = changetype<String>(__new((thisLen + (thisLen + 1) * replaceLen) << 1, idof<String>()));\n      memory.copy(changetype<usize>(out), changetype<usize>(replacement), replaceLen << 1);\n      let offset = replaceLen;\n      for (let i: usize = 0; i < thisLen; ++i) {\n        store<u16>(\n          changetype<usize>(out) + (offset++ << 1),\n          load<u16>(changetype<usize>(this) + (i << 1))\n        );\n        memory.copy(\n          changetype<usize>(out) + (offset << 1),\n          changetype<usize>(replacement),\n          replaceLen << 1\n        );\n        offset += replaceLen;\n      }\n      return out;\n    }\n    let prev: isize = 0, next: isize = 0;\n    if (searchLen == replaceLen) {\n      // Fast path when search and replacement have same length\n      let outSize = thisLen << 1;\n      let out = changetype<String>(__new(outSize, idof<String>()));\n      memory.copy(changetype<usize>(out), changetype<usize>(this), outSize);\n      while (~(next = <isize>this.indexOf(search, <i32>prev))) {\n        memory.copy(changetype<usize>(out) + (next << 1), changetype<usize>(replacement), replaceLen << 1);\n        prev = next + searchLen;\n      }\n      return out;\n    }\n    let out: String | null = null, offset: usize = 0, outSize = thisLen;\n    while (~(next = <isize>this.indexOf(search, <i32>prev))) {\n      if (!out) out = changetype<String>(__new(thisLen << 1, idof<String>()));\n      let chunk = next - prev;\n      if (offset + chunk + replaceLen > outSize) {\n        outSize <<= 1;\n        out = changetype<String>(__renew(changetype<usize>(out), outSize << 1));\n      }\n      memory.copy(\n        changetype<usize>(out) + (offset << 1),\n        changetype<usize>(this) + (prev << 1),\n        chunk << 1\n      );\n      offset += chunk;\n      memory.copy(\n        changetype<usize>(out) + (offset << 1),\n        changetype<usize>(replacement),\n        replaceLen << 1\n      );\n      offset += replaceLen;\n      prev = next + searchLen;\n    }\n    if (out) {\n      let rest = thisLen - prev;\n      if (offset + rest > outSize) {\n        outSize <<= 1;\n        out = changetype<String>(__renew(changetype<usize>(out), outSize << 1));\n      }\n      if (rest) {\n        memory.copy(\n          changetype<usize>(out) + (offset << 1),\n          changetype<usize>(this) + (prev << 1),\n          rest << 1\n        );\n      }\n      rest += offset;\n      if (outSize > rest) {\n        out = changetype<String>(__renew(changetype<usize>(out), rest << 1));\n      }\n      return out;\n    }\n    return this;\n  }\n\n  slice(start: i32, end: i32 = i32.MAX_VALUE): String {\n    let len = this.length;\n    start = start < 0 ? max(start + len, 0) : min(start, len);\n    end   = end   < 0 ? max(end   + len, 0) : min(end,   len);\n    len   = end - start;\n    if (len <= 0) return changetype<String>(\"\");\n    let out = changetype<String>(__new(len << 1, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this) + (<usize>start << 1), <usize>len << 1);\n    return out;\n  }\n\n  split(separator: String | null = null, limit: i32 = i32.MAX_VALUE): String[] {\n    if (!limit) return changetype<String[]>(__newArray(0, alignof<String>(), idof<Array<String>>()));\n    if (changetype<usize>(separator) == 0) return [ this ];\n    let length: isize = this.length;\n    let sepLen = changetype<string>(separator).length;\n    if (limit < 0) limit = i32.MAX_VALUE;\n    if (!sepLen) {\n      if (!length) return changetype<String[]>(__newArray(0, alignof<String>(), idof<Array<String>>()));\n      // split by chars\n      length = min<isize>(length, <isize>limit);\n      let result = changetype<String[]>(__newArray(<i32>length, alignof<String>(), idof<Array<String>>()));\n      // @ts-ignore: cast\n      let resultStart = result.dataStart as usize;\n      for (let i: isize = 0; i < length; ++i) {\n        let charStr = changetype<String>(__new(2, idof<String>()));\n        store<u16>(changetype<usize>(charStr), load<u16>(changetype<usize>(this) + (<usize>i << 1)));\n        store<usize>(resultStart + (<usize>i << alignof<usize>()), changetype<usize>(charStr)); // result[i] = charStr\n        __link(changetype<usize>(result), changetype<usize>(charStr), true);\n      }\n      return result;\n    } else if (!length) {\n      let result = changetype<String[]>(__newArray(1, alignof<String>(), idof<Array<String>>()));\n      // @ts-ignore: cast\n      store<usize>(result.dataStart as usize, changetype<usize>(\"\")); // static \"\"\n      return result;\n    }\n    let result = changetype<String[]>(__newArray(0, alignof<String>(), idof<Array<String>>()));\n    let end = 0, start = 0, i = 0;\n    while (~(end = this.indexOf(changetype<string>(separator), start))) {\n      let len = end - start;\n      if (len > 0) {\n        let out = changetype<String>(__new(<usize>len << 1, idof<String>()));\n        memory.copy(changetype<usize>(out), changetype<usize>(this) + (<usize>start << 1), <usize>len << 1);\n        result.push(out);\n      } else {\n        result.push(changetype<String>(\"\"));\n      }\n      if (++i == limit) return result;\n      start = end + sepLen;\n    }\n    if (!start) { // also means: loop above didn't do anything\n      result.push(this);\n      return result;\n    }\n    let len = length - start;\n    if (len > 0) {\n      let out = changetype<String>(__new(<usize>len << 1, idof<String>()));\n      memory.copy(changetype<usize>(out), changetype<usize>(this) + (<usize>start << 1), <usize>len << 1);\n      result.push(out);\n    } else {\n      result.push(changetype<String>(\"\")); // static \"\"\n    }\n    return result;\n  }\n\n  toLowerCase(): String {\n    let len = <usize>this.length;\n    if (!len) return this;\n    let codes = changetype<String>(__new(len * 2 * 2, idof<String>()));\n    let j: usize = 0;\n    for (let i: usize = 0; i < len; ++i, ++j) {\n      let c = <u32>load<u16>(changetype<usize>(this) + (i << 1));\n      if (isAscii(c)) {\n        store<u16>(changetype<usize>(codes) + (j << 1), toLower8(c));\n      } else {\n        // check and read surrogate pair\n        if ((c - 0xD7FF < 0xDC00 - 0xD7FF) && i < len - 1) {\n          let c1 = <u32>load<u16>(changetype<usize>(this) + (i << 1), 2);\n          if (c1 - 0xDBFF < 0xE000 - 0xDBFF) {\n            let c0 = c;\n            c = (((c & 0x03FF) << 10) | (c1 & 0x03FF)) + 0x10000;\n            ++i;\n            if (c >= 0x20000) {\n              store<u32>(changetype<usize>(codes) + (j << 1), c0 | (c1 << 16));\n              ++j;\n              continue;\n            }\n          }\n        }\n        // check special casing for lower table. It has one ently so instead lookup we just inline this.\n        if (c == 0x0130) {\n          // 0x0130 -> [0x0069, 0x0307]\n          store<u32>(changetype<usize>(codes) + (j << 1), (0x0307 << 16) | 0x0069);\n          ++j;\n        } else if (c == 0x03A3) { // 'Σ'\n          // Σ maps to σ but except at the end of a word where it maps to ς\n          let sigma = 0x03C3; // σ\n          if (len > 1 && isFinalSigma(changetype<usize>(this), i, len)) {\n            sigma = 0x03C2; // ς\n          }\n          store<u16>(changetype<usize>(codes) + (j << 1), sigma);\n        } else if (c - 0x24B6 <= 0x24CF - 0x24B6) {\n          // Range 0x24B6 <= c <= 0x24CF not covered by casemap and require special early handling\n          store<u16>(changetype<usize>(codes) + (j << 1), c + 26);\n        } else {\n          let code = casemap(c, 0) & 0x1FFFFF;\n          if (code < 0x10000) {\n            store<u16>(changetype<usize>(codes) + (j << 1), code);\n          } else {\n            // store as surrogare pair\n            code -= 0x10000;\n            let lo = (code >>> 10) | 0xD800;\n            let hi = (code & 0x03FF) | 0xDC00;\n            store<u32>(changetype<usize>(codes) + (j << 1), lo | (hi << 16));\n            ++j;\n          }\n        }\n      }\n    }\n    return changetype<String>(__renew(changetype<usize>(codes), j << 1));\n  }\n\n  toUpperCase(): String {\n    let len = <usize>this.length;\n    if (!len) return this;\n    let codes = changetype<String>(__new(len * 3 * 2, idof<String>()));\n    let specialsPtr = changetype<usize>(SPECIALS_UPPER);\n    let specialsLen = SPECIALS_UPPER.length;\n    let j: usize = 0;\n    for (let i: usize = 0; i < len; ++i, ++j) {\n      let c = <u32>load<u16>(changetype<usize>(this) + (i << 1));\n      if (isAscii(c)) {\n        store<u16>(changetype<usize>(codes) + (j << 1), toUpper8(c));\n      } else {\n        // check and read surrogate pair\n        if ((c - 0xD7FF < 0xDC00 - 0xD7FF) && i < len - 1) {\n          let c1 = <u32>load<u16>(changetype<usize>(this) + (i << 1), 2);\n          if (c1 - 0xDBFF < 0xE000 - 0xDBFF) {\n            let c0 = c;\n            c = (((c & 0x03FF) << 10) | (c1 & 0x03FF)) + 0x10000;\n            ++i;\n            if (c >= 0x20000) {\n              store<u32>(changetype<usize>(codes) + (j << 1), c0 | (c1 << 16));\n              ++j;\n              continue;\n            }\n          }\n        }\n        // Range 0x24D0 <= c <= 0x24E9 not covered by casemap and require special early handling\n        if (c - 0x24D0 <= 0x24E9 - 0x24D0) {\n          // monkey patch\n          store<u16>(changetype<usize>(codes) + (j << 1), c - 26);\n        } else {\n          let index: usize = -1;\n          // Fast range check. See first and last rows in specialsUpper table\n          if (c - 0x00DF <= 0xFB17 - 0x00DF) {\n            index = <usize>bsearch(c, specialsPtr, specialsLen);\n          }\n          if (~index) {\n            // load next 3 code points from row with `index` offset for specialsUpper table\n            let ab = load<u32>(specialsPtr + (index << 1), 2);\n            let cc = load<u16>(specialsPtr + (index << 1), 6);\n            store<u32>(changetype<usize>(codes) + (j << 1), ab, 0);\n            store<u16>(changetype<usize>(codes) + (j << 1), cc, 4);\n            j += 1 + usize(cc != 0);\n          } else {\n            let code = casemap(c, 1) & 0x1FFFFF;\n            if (code < 0x10000) {\n              store<u16>(changetype<usize>(codes) + (j << 1), code);\n            } else {\n              // store as surrogare pair\n              code -= 0x10000;\n              let lo = (code >>> 10) | 0xD800;\n              let hi = (code & 0x03FF) | 0xDC00;\n              store<u32>(changetype<usize>(codes) + (j << 1), lo | (hi << 16));\n              ++j;\n            }\n          }\n        }\n      }\n    }\n    return changetype<String>(__renew(changetype<usize>(codes), j << 1));\n  }\n\n  toString(): String {\n    return this;\n  }\n}\n\n// @ts-ignore: nolib\nexport type string = String;\n\nexport function parseInt(str: string, radix: i32 = 0): f64 {\n  return strtol<f64>(str, radix);\n}\n\nexport function parseFloat(str: string): f64 {\n  return strtod(str);\n}\n\n// Encoding helpers\nexport namespace String {\n\n  export namespace UTF8 {\n\n    export const enum ErrorMode {\n      WTF8,\n      REPLACE,\n      ERROR\n    }\n\n    export function byteLength(str: string, nullTerminated: bool = false): i32 {\n      let strOff = changetype<usize>(str);\n      let strEnd = strOff + <usize>changetype<OBJECT>(changetype<usize>(str) - TOTAL_OVERHEAD).rtSize;\n      let bufLen = i32(nullTerminated);\n      while (strOff < strEnd) {\n        let c1 = <u32>load<u16>(strOff);\n        if (c1 < 128) {\n          // @ts-ignore: cast\n          if (nullTerminated & !c1) break;\n          bufLen += 1;\n        } else if (c1 < 2048) {\n          bufLen += 2;\n        } else {\n          if ((c1 & 0xFC00) == 0xD800 && strOff + 2 < strEnd) {\n            if ((<u32>load<u16>(strOff, 2) & 0xFC00) == 0xDC00) {\n              bufLen += 4; strOff += 4;\n              continue;\n            }\n          }\n          bufLen += 3;\n        }\n        strOff += 2;\n      }\n      return bufLen;\n    }\n\n    export function encode(str: string, nullTerminated: bool = false, errorMode: ErrorMode = ErrorMode.WTF8): ArrayBuffer {\n      let buf = changetype<ArrayBuffer>(__new(<usize>byteLength(str, nullTerminated), idof<ArrayBuffer>()));\n      encodeUnsafe(changetype<usize>(str), str.length, changetype<usize>(buf), nullTerminated, errorMode);\n      return buf;\n    }\n\n    // @ts-ignore: decorator\n    @unsafe\n    export function encodeUnsafe(str: usize, len: i32, buf: usize, nullTerminated: bool = false, errorMode: ErrorMode = ErrorMode.WTF8): usize {\n      let strEnd = str + (<usize>len << 1);\n      let bufOff = buf;\n      while (str < strEnd) {\n        let c1 = <u32>load<u16>(str);\n        if (c1 < 128) {\n          store<u8>(bufOff, c1);\n          bufOff++;\n          // @ts-ignore: cast\n          if (nullTerminated & !c1) return bufOff - buf;\n        } else if (c1 < 2048) {\n          let b0 = c1 >> 6 | 192;\n          let b1 = c1 & 63 | 128;\n          store<u16>(bufOff, b1 << 8 | b0);\n          bufOff += 2;\n        } else {\n          // D800: 11011 0 0000000000 Lead\n          // DBFF: 11011 0 1111111111\n          // DC00: 11011 1 0000000000 Trail\n          // DFFF: 11011 1 1111111111\n          // F800: 11111 0 0000000000 Mask\n          // FC00: 11111 1 0000000000\n          if ((c1 & 0xF800) == 0xD800) {\n            if (c1 < 0xDC00 && str + 2 < strEnd) {\n              let c2 = <u32>load<u16>(str, 2);\n              if ((c2 & 0xFC00) == 0xDC00) {\n                c1 = 0x10000 + ((c1 & 0x03FF) << 10) | (c2 & 0x03FF);\n                let b0 = c1 >> 18 | 240;\n                let b1 = c1 >> 12 & 63 | 128;\n                let b2 = c1 >> 6  & 63 | 128;\n                let b3 = c1       & 63 | 128;\n                store<u32>(bufOff, b3 << 24 | b2 << 16 | b1 << 8 | b0);\n                bufOff += 4; str += 4;\n                continue;\n              }\n            }\n            if (errorMode != ErrorMode.WTF8) { // unlikely\n              if (errorMode == ErrorMode.ERROR) throw new Error(E_UNPAIRED_SURROGATE);\n              c1 = 0xFFFD;\n            }\n          }\n          let b0 = c1 >> 12 | 224;\n          let b1 = c1 >> 6  & 63 | 128;\n          let b2 = c1       & 63 | 128;\n          store<u16>(bufOff, b1 << 8 | b0);\n          store<u8>(bufOff, b2, 2);\n          bufOff += 3;\n        }\n        str += 2;\n      }\n      if (nullTerminated) {\n        store<u8>(bufOff++, 0);\n      }\n      return bufOff - buf;\n    }\n\n    export function decode(buf: ArrayBuffer, nullTerminated: bool = false): String {\n      return decodeUnsafe(changetype<usize>(buf), buf.byteLength, nullTerminated);\n    }\n\n    // @ts-ignore: decorator\n    @unsafe\n    export function decodeUnsafe(buf: usize, len: usize, nullTerminated: bool = false): String {\n      let bufOff = buf;\n      let bufEnd = buf + len;\n      assert(bufEnd >= bufOff); // guard wraparound\n      let str = changetype<String>(__new(len << 1, idof<String>())); // max is one u16 char per u8 byte\n      let strOff = changetype<usize>(str);\n      while (bufOff < bufEnd) {\n        let u0 = <u32>load<u8>(bufOff); ++bufOff;\n        if (!(u0 & 128)) {\n          // @ts-ignore: cast\n          if (nullTerminated & !u0) break;\n          store<u16>(strOff, u0);\n        } else {\n          if (bufEnd == bufOff) break;\n          let u1 = <u32>load<u8>(bufOff) & 63; ++bufOff;\n          if ((u0 & 224) == 192) {\n            store<u16>(strOff, (u0 & 31) << 6 | u1);\n          } else {\n            if (bufEnd == bufOff) break;\n            let u2 = <u32>load<u8>(bufOff) & 63; ++bufOff;\n            if ((u0 & 240) == 224) {\n              u0 = (u0 & 15) << 12 | u1 << 6 | u2;\n            } else {\n              if (bufEnd == bufOff) break;\n              u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | <u32>load<u8>(bufOff) & 63;\n              ++bufOff;\n            }\n            if (u0 < 0x10000) {\n              store<u16>(strOff, u0);\n            } else {\n              u0 -= 0x10000;\n              let lo = u0 >> 10 | 0xD800;\n              let hi = (u0 & 0x03FF) | 0xDC00;\n              store<u32>(strOff, lo | (hi << 16));\n              strOff += 2;\n            }\n          }\n        }\n        strOff += 2;\n      }\n      return changetype<String>(__renew(changetype<usize>(str), strOff - changetype<usize>(str)));\n    }\n  }\n\n  export namespace UTF16 {\n\n    export function byteLength(str: string): i32 {\n      return changetype<OBJECT>(changetype<usize>(str) - TOTAL_OVERHEAD).rtSize;\n    }\n\n    export function encode(str: string): ArrayBuffer {\n      let buf = changetype<ArrayBuffer>(__new(<usize>byteLength(str), idof<ArrayBuffer>()));\n      encodeUnsafe(changetype<usize>(str), str.length, changetype<usize>(buf));\n      return buf;\n    }\n\n    // @ts-ignore: decorator\n    @unsafe\n    export function encodeUnsafe(str: usize, len: i32, buf: usize): usize {\n      let size = <usize>len << 1;\n      memory.copy(buf, changetype<usize>(str), size);\n      return size;\n    }\n\n    export function decode(buf: ArrayBuffer): String {\n      return decodeUnsafe(changetype<usize>(buf), buf.byteLength);\n    }\n\n    // @ts-ignore: decorator\n    @unsafe\n    export function decodeUnsafe(buf: usize, len: usize): String {\n      let str = changetype<String>(__new(len &= ~1, idof<String>()));\n      memory.copy(changetype<usize>(str), buf, len);\n      return str;\n    }\n  }\n}\n\nexport class TemplateStringsArray extends Array<string> {\n  readonly raw: string[];\n}\n","import { lookAt, mat, mat4, Mat4, perspective, scale } from 'munum/assembly';\nimport {\n  AddressMode, BaseGPU, BindGroup, BindingType, Buffer, BufferUsage, CompareFunction, CullMode, Device,\n  FilterMode, Float, RenderPipeline, RenderPipelineDescriptor, Sampler, ShaderStage, Texture,\n  TextureDimension, UInt, vertexBufferLayouts, VertexFormat, getImage, RenderPass, TextureFormat, TextureUsage\n} from '../interop/mugl';\nimport { BaseExample, createBuffer, Cube, Model, TEX_SIZE, toIndices, toVertices } from '../common';\n\nconst texSize = TEX_SIZE;\n\n// Double the cube UVs for repeating effect\nconst cubeUvs: Float[][] = [];\nfor (let i = 0; i < Cube.uvs!.length; ++i) {\n  const uv = Cube.uvs![i];\n  cubeUvs.push([uv[0] * 2, uv[1] * 2]);\n}\nconst cubeVertices = toVertices({\n  positions: Cube.positions,\n  uvs: cubeUvs\n} as Model);\nconst cubeIndices = toIndices(Cube);\n\nconst vert = `#version 300 es\nlayout(std140) uniform Camera {\n  mat4 mvp;\n};\nlayout (location=0) in vec3 position;\nlayout (location=1) in vec2 uv;\nout vec2 vUv;\nout vec3 vNormal;\nvoid main(void) {\n  vUv = uv;\n  vNormal = normalize(position);\n  gl_Position = mvp * vec4(position, 1.0);\n}\n`;\n\nconst fragCube = `#version 300 es\nprecision mediump float;\nuniform sampler2D tex;\nin vec2 vUv;\nout vec4 outColor;\nvoid main () {\n  outColor = texture(tex, vUv);\n}\n`;\n\nconst fragSky = `#version 300 es\nprecision mediump float;\nuniform samplerCube tex;\nin vec3 vNormal;\nout vec4 outColor;\nvoid main () {\n  outColor = texture(tex, normalize(vNormal));\n}\n`;\n\nconst dataUniformWGPU = `\nstruct Data {\n  mvp: mat4x4<f32>,\n};\n@group(1) @binding(0) var<uniform> data: Data;\n`;\n\nconst vertOutWGPU = `\nstruct VertexOutput {\n  @builtin(position) clip_position: vec4<f32>,\n  @location(0) uv: vec2<f32>,\n  @location(1) normal: vec3<f32>,\n};\n`;\n\nconst vertWGPU = `\n${dataUniformWGPU}\n${vertOutWGPU}\n\nstruct VertexInput {\n  @location(0) position: vec3<f32>,\n  @location(1) uv: vec2<f32>,\n};\n\n@vertex\nfn vs_main(model: VertexInput) -> VertexOutput {\n  var out: VertexOutput;\n  out.clip_position = data.mvp * vec4<f32>(model.position, 1.0);\n  out.uv = model.uv;\n  out.normal = normalize(model.position);\n  return out;\n}\n`;\n\nconst fragCubeWGPU = `\n${vertOutWGPU}\n\n@group(0) @binding(0) var tex: texture_2d<f32>;\n@group(0) @binding(1) var tex_sampler: sampler;\n\n@fragment\nfn fs_main(in: VertexOutput) -> @location(0) vec4<f32> {\n    return textureSample(tex, tex_sampler, in.uv);\n}\n`;\n\nconst fragSkyWGPU = `\n${vertOutWGPU}\n\n@group(0) @binding(0) var tex: texture_cube<f32>;\n@group(0) @binding(1) var tex_sampler: sampler;\n\n@fragment\nfn fs_main(in: VertexOutput) -> @location(0) vec4<f32> {\n  return textureSample(tex, tex_sampler, normalize(in.normal));\n}\n`;\n\nclass TextureRenderBundle {\n  public pipeline: RenderPipeline;\n  public texture: Texture;\n  public sampler: Sampler;\n  public cameraData: Float32Array = new Float32Array(16);\n  public cameraBuffer!: Buffer;\n  public textureBindGroup!: BindGroup;\n  public cameraBindGroup!: BindGroup;\n\n  public constructor(\n    private readonly gpu: BaseGPU,\n    public device: Device,\n    pipelineDesc: RenderPipelineDescriptor,\n    textureType: TextureDimension,\n    public vertexBuffer: Buffer,\n    public indexBuffer: Buffer,\n    public indexCount: UInt\n  ) {\n    const textureLayout = gpu.createBindGroupLayout(device, {\n      entries: [\n        { label: 'tex', type: BindingType.Texture, textureDimension: textureType, binding: 0 },\n        { label: 'tex', type: BindingType.Sampler, binding: 1 },\n      ]\n    });\n    const cameraLayout = gpu.createBindGroupLayout(device, {\n      entries: [{ label: 'Camera', type: BindingType.Buffer }]\n    });\n\n    pipelineDesc.bindGroups = [textureLayout, cameraLayout];\n    this.pipeline = gpu.createRenderPipeline(device, pipelineDesc);\n\n    this.texture = gpu.createTexture(device, {\n      dimension: textureType,\n      size: [texSize, texSize, 1],\n      usage: TextureUsage.TextureBinding | TextureUsage.RenderAttachment,\n    });\n    this.sampler = gpu.createSampler(device, {\n      magFilter: FilterMode.Linear,\n      minFilter: FilterMode.Linear,\n      mipmapFilter: FilterMode.Linear,\n      addressModeU: AddressMode.Repeat,\n      addressModeV: AddressMode.Repeat,\n      maxAnisotropy: 16\n    });\n    this.cameraBuffer = createBuffer(gpu, device, this.cameraData, BufferUsage.Uniform | BufferUsage.Stream);\n\n    this.textureBindGroup = gpu.createBindGroup(device, {\n      layout: textureLayout,\n      entries: [{ binding: 0, texture: this.texture }, { binding: 1, sampler: this.sampler }]\n    });\n    this.cameraBindGroup = gpu.createBindGroup(device, {\n      layout: cameraLayout,\n      entries: [{ buffer: this.cameraBuffer }]\n    });\n\n    textureLayout.destroy();\n    cameraLayout.destroy();\n  }\n\n  public updateCamera(mvp: Mat4): void {\n    mat.copy(mvp, this.cameraData, 0, 0, 16);\n    this.gpu.writeBuffer(this.device, this.cameraBuffer, this.cameraData);\n  }\n\n  public render(device: Device): void {\n    this.gpu.setRenderPipeline(device, this.pipeline);\n    this.gpu.setIndex(device, this.indexBuffer);\n    this.gpu.setVertex(device, 0, this.vertexBuffer);\n    this.gpu.setBindGroup(device, 0, this.textureBindGroup);\n    this.gpu.setBindGroup(device, 1, this.cameraBindGroup);\n    this.gpu.drawIndexed(device, this.indexCount);\n  }\n\n  public destroy(): void {\n    this.pipeline.destroy();\n    this.textureBindGroup.destroy();\n    this.cameraBindGroup.destroy();\n    this.texture.destroy();\n    this.sampler.destroy();\n    this.cameraBuffer.destroy();\n  }\n}\n\nexport class TextureExample extends BaseExample {\n  pass: RenderPass | null = null;\n\n  vertBuffer: Buffer | null = null;\n  indexBuffer: Buffer | null = null;\n\n  cube: TextureRenderBundle | null = null;\n  skybox: TextureRenderBundle | null = null;\n\n  constructor(\n    private readonly device: Device,\n    useWebGPU: boolean\n  ) {\n    super(useWebGPU);\n  }\n\n  init(): void {\n    // Get texture images\n    const airplane = getImage('airplane');\n    const sky0 = getImage('sky0');\n    const sky1 = getImage('sky1');\n    const sky2 = getImage('sky2');\n\n    // Create shaders\n    const vs = this.gpu.createShader(this.device, { code: this.useWebGPU ? vertWGPU : vert, usage: ShaderStage.Vertex });\n    const cubeFs = this.gpu.createShader(this.device, { code: this.useWebGPU ? fragCubeWGPU : fragCube, usage: ShaderStage.Fragment });\n    const skyFs = this.gpu.createShader(this.device, { code: this.useWebGPU ? fragSkyWGPU : fragSky, usage: ShaderStage.Fragment });\n\n    // Create buffers\n    this.vertBuffer = createBuffer(this.gpu, this.device, cubeVertices);\n    this.indexBuffer = createBuffer(this.gpu, this.device, cubeIndices, BufferUsage.Index);\n\n    // Create the cube\n    const cubePipelineDesc: RenderPipelineDescriptor = {\n      vertex: vs,\n      fragment: cubeFs,\n      buffers: vertexBufferLayouts([\n        { attributes: [/* position */ VertexFormat.F32x3, /* uv */ VertexFormat.F32x2] }\n      ]),\n      depthStencil: {\n        format: TextureFormat.Depth24Stencil8,\n        depthWrite: true,\n        depthCompare: CompareFunction.LessEqual\n      },\n      primitive: {\n        cullMode: CullMode.Back\n      }\n    };\n    this.cube = new TextureRenderBundle(\n      this.gpu, this.device,\n      cubePipelineDesc, TextureDimension.D2, this.vertBuffer!, this.indexBuffer!, cubeIndices.length\n    );\n    if (airplane) {\n      this.gpu.copyExternalImageToTexture(this.device, { src: airplane }, { texture: this.cube!.texture });\n      // TODO: no auto mipmap for WebGPU\n      // this.gpu.generateMipmap(this.device, this.cube!.texture);\n    }\n\n    // Create the skybox\n    const skyboxPipelineDesc: RenderPipelineDescriptor = {\n      vertex: vs,\n      fragment: skyFs,\n      buffers: cubePipelineDesc.buffers,\n      depthStencil: cubePipelineDesc.depthStencil,\n      primitive: {\n        cullMode: CullMode.Front // Render back face for sky box\n      }\n    };\n    this.skybox = new TextureRenderBundle(\n      this.gpu, this.device,\n      skyboxPipelineDesc, TextureDimension.CubeMap, this.vertBuffer!, this.indexBuffer!, cubeIndices.length\n    );\n    if (sky0 && sky1 && sky2) {\n      const cubeImages = [sky0, sky0, sky1, sky2, sky0, sky0];\n      for (let z = 0; z < 6; ++z) {\n        this.gpu.copyExternalImageToTexture(this.device, { src: cubeImages[z] }, { texture: this.skybox!.texture, origin: [0, 0, z] });\n      }\n      // TODO: no auto mipmap for WebGPU\n      // this.gpu.generateMipmap(this.device, this.skybox!.texture);\n    }\n\n    this.pass = this.gpu.createRenderPass(this.device, { clearColor: [0.1, 0.2, 0.3, 1], clearDepth: 1 });\n\n    this.register([\n      this.vertBuffer!, this.indexBuffer!, this.pass!, vs, cubeFs, skyFs,\n    ]);\n  }\n\n  render(t: Float): boolean {\n    const proj = perspective((this.width as Float) / (this.height as Float), Math.PI / 4 as Float, 0.01, 100);\n    const view = lookAt([10 * Math.cos(t) as Float, 5 * Math.sin(t) as Float, 10 * Math.sin(t) as Float], [0, 0, 0]);\n    const vp = mat4.mul(proj, view);\n\n    let mvp = vp; // Cube at (0, 0, 0)\n    this.cube!.updateCamera(mvp);\n\n    mvp = mat4.mul(vp, scale([10, 10, 10]), vp);  // Make the skybox bigger\n    this.skybox!.updateCamera(mvp);\n\n    this.gpu.beginRenderPass(this.device, this.pass!);\n    this.cube!.render(this.device);\n    this.skybox!.render(this.device);\n    this.gpu.submitRenderPass(this.device);\n\n    return true;\n  }\n\n  destroy(): void {\n    super.destroy();\n    this.cube!.destroy();\n    this.skybox!.destroy();\n  }\n}\n","import { ExampleFactory } from '../common';\nimport { BasicExample } from './basic';\nimport { InstancingExample } from './instancing';\nimport { MRTExample } from './mrt';\nimport { PbrExample } from './pbr';\nimport { PostprocessExample } from './postprocess';\nimport { StencilExample } from './stencil';\nimport { TextureExample } from './texture';\n\nexport class AppDefinition {\n  public constructor(\n    public readonly id: string,\n    public readonly title: string,\n    public readonly factory: ExampleFactory\n  ) {\n  }\n}\n\nexport const Apps = [\n  new AppDefinition('basic', 'Hello World', (device, useWebGPU) => new BasicExample(device, useWebGPU)),\n  new AppDefinition('instancing', 'Buffers & Instancing', (device, useWebGPU) => new InstancingExample(device, useWebGPU)),\n  new AppDefinition('texture', 'Texture & Sampler', (device, useWebGPU) => new TextureExample(device, useWebGPU)),\n  new AppDefinition('stencil', 'Depth Stencil', (device, useWebGPU) => new StencilExample(device, useWebGPU)),\n  new AppDefinition('postprocess', 'Post-processing', (device, useWebGPU) => new PostprocessExample(device)),\n  new AppDefinition('mrt', 'Multi Render Targets', (device, useWebGPU) => new MRTExample(device)),\n  new AppDefinition('pbr', 'Physically Based Rendering', (device, useWebGPU) => new PbrExample(device)),\n];\n","import { BaseGPU, Device, Float, Resource, UInt, WebGL, WebGPU } from '../interop/mugl';\n\nexport type ExampleFactory = (device: Device, useWebGPU: boolean) => ExampleApplication;\n\nexport abstract class ExampleApplication {\n  public init(): void { /* empty */ }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  public render(delta: Float): boolean {\n    return false;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  public resize(width: UInt, height: UInt): void { /* empty */ }\n\n  public destroy(): void { /* empty */ }\n}\n\nexport abstract class BaseExample extends ExampleApplication {\n  protected resources: Resource[] = [];\n  protected width: UInt = 1;\n  protected height: UInt = 1;\n\n  public constructor(protected readonly useWebGPU: boolean = false) {\n    super();\n  }\n\n  public get gpu(): BaseGPU {\n    return this.useWebGPU ? WebGPU : WebGL;\n  }\n\n  public resize(width: UInt, height: UInt): void {\n    this.width = width;\n    this.height = height;\n  }\n\n  public destroy(): void {\n    for (let i = 0; i < this.resources.length; ++i) {\n      this.resources[i].destroy();\n    }\n    this.resources.length = 0;\n  }\n\n  protected register(resources: Resource[]): void {\n    for (let i = 0; i < resources.length; ++i) {\n      this.resources.push(resources[i]);\n    }\n  }\n}\n","import { Device as DeviceImpl } from 'mugl/assembly';\nimport { Device } from '../src/interop/mugl';\nimport { ExampleApplication } from '../src/common';\nimport { Apps } from '../src/apps';\n\nlet activeApp: ExampleApplication | null = null;\n\nexport function init(id: u32, deviceId: f64, useWebGPU: boolean): void {\n  if (!deviceId) {\n    return;\n  }\n  // @ts-expect-error: valid type cast\n  const device = new DeviceImpl(deviceId) as Device;\n  const nextApp = Apps[id].factory(device, useWebGPU);\n  nextApp.init();\n  activeApp = nextApp;\n}\n\nexport function render(delta: f32): boolean {\n  const app = activeApp;\n  if (app) {\n    return app.render(delta);\n  }\n  return false;\n}\n\nexport function resize(width: u32, height: u32): void {\n  const app = activeApp;\n  if (app) {\n    app.resize(width, height);\n  }\n}\n\nexport function destroy(): void {\n  const app = activeApp;\n  if (app) {\n    app.destroy();\n  }\n}\n","import {\n  Color, Extent3D, Float, ImageSource, Origin2D, Origin3D, UInt,\n} from './primitive';\nimport {\n  AddressMode, BindingType, BlendFactor, BlendOperation, BufferUsage, ColorWrite, CompareFunction, CullMode,\n  FilterMode, FrontFace, IndexFormat, PrimitiveTopology, SamplerBindingType, ShaderStage, StencilOperation,\n  TextureDimension, TextureFormat, TextureSampleType, TextureUsage, VertexFormat, VertexStepMode\n} from './type';\nimport { BindGroupLayout, Buffer, Sampler, Shader, Texture } from './resource';\n\n/**\n * Descriptor of a Buffer.\n * @see https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/bindBuffer\n * @see https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/bufferData\n * @see https://www.w3.org/TR/webgpu/#GPUBufferDescriptor\n */\nexport class BufferDescriptor {\n  /** Buffer size in bytes */\n  size: UInt = 0;\n\n  /** Buffer usage */\n  usage: BufferUsage = BufferUsage.Vertex;\n}\n\n/**\n * Descriptor of a Texture.\n * @see https://www.w3.org/TR/webgpu/#texture-creation\n */\nexport class TextureDescriptor {\n  /** Size of texture. Defaults to [1, 1, 1]. */\n  size: Extent3D = [1, 1, 1];\n\n  /** The number of mipmap levels. Defaults to 1. */\n  mipLevelCount: UInt = 1;\n\n  /** The number of samples for MSAA render targets. Defaults to 1. */\n  sampleCount: UInt = 1;\n\n  /** Textue dimension. Defaults to {@link TextureDimension.D2}. */\n  dimension: TextureDimension = TextureDimension.D2;\n\n  /** Format of the texture. Defaults to {@link TextureFormat.RGBA8}. */\n  format: TextureFormat = TextureFormat.RGBA8;\n\n  /** Specifies the usage of the texture. Defaults to {@link TextureUsage.TextureBinding}. */\n  usage: TextureUsage = TextureUsage.TextureBinding;\n}\n\n/**\n* The texture view for render pass attachment.\n* @see https://www.w3.org/TR/webgpu/#texture-view-creation\n*/\nexport class TextureView {\n  /** The texture to bind */\n  texture!: Texture;\n\n  /** Rendering mip level. Defaults to 0 */\n  mipLevel: UInt = 0;\n\n  /** Rendering texture slice. Defaults to 0 */\n  slice: UInt = 0;\n}\n\n/**\n* Defines the texture with origin offset for a texture write operation.\n* @see https://www.w3.org/TR/webgpu/#dictdef-gpuimagecopytexture\n*/\nexport class ImageCopyTexture {\n  /** The texture to write to. */\n  texture!: Texture;\n\n  /** The texture mip level to write to. Defaults to 0 */\n  mipLevel: UInt = 0;\n\n  /** The origin offset of the texture for a write operation. Defaults to [0, 0, 0].  */\n  origin: Origin3D = [0, 0, 0];\n}\n\n/**\n* Defines the source image with origin offset to be copied into a texture.\n* @see https://www.w3.org/TR/webgpu/#dictdef-gpuimagecopyexternalimage\n*/\nexport class ImageCopyExternalImage {\n  /** The source image. */\n  src!: ImageSource;\n\n  /** The origin offset of the image. Defaults to [0, 0].  */\n  origin: Origin2D = [0, 0];\n}\n\n/**\n* Defines the layout of a texture image buffer data for a texture write.\n* @see https://www.w3.org/TR/webgpu/#dictdef-gpuimagedatalayout\n*/\nexport class ImageDataLayout {\n  /** The data offset in bytes. */\n  offset: UInt = 0;\n\n  /** The stride in bytes between the beginning of each block row and the subsequent block row. */\n  bytesPerRow: UInt = 0;\n\n  /**\n   * Number of block rows per single image slice of the texture.\n   * rowsPerImage × pixelsPerRow is the stride between image slices. Required only for depth > 1. Defaults to 0.\n   */\n  rowsPerImage: UInt = 0;\n}\n\n/**\n * Descriptor of a texture sampler.\n * @see https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/texParameter\n * @see https://www.w3.org/TR/webgpu/#sampler-creation\n */\nexport class SamplerDescriptor {\n  /** Texture address mode for texture width coordinates. Defaults to {@link AddressMode.ClampToEdge} */\n  addressModeU: AddressMode = AddressMode.ClampToEdge;\n\n  /** Texture address mode for texture height coordinates. Defaults to {@link AddressMode.ClampToEdge} */\n  addressModeV: AddressMode = AddressMode.ClampToEdge;\n\n  /** Texture address mode for texture depth coordinates. Defaults to {@link AddressMode.ClampToEdge} */\n  addressModeW: AddressMode = AddressMode.ClampToEdge;\n\n  /** Texture filter mode for magnification. Defaults to {@link FilterMode.Nearest} */\n  magFilter: FilterMode = FilterMode.Nearest;\n\n  /** Texture filter mode for minimifaction. Defaults to {@link FilterMode.Nearest} */\n  minFilter: FilterMode = FilterMode.Nearest;\n\n  /** Texture filter mode for sampling between two mipmap levels. Defaults to {@link FilterMode.Nearest} */\n  mipmapFilter: FilterMode = FilterMode.Nearest;\n\n  /** Minimum levels of detail. Defaults to 0. */\n  lodMinClamp: Float = 0;\n\n  /** Maximum levels of detail. Defaults to 32. */\n  lodMaxClamp: Float = 32;\n\n  /** Specifies the behavior of a comparison sampler. Defaults to null. */\n  compare: CompareFunction = 0 as CompareFunction;\n\n  /** Max anisotropy level. Defaults to 1. Requires EXT_texture_filter_anisotropic extension. */\n  maxAnisotropy: UInt = 1;\n}\n\n/**\n * Descriptor of a shader.\n * @see https://www.w3.org/TR/webgpu/#shader-module-creation\n */\nexport class ShaderDescriptor {\n  /** The shader source code. */\n  code: string = '';\n\n  /** The stage of the shader. */\n  usage: ShaderStage = ShaderStage.Vertex;\n}\n\n/**\n * Descriptor of render pipeline states.\n * @see https://www.w3.org/TR/webgpu/#render-pipeline-creation\n */\nexport class RenderPipelineState {\n  /** The color target states. Defaults to null, which disables blending. */\n  targets: ColorTargetStates | null = null;\n\n  /** The primitive states. Defaults to empty. */\n  primitive: PrimitiveState = {} as PrimitiveState;\n\n  /** The depth stencil states. Defaults to null, which disables depth/stencil test. */\n  depthStencil: DepthStencilState | null = null;\n\n  /** The multisample states. Defaults to empty. */\n  multisample: MultisampleState = {} as MultisampleState;\n}\n\n/**\n * Descriptor of a GPU render pipeline resource.\n * @see https://www.w3.org/TR/webgpu/#render-pipeline-creation\n */\nexport class RenderPipelineDescriptor extends RenderPipelineState {\n  /** The vertex shader. */\n  vertex!: Shader;\n\n  /** The fragment shader. */\n  fragment!: Shader;\n\n  /** The entry point function name of vertex shader. Defaults to \"vs_main\". */\n  vertexEntryPoint: string = 'vs_main';\n\n  /** The entry point function name of fragment shader. Defaults to \"fs_main\". */\n  fragmentEntryPoint: string = 'fs_main';\n\n  /** The vertex buffer layouts. */\n  buffers: VertexBufferLayout[] = [];\n\n  /** The bind group layouts. Defaults to empty. */\n  bindGroups: BindGroupLayout[] = [];\n}\n\n/**\n * Descriptor of render pipeline mutlisample state.\n * @see https://www.w3.org/TR/webgpu/#multisample-state\n */\nexport class MultisampleState {\n  /** The number of samples for MSAA render targets. Defaults to 1. */\n  sampleCount: UInt = 1;\n\n  /** Enables alpha to coverage mode. Defaults to false. */\n  alphaToCoverage: boolean = false;\n}\n\n/**\n * Descriptor of the primitive state of a render pipeline.\n * @see https://www.w3.org/TR/webgpu/#dictdef-gpuprimitivestate\n */\nexport class PrimitiveState {\n  /** The primitive topology. Defaults to {@link PrimitiveTopology.Triangles} */\n  topology: PrimitiveTopology = PrimitiveTopology.Triangles;\n\n  /** The index format. Defaults to {@link IndexFormat.UInt16} */\n  indexFormat: IndexFormat = IndexFormat.UInt16;\n\n  /** The front face. Default to {@link FrontFace.CCW} */\n  frontFace: FrontFace = FrontFace.CCW;\n\n  /** The face culling mode. Default to {@link CullMode.None} */\n  cullMode: CullMode = CullMode.None;\n}\n\n/**\n * Descriptor of vertex buffer layout.\n * @see https://www.w3.org/TR/webgpu/#dictdef-gpuvertexbufferlayout\n */\nexport class VertexBufferLayout {\n  /** The attribute descriptors */\n  attributes: VertexAttribute[] = [];\n\n  /** Stride in bytes. */\n  stride: UInt = 0;\n\n  /** Specify if this buffer's data is instanced. Defaults to {@link VertexStepMode.Vertex}. */\n  stepMode: VertexStepMode = VertexStepMode.Vertex;\n}\n\n/**\n * Descriptor of vertex buffer attribute formats.\n */\nexport class VertexBufferFormats {\n  /** The vertex attribute format. */\n  attributes: VertexFormat[] = [];\n\n  /** Specify if this buffer's data is instanced. Defaults to false. */\n  instanced: bool = false;\n}\n\n/**\n * Descriptor of vertex attributes.\n * @see https://www.w3.org/TR/webgpu/#dictdef-gpuvertexbufferlayout\n */\nexport class VertexAttribute {\n  /** Vertex format */\n  format: VertexFormat = VertexFormat.F32x3;\n\n  /** Offset in buffer in bytes. */\n  offset: UInt = 0;\n\n  /** Shader location to bind to. */\n  shaderLocation: UInt = 0;\n}\n\n/**\n * Descriptor of the depth stencil state.\n * @see https://www.w3.org/TR/webgpu/#depth-stencil-state\n */\nexport class DepthStencilState {\n  /** The depth-stencil format. Defaults to {@link TextureFormat.Depth16} */\n  format: TextureFormat = TextureFormat.Depth16;\n\n  /** Depth-writes enabled? Defaults to false */\n  depthWrite: boolean = false;\n\n  /** Depth-compare function. Defaults to {@link CompareFunction.Always} */\n  depthCompare: CompareFunction = CompareFunction.Always;\n\n  /** Stencil front face state. */\n  stencilFront: StencilFaceState = {} as StencilFaceState;\n\n  /** Stencil back face state. */\n  stencilBack: StencilFaceState = {} as StencilFaceState;\n\n  /** Stencil read mask. Defaults to 0xFFFFFFFF */\n  stencilReadMask: UInt = 0xFFFFFFFF;\n\n  /** Stencil write mask. Defaults to 0xFFFFFFFF */\n  stencilWriteMask: UInt = 0xFFFFFFFF;\n\n  /** The depth bias aka polygonOffsetUnits. Defaults to 0. */\n  depthBias: Float = 0;\n\n  /** The depth bias slope scale aka polygonOffsetFactor. Defaults to 0. */\n  depthBiasSlopeScale: Float = 0;\n\n  /** The depth bias clamp value. Defaults to 0. */\n  depthBiasClamp: Float = 0;\n}\n\n/**\n * Descriptor of the stencil face state.\n * @see https://www.w3.org/TR/webgpu/#dictdef-gpudepthstencilstate\n */\nexport class StencilFaceState {\n  /** Stencil compare function. Defaults to {@link CompareFunction.Always} */\n  compare: CompareFunction = CompareFunction.Always;\n\n  /** Stencil fail operation. Defaults to {@link StencilOperation.Keep} */\n  failOp: StencilOperation = StencilOperation.Keep;\n\n  /** Stencil depth fail operation. Defaults to {@link StencilOperation.Keep} */\n  depthFailOp: StencilOperation = StencilOperation.Keep;\n\n  /** Stencil pass operation. Defaults to {@link StencilOperation.Keep} */\n  passOp: StencilOperation = StencilOperation.Keep;\n}\n\n/**\n * Descriptor of the color target states.\n * @see https://www.w3.org/TR/webgpu/#dictdef-gpucolortargetstate\n */\nexport class ColorTargetStates {\n  /** The render targets for offscreen pass. Defaults to null. */\n  targets: ColorTargetState[] | null = null;\n\n  /** Color-channels to write. Defaults to {@link ColorWrite.All} */\n  writeMask: ColorWrite = ColorWrite.All;\n\n  /** Blend component for RGB color. */\n  blendColor: BlendComponent = {} as BlendComponent;\n\n  /** Blend component for RGB color. */\n  blendAlpha: BlendComponent = {} as BlendComponent;\n}\n\n/**\n * Descriptor of the color states of a target.\n * @see https://www.w3.org/TR/webgpu/#dictdef-gpucolortargetstate\n */\nexport class ColorTargetState {\n  /** The texture format for this render target. */\n  format: TextureFormat = TextureFormat.RGBA8;\n\n  /** Color-channels to write. Defaults to {@link ColorWrite.All} */\n  writeMask: ColorWrite = ColorWrite.All;\n\n  /** Blend component for RGB color. */\n  blendColor: BlendComponent = {} as BlendComponent;\n\n  /** Blend component for RGB color. */\n  blendAlpha: BlendComponent = {} as BlendComponent;\n}\n\n/**\n * Descriptor of the blend component state of a color target.\n * @see https://www.w3.org/TR/webgpu/#dictdef-gpublendcomponent\n */\nexport class BlendComponent {\n  /** Blend operation. Defaults to {@link BlendOperation.Add} */\n  operation: BlendOperation = BlendOperation.Add;\n\n  /** Blend source factor. Defaults to {@link BlendFactor.One} */\n  srcFactor: BlendFactor = BlendFactor.One;\n\n  /** Blend destination factor. Defaults to {@link BlendFactor.Zero} */\n  dstFactor: BlendFactor = BlendFactor.Zero;\n}\n\n/**\n * Descriptor of a default Render Pass.\n * @see https://www.w3.org/TR/webgpu/#dictdef-gpurenderpassdescriptor\n */\nexport class DefaultRenderPassDescriptor {\n  /**\n   * The color load operation. Only applicale to a default pass. Defaults to null, which does not clear the buffers.\n   * If a color is specified, it represents the clear color.\n   */\n  clearColor: Color | null = null;\n\n  /**\n   * The depth load operation. Defaults to NaN, which does not clear the buffer.\n   * If a number is specified, it represents the clear value.\n   */\n  clearDepth: Float = NaN;\n\n  /**\n   * The stencil load operation. Defaults to NaN, which does not clear the buffer.\n   * If a number is specified, it represents the clear value.\n   */\n  clearStencil: Float = NaN;\n}\n\n/**\n * Descriptor of a Render Pass.\n * @see https://www.w3.org/TR/webgpu/#dictdef-gpurenderpassdescriptor\n */\nexport class RenderPassDescriptor extends DefaultRenderPassDescriptor {\n  /** List of color attachments. If null or empty, defaults to render to screen. */\n  colors: ColorAttachment[] | null = null;\n\n  /** The depth/stencil attachment. Defaults to null. */\n  depthStencil: TextureView | null = null;\n}\n\n/**\n * Descriptor of a color attachment in a render pass.\n * @see https://www.w3.org/TR/webgpu/#dictdef-gpurenderpassdescriptor\n */\nexport class ColorAttachment {\n  /** The color attachment. */\n  view!: TextureView;\n\n  /**\n   * The color load operation for this attachment. Defaults to null, which does not clear the buffers.\n   * If a color is specified, it represents the clear color.\n   */\n  clear: Color | null = null;\n}\n\n/**\n * Descriptor of a bind group layout object.\n */\nexport class BindGroupLayoutDescriptor {\n  /** The layouts of entries of a bind group. */\n  entries: BindGroupLayoutEntry[] = [];\n}\n\n/**\n * Descriptor of a bind group layout entry.\n */\nexport class BindGroupLayoutEntry {\n  /** Bind group entry name. */\n  label: string = '';\n\n  /** The type of binding. */\n  type: BindingType = BindingType.Buffer;\n\n  /** Binding location. Defaults to the position of the entry. */\n  binding: UInt = 0;\n\n  /** The stages that this resource is visible. Defaults to {@link ShaderStage.Vertex} | {@link ShaderStage.Fragment} */\n  visibility: ShaderStage = ShaderStage.Vertex | ShaderStage.Fragment;\n\n  /** Whether buffer has dynamic offset. Defaults to false. */\n  bufferDynamicOffset: boolean = false;\n\n  /** Type of sampler. Not used currently */\n  samplerType: SamplerBindingType = SamplerBindingType.Filtering;\n\n  /** Type of texture sample. Not used currently */\n  textureSampleType: TextureSampleType = TextureSampleType.Float;\n\n  /** Dimension of texture. Defaults to {@link TextureDimension.D2}. */\n  textureDimension: TextureDimension = TextureDimension.D2;\n\n  /** Whether texture is multisampled. Defaults to false. */\n  textureMultisampled: boolean = false;\n}\n\n/**\n * Descriptor of a bind group object.\n */\nexport class BindGroupDescriptor {\n  /** Layout of the bind group */\n  layout!: BindGroupLayout;\n\n  /** The entries of a bind group. */\n  entries: BindGroupEntry[] = [];\n}\n\n/**\n* A resource binding.\n* @see https://www.w3.org/TR/webgpu/#bind-group-creation\n* @see https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/uniform\n* @see https://developer.mozilla.org/en-US/docs/Web/API/WebGL2RenderingContext/bindBufferRange\n*/\nexport class BindGroupEntry {\n  /** Uniform binding location. Defaults to the position of the entry. */\n  binding: UInt = 0;\n\n  /** The texture to bind */\n  texture: Texture | null = null;\n\n  /** The texture sampler to bind */\n  sampler: Sampler | null = null;\n\n  /** The buffer to bind */\n  buffer: Buffer | null = null;\n\n  /** The starting offset of the buffer. Defaults to 0 */\n  bufferOffset: UInt = 0;\n\n  /**\n   * The byte size of data to read from the buffer.\n   * Defaults to the range starting at offset and ending at the end of the buffer.\n   */\n  bufferSize: UInt = 0;\n}\n","\nimport {\n  beginRenderPass, copyBuffer, copyExternalImageToTexture, copyTexture, copyTextureToBuffer, createTexture, draw,\n  drawIndexed, flush, getFeatures, isDeviceLost, readBuffer, resetDevice, setBindGroup, setBlendConst, setIndex,\n  setRenderPipeline, setScissorRect, setStencilRef, setVertex, setViewport, submitRenderPass, writeBuffer, writeTexture\n} from '../mugl';\nimport {\n  BufferDescriptor, TextureDescriptor, SamplerDescriptor, ShaderDescriptor, BindGroupLayoutDescriptor,\n  BindGroupDescriptor, RenderPipelineDescriptor, RenderPassDescriptor, ImageCopyTexture, ImageDataLayout,\n  ImageCopyExternalImage\n} from './descriptor';\nimport { GPU } from './gpu';\nimport { Color, Extent2D, Extent3D, Float, Future, UInt, UIntArray } from './primitive';\nimport {\n  Buffer, BindGroupLayout, BindGroup, Device, RenderPipeline, RenderPass, Sampler, Shader, Texture,\n} from './resource';\n\n/**\n * Base implementation of the GPU interface.\n */\nexport class BaseGPU implements GPU {\n  public flush(device: Device): void {\n    flush(device.id);\n  }\n\n  public resetDevice(device: Device): void {\n    resetDevice(device.id);\n  }\n\n  public isDeviceLost(device: Device): boolean {\n    return isDeviceLost(device.id);\n  }\n\n  public getDeviceFeatures(device: Device): UInt {\n    return getFeatures(device.id);\n  }\n\n  public createBuffer(device: Device, desc: BufferDescriptor): Buffer {\n    return new Buffer(device, desc);\n  }\n\n  public createTexture(device: Device, desc: TextureDescriptor): Texture {\n    return new Texture(createTexture(\n      device.id,\n      desc.size[0], desc.size[1], desc.size[2],\n      desc.mipLevelCount,\n      desc.sampleCount,\n      desc.dimension,\n      desc.format,\n      desc.usage\n    ));\n  }\n\n  public createSampler(device: Device, desc: SamplerDescriptor): Sampler {\n    return new Sampler(device, desc);\n  }\n\n  public createShader(device: Device, desc: ShaderDescriptor): Shader {\n    return new Shader(device, desc);\n  }\n\n  public createBindGroupLayout(device: Device, desc: BindGroupLayoutDescriptor): BindGroupLayout {\n    return new BindGroupLayout(device, desc);\n  }\n\n  public createBindGroup(device: Device, desc: BindGroupDescriptor): BindGroup {\n    return new BindGroup(device, desc);\n  }\n\n  public createRenderPipeline(device: Device, desc: RenderPipelineDescriptor): RenderPipeline {\n    return new RenderPipeline(device, desc);\n  }\n\n  public createRenderPass(device: Device, desc: RenderPassDescriptor): RenderPass {\n    return new RenderPass(device, desc);\n  }\n\n  public readBuffer(device: Device, buffer: Buffer, out: Uint8Array, offset: UInt = 0): Future {\n    return new Future(\n      readBuffer(device.id, buffer.id, offset, changetype<usize>(out.buffer) + out.byteOffset, out.byteLength)\n    );\n  }\n\n  public writeBuffer(device: Device, buffer: Buffer, data: ArrayBufferView, offset: UInt = 0): void {\n    writeBuffer(device.id, buffer.id, changetype<usize>(data.buffer) + data.byteOffset, data.byteLength, offset);\n  }\n\n  public copyBuffer(device: Device, src: Buffer, dst: Buffer, size: UInt = 0, srcOffset: UInt = 0, dstOffset: UInt = 0): void {\n    copyBuffer(device.id, src.id, dst.id, size, srcOffset, dstOffset);\n  }\n\n  // TODO: set default size instead of 0!\n  public writeTexture(device: Device, texture: ImageCopyTexture, data: ArrayBufferView, layout: ImageDataLayout, size: Extent3D = [0, 0, 0]): void {\n    writeTexture(\n      device.id,\n      texture.texture.id, texture.mipLevel, texture.origin[0], texture.origin[1], texture.origin[2],\n      changetype<usize>(data.buffer) + data.byteOffset, data.byteLength,\n      layout.offset, layout.bytesPerRow, layout.rowsPerImage,\n      size[0], size[1], size[2]\n    );\n  }\n\n  public copyExternalImageToTexture(\n    device: Device, src: ImageCopyExternalImage, dst: ImageCopyTexture, size: Extent2D = [src.src.width - src.origin[0], src.src.height - src.origin[1]]\n  ): void {\n    copyExternalImageToTexture(\n      device.id,\n      src.src.id, src.origin[0], src.origin[1],\n      dst.texture.id, dst.mipLevel, dst.origin[0], dst.origin[1], dst.origin[2],\n      size[0], size[1]\n    );\n  }\n\n  // TODO: set default size instead of 0!\n  public copyTexture(device: Device, src: ImageCopyTexture, dst: ImageCopyTexture, size: Extent3D = [0, 0, 0]): void {\n    copyTexture(\n      device.id,\n      src.texture.id, src.mipLevel, src.origin[0], src.origin[1], src.origin[2],\n      dst.texture.id, dst.mipLevel, dst.origin[0], dst.origin[1], dst.origin[2],\n      size[0], size[1], size[2]\n    );\n  }\n\n  // TODO: set default size instead of 0!\n  public copyTextureToBuffer(device: Device, src: ImageCopyTexture, dst: Buffer, layout: ImageDataLayout, size: Extent3D = [0, 0, 0]): void {\n    copyTextureToBuffer(\n      device.id,\n      src.texture.id, src.mipLevel, src.origin[0], src.origin[1], src.origin[2],\n      dst.id,\n      layout.offset, layout.bytesPerRow, layout.rowsPerImage,\n      size[0], size[1], size[2]\n    );\n  }\n\n  public beginRenderPass(device: Device, pass: RenderPass | null = null): void {\n    beginRenderPass(device.id, pass ? pass.id : 0);\n  }\n\n  public submitRenderPass(device: Device): void {\n    submitRenderPass(device.id);\n  }\n\n  public setRenderPipeline(device: Device, pipeline: RenderPipeline): void {\n    setRenderPipeline(device.id, pipeline.id);\n  }\n\n  public setIndex(device: Device, buffer: Buffer): void {\n    setIndex(device.id, buffer.id);\n  }\n\n  public setVertex(device: Device, slot: UInt, buffer: Buffer, offset: UInt = 0): void {\n    setVertex(device.id, slot, buffer.id, offset);\n  }\n\n  public setBindGroup(device: Device, slot: UInt, bindGroup: BindGroup, offsets: UIntArray = []): void {\n    setBindGroup(device.id, slot, bindGroup.id, changetype<usize>(offsets), offsets.length);\n  }\n\n  public draw(device: Device, vertexCount: UInt, instanceCount: UInt = 1, firstVertex: UInt = 0, firstInstance: UInt = 0): void {\n    draw(device.id, vertexCount, instanceCount, firstVertex, firstInstance);\n  }\n  public drawIndexed(device: Device, indexCount: UInt, instanceCount: UInt = 1, firstIndex: UInt = 0, firstInstance: UInt = 0): void {\n    drawIndexed(device.id, indexCount, instanceCount, firstIndex, firstInstance);\n  }\n  public setViewport(device: Device, x: UInt, y: UInt, width: UInt, height: UInt, minDepth: Float = 0, maxDepth: Float = 1): void {\n    setViewport(device.id, x, y, width, height, minDepth, maxDepth);\n  }\n  public setScissorRect(device: Device, x: UInt, y: UInt, width: UInt, height: UInt): void {\n    setScissorRect(device.id, x, y, width, height);\n  }\n  public setBlendConst(device: Device, color: Color): void {\n    setBlendConst(device.id, color[0], color[1], color[2], color[3]);\n  }\n  public setStencilRef(device: Device, ref: UInt): void {\n    setStencilRef(device.id, ref);\n  }\n}\n","import * as GLenum from './gl-const';\nimport { VertexAttribute, VertexBufferFormats, VertexBufferLayout } from './descriptor';\nimport { UInt } from './primitive';\nimport { IndexFormat, TextureDimension, TextureFormat, VertexFormat, VertexStepMode } from './type';\n\n/**\n * Checks if given texture type is a 3D or 2D array texture.\n * @internal\n * @param dimension texture dimension\n * @return whether the texture type is 3D\n */\nexport function is3DTexture(dimension: TextureDimension): boolean {\n  return dimension === GLenum.TEXTURE_3D || dimension === GLenum.TEXTURE_2D_ARRAY;\n}\n\n/**\n * Returns the byte size of a index format.\n * @internal\n * @param format index format\n * @returns byte size of the format\n */\nexport function indexByteSize(format: IndexFormat): UInt {\n  return format === GLenum.UNSIGNED_SHORT ? 2 : 4;\n}\n\n/**\n * Returns the byte size of a vertex format.\n * @internal\n * @param format vertex format\n * @returns byte size\n */\nexport function vertexByteSize(format: VertexFormat): UInt {\n  return ((format >> 4) & 0xF) * vertexSize(format);\n}\n\n/**\n * Returns the number of components of a vertex format.\n * @internal\n * @param format vertex format\n * @returns number of components\n */\n export function vertexSize(format: VertexFormat): UInt {\n  return format & 0xF;\n}\n\n/**\n * Returns the data type of a vertex format.\n * @internal\n * @param format vertex format\n * @returns GL data type\n */\nexport function vertexType(format: VertexFormat): UInt {\n  switch ((format >> 4) & 0x1FF) {\n    case 0x024:\n      return GLenum.FLOAT;\n    case 0x022:\n      return GLenum.HALF_FLOAT;\n    case 0x112:\n      return GLenum.SHORT;\n    case 0x111:\n      return GLenum.BYTE;\n    case 0x012:\n      return GLenum.UNSIGNED_SHORT;\n    case 0x011:\n      return GLenum.UNSIGNED_BYTE;\n  }\n\n  return GLenum.NONE;\n}\n\n/**\n * Returns if a vertex format is normalized.\n * @internal\n * @param format vertex format\n * @returns number of components\n */\nexport function vertexNormalized(format: VertexFormat): boolean {\n  return !!(format >> 13);\n}\n\n/**\n * Auto-calculates the offsets, strides, shaderLocation for given attribute formats.\n * @param buffers the buffer layouts\n * @return the calculated vertex buffer layout \n */\nexport function vertexBufferLayouts(buffers: VertexBufferFormats[]): VertexBufferLayout[] {\n  let shaderLocation = 0;\n  const result: VertexBufferLayout[] = [];\n  for (let i = 0; i < buffers.length; ++i) {\n    const attributes: VertexAttribute[] = [];\n    let stride = 0;\n    for (let j = 0; j < buffers[i].attributes.length; ++j) {\n      const format = buffers[i].attributes[j];\n      attributes.push({\n        format,\n        offset: stride,\n        shaderLocation,\n      });\n      stride += vertexByteSize(format);\n      ++shaderLocation;\n    }\n    result.push({\n      attributes,\n      stride,\n      stepMode: buffers[i].instanced ? VertexStepMode.Instance : VertexStepMode.Vertex,\n    });\n  }\n\n  return result;\n}\n\n/**\n * Checks if given texture format is a depth/stencil format.\n * @internal\n * @param format texture format\n * @returns whether the texture format is a depth/stencil format\n */\n export function isDepthStencil(format: TextureFormat): boolean {\n  switch (format) {\n    case GLenum.DEPTH_COMPONENT16:\n    case GLenum.DEPTH_COMPONENT24:\n    case GLenum.DEPTH24_STENCIL8:\n    case GLenum.DEPTH_COMPONENT32F:\n    case GLenum.DEPTH32F_STENCIL8:\n      return true;\n  }\n  return false;\n}\n\n/**\n * Checks if given texture format has stencil component.\n * @internal\n * @param format texture format\n * @returns whether the texture format has stencil component\n */\nexport function hasStencil(format: TextureFormat): boolean {\n  switch (format) {\n    case GLenum.DEPTH24_STENCIL8:\n    case GLenum.DEPTH32F_STENCIL8:\n      return true;\n  }\n  return false;\n}\n","import { getImageById, ImageSource } from 'mugl/assembly';\nimport { APP_CONTEXT_ID } from '../../common/config';\n\nexport * from 'mugl/assembly';\n\nexport function getImage(id: string): ImageSource {\n  return getImageById(APP_CONTEXT_ID, id);\n}\n","import { getImageById as _getImageById, getCanvasById as _getCanvasById, ContextId } from '../mugl';\nimport { Canvas, ImageSource } from './resource';\n\n/**\n * Gets an image handle by string ID.\n * @param context unique context ID for the app\n * @param id the image ID\n * @returns image\n */\nexport function getImageById(context: ContextId, id: string): ImageSource {\n  const sBuf = String.UTF8.encode(id);\n  return new ImageSource(_getImageById(context, changetype<usize>(sBuf), sBuf.byteLength));\n}\n\n/**\n * Get canvas by ID.\n * @param context unique context ID for the app\n * @param id canvas ID\n * @returns canvas\n */\nexport function getCanvasById(context: ContextId, id: string): Canvas {\n  const sBuf = String.UTF8.encode(id);\n  return new Canvas(_getCanvasById(context, changetype<usize>(sBuf), sBuf.byteLength));\n}\n","import { CanvasId, deleteImage, getCanvasWidth, getCanvasHeight, getImageWidth, getImageHeight, ImageSourceId, deleteCanvas } from '../mugl';\nimport { Resource, UInt } from '../gpu';\n\n/**\n* A canvas element from which a WebGL2RenderingContext can be retrieved.\n*/\nexport class Canvas extends Resource {\n  public constructor(\n    public readonly id: CanvasId\n  ) {\n    super();\n  }\n\n  /**\n   * @returns the canvas width.\n   */\n  get width(): UInt {\n    return getCanvasWidth(this.id);\n  }\n\n  /**\n   * @returns the canvas height.\n   */\n  get height(): UInt {\n    return getCanvasHeight(this.id);\n  }\n\n  public destroy(): void {\n    deleteCanvas(this.id);\n  }\n}\n\n/**\n * An image source element\n */\nexport class ImageSource extends Resource {\n  public constructor(\n    public readonly id: ImageSourceId\n  ) {\n    super();\n  }\n\n  /**\n   * @returns the image width.\n   */\n  get width(): UInt {\n    return getImageWidth(this.id);\n  }\n\n  /**\n   * @returns the image height.\n   */\n  get height(): UInt {\n    return getImageHeight(this.id);\n  }\n\n  public destroy(): void {\n    deleteImage(this.id);\n  }\n}\n","type auto = i32;\n\n@final export abstract class Function<T> {\n  private _index: u32;\n  private _env: usize;\n\n  // @ts-ignore: this on getter\n  get index(this: T): u32 {\n    return load<u32>(changetype<usize>(this), offsetof<Function<T>>(\"_index\"));\n  }\n\n  // @ts-ignore: this on getter\n  get name(this: T): string {\n    return \"\";\n  }\n\n  // @ts-ignore: this on getter\n  get length(this: T): i32 {\n    // @ts-ignore: T is function\n    return lengthof<T>();\n  }\n\n  // @ts-ignore: T is function\n  @builtin call(thisArg: thisof<T> | null, ...args: auto[]): returnof<T> {\n    return unreachable();\n  }\n\n  toString(this: T): string {\n    return \"function() { [native code] }\";\n  }\n\n  // RT integration\n\n  @unsafe private __visit(cookie: u32): void {\n    // Env is either `null` (nop) or compiler-generated\n    __visit(this._env, cookie);\n  }\n}\n"]}