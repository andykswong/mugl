/* tslint:disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

/**
 * The root object for a glTF asset.
 */
export type GlTF = GlTF1 & GlTF3;
export type GlTF1 = GlTFProperty & GlTF2;
/**
 * A typed view into a bufferView.  A bufferView contains raw binary data.  An accessor provides a typed view into a bufferView or a subset of a bufferView similar to how WebGL's `vertexAttribPointer()` defines an attribute in a buffer.
 */
export type Accessor = GlTFChildOfRootProperty & Accessor1;
export type GlTFChildOfRootProperty = GlTFProperty & GlTFChildOfRootProperty1;
export type GlTFId = number;
/**
 * Sparse storage of attributes that deviate from their initialization value.
 */
export type AccessorSparse = GlTFProperty & AccessorSparse1;
/**
 * Indices of those attributes that deviate from their initialization value.
 */
export type AccessorSparseIndices = GlTFProperty & AccessorSparseIndices1;
/**
 * Array of size `accessor.sparse.count` times number of components storing the displaced accessor attributes pointed by `accessor.sparse.indices`.
 */
export type AccessorSparseValues = GlTFProperty & AccessorSparseValues1;
/**
 * A keyframe animation.
 */
export type Animation = GlTFChildOfRootProperty & Animation1;
/**
 * Targets an animation's sampler at a node's property.
 */
export type AnimationChannel = GlTFProperty & AnimationChannel1;
/**
 * The index of the node and TRS property that an animation channel targets.
 */
export type AnimationChannelTarget = GlTFProperty & AnimationChannelTarget1;
/**
 * Combines input and output accessors with an interpolation algorithm to define a keyframe graph (but not its target).
 */
export type AnimationSampler = GlTFProperty & AnimationSampler1;
/**
 * Metadata about the glTF asset.
 */
export type Asset = GlTFProperty & Asset1;
/**
 * A buffer points to binary geometry, animation, or skins.
 */
export type Buffer = GlTFChildOfRootProperty & Buffer1;
/**
 * A view into a buffer generally representing a subset of the buffer.
 */
export type BufferView = GlTFChildOfRootProperty & BufferView1;
/**
 * A camera's projection.  A node can reference a camera to apply a transform to place the camera in the scene.
 */
export type Camera = GlTFChildOfRootProperty & Camera1;
/**
 * An orthographic camera containing properties to create an orthographic projection matrix.
 */
export type CameraOrthographic = GlTFProperty & CameraOrthographic1;
/**
 * A perspective camera containing properties to create a perspective projection matrix.
 */
export type CameraPerspective = GlTFProperty & CameraPerspective1;
/**
 * Image data used to create a texture. Image can be referenced by URI or `bufferView` index. `mimeType` is required in the latter case.
 */
export type Image = Image1 & Image3;
export type Image1 = GlTFChildOfRootProperty & Image2;
export type Image3 =
  | {
      [k: string]: unknown;
    }
  | {
      [k: string]: unknown;
    };
export type Image4 = Image1 & Image3;
/**
 * The material appearance of a primitive.
 */
export type Material = GlTFChildOfRootProperty & Material1;
/**
 * A set of parameter values that are used to define the metallic-roughness material model from Physically-Based Rendering (PBR) methodology.
 */
export type MaterialPBRMetallicRoughness = GlTFProperty & MaterialPBRMetallicRoughness1;
/**
 * Reference to a texture.
 */
export type TextureInfo = GlTFProperty & TextureInfo1;
export type MaterialNormalTextureInfo = TextureInfo & MaterialNormalTextureInfo1;
export type MaterialOcclusionTextureInfo = TextureInfo & MaterialOcclusionTextureInfo1;
/**
 * A set of primitives to be rendered.  A node can contain one mesh.  A node's transform places the mesh in the scene.
 */
export type Mesh = GlTFChildOfRootProperty & Mesh1;
/**
 * Geometry to be rendered with the given material.
 */
export type MeshPrimitive = GlTFProperty & MeshPrimitive1;
/**
 * A node in the node hierarchy.  When the node contains `skin`, all `mesh.primitives` must contain `JOINTS_0` and `WEIGHTS_0` attributes.  A node can have either a `matrix` or any combination of `translation`/`rotation`/`scale` (TRS) properties. TRS properties are converted to matrices and postmultiplied in the `T * R * S` order to compose the transformation matrix; first the scale is applied to the vertices, then the rotation, and then the translation. If none are provided, the transform is the identity. When a node is targeted for animation (referenced by an animation.channel.target), only TRS properties may be present; `matrix` will not be present.
 */
export type Node = GlTFChildOfRootProperty & Node1;
/**
 * Texture sampler properties for filtering and wrapping modes.
 */
export type Sampler = GlTFChildOfRootProperty & Sampler1;
/**
 * The root nodes of a scene.
 */
export type Scene = GlTFChildOfRootProperty & Scene1;
/**
 * Joints and matrices defining a skin.
 */
export type Skin = GlTFChildOfRootProperty & Skin1;
/**
 * A texture and its sampler.
 */
export type Texture = GlTFChildOfRootProperty & Texture1;

export interface GlTFProperty {
  extensions?: Extension;
  extras?: Extras;
  [k: string]: unknown;
}
/**
 * Dictionary object with extension-specific objects.
 */
export interface Extension {
  [k: string]: {
    [k: string]: unknown;
  };
}
/**
 * Application-specific data.
 */
export interface Extras {
  [k: string]: unknown;
}
export interface GlTF2 {
  /**
   * Names of glTF extensions used somewhere in this asset.
   */
  extensionsUsed?: [string, ...string[]];
  /**
   * Names of glTF extensions required to properly load this asset.
   */
  extensionsRequired?: [string, ...string[]];
  /**
   * An array of accessors.
   */
  accessors?: [Accessor, ...Accessor[]];
  /**
   * An array of keyframe animations.
   */
  animations?: [Animation, ...Animation[]];
  /**
   * Metadata about the glTF asset.
   */
  asset: Asset;
  /**
   * An array of buffers.
   */
  buffers?: [Buffer, ...Buffer[]];
  /**
   * An array of bufferViews.
   */
  bufferViews?: [BufferView, ...BufferView[]];
  /**
   * An array of cameras.
   */
  cameras?: [Camera, ...Camera[]];
  /**
   * An array of images.
   */
  images?: [Image, ...Image4[]];
  /**
   * An array of materials.
   */
  materials?: [Material, ...Material[]];
  /**
   * An array of meshes.
   */
  meshes?: [Mesh, ...Mesh[]];
  /**
   * An array of nodes.
   */
  nodes?: [Node, ...Node[]];
  /**
   * An array of samplers.
   */
  samplers?: [Sampler, ...Sampler[]];
  /**
   * The index of the default scene.
   */
  scene?: GlTFId;
  /**
   * An array of scenes.
   */
  scenes?: [Scene, ...Scene[]];
  /**
   * An array of skins.
   */
  skins?: [Skin, ...Skin[]];
  /**
   * An array of textures.
   */
  textures?: [Texture, ...Texture[]];
  extensions?: unknown;
  extras?: unknown;
  [k: string]: unknown;
}
export interface GlTFChildOfRootProperty1 {
  /**
   * The user-defined name of this object.
   */
  name?: string;
  [k: string]: unknown;
}
export interface Accessor1 {
  /**
   * The index of the bufferView.
   */
  bufferView?: GlTFId;
  /**
   * The offset relative to the start of the bufferView in bytes.
   */
  byteOffset?: number;
  /**
   * The datatype of components in the attribute.
   */
  componentType: 5120 | 5121 | 5122 | 5123 | 5125 | 5126 | number;
  /**
   * Specifies whether integer data values should be normalized.
   */
  normalized?: boolean;
  /**
   * The number of attributes referenced by this accessor.
   */
  count: number;
  /**
   * Specifies if the attribute is a scalar, vector, or matrix.
   */
  type: "SCALAR" | "VEC2" | "VEC3" | "VEC4" | "MAT2" | "MAT3" | "MAT4" | string;
  /**
   * Maximum value of each component in this attribute.
   */
  max?:
    | [number]
    | [number, number]
    | [number, number, number]
    | [number, number, number, number]
    | [number, number, number, number, number]
    | [number, number, number, number, number, number]
    | [number, number, number, number, number, number, number]
    | [number, number, number, number, number, number, number, number]
    | [number, number, number, number, number, number, number, number, number]
    | [number, number, number, number, number, number, number, number, number, number]
    | [number, number, number, number, number, number, number, number, number, number, number]
    | [number, number, number, number, number, number, number, number, number, number, number, number]
    | [number, number, number, number, number, number, number, number, number, number, number, number, number]
    | [number, number, number, number, number, number, number, number, number, number, number, number, number, number]
    | [
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number
      ]
    | [
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number
      ];
  /**
   * Minimum value of each component in this attribute.
   */
  min?:
    | [number]
    | [number, number]
    | [number, number, number]
    | [number, number, number, number]
    | [number, number, number, number, number]
    | [number, number, number, number, number, number]
    | [number, number, number, number, number, number, number]
    | [number, number, number, number, number, number, number, number]
    | [number, number, number, number, number, number, number, number, number]
    | [number, number, number, number, number, number, number, number, number, number]
    | [number, number, number, number, number, number, number, number, number, number, number]
    | [number, number, number, number, number, number, number, number, number, number, number, number]
    | [number, number, number, number, number, number, number, number, number, number, number, number, number]
    | [number, number, number, number, number, number, number, number, number, number, number, number, number, number]
    | [
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number
      ]
    | [
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number
      ];
  /**
   * Sparse storage of attributes that deviate from their initialization value.
   */
  sparse?: AccessorSparse;
  name?: unknown;
  extensions?: unknown;
  extras?: unknown;
  [k: string]: unknown;
}
export interface AccessorSparse1 {
  /**
   * Number of entries stored in the sparse array.
   */
  count: number;
  /**
   * Index array of size `count` that points to those accessor attributes that deviate from their initialization value. Indices must strictly increase.
   */
  indices: AccessorSparseIndices;
  /**
   * Array of size `count` times number of components, storing the displaced accessor attributes pointed by `indices`. Substituted values must have the same `componentType` and number of components as the base accessor.
   */
  values: AccessorSparseValues;
  extensions?: unknown;
  extras?: unknown;
  [k: string]: unknown;
}
export interface AccessorSparseIndices1 {
  /**
   * The index of the bufferView with sparse indices. Referenced bufferView can't have ARRAY_BUFFER or ELEMENT_ARRAY_BUFFER target.
   */
  bufferView: GlTFId;
  /**
   * The offset relative to the start of the bufferView in bytes. Must be aligned.
   */
  byteOffset?: number;
  /**
   * The indices data type.
   */
  componentType: 5121 | 5123 | 5125 | number;
  extensions?: unknown;
  extras?: unknown;
  [k: string]: unknown;
}
export interface AccessorSparseValues1 {
  /**
   * The index of the bufferView with sparse values. Referenced bufferView can't have ARRAY_BUFFER or ELEMENT_ARRAY_BUFFER target.
   */
  bufferView: GlTFId;
  /**
   * The offset relative to the start of the bufferView in bytes. Must be aligned.
   */
  byteOffset?: number;
  extensions?: unknown;
  extras?: unknown;
  [k: string]: unknown;
}
export interface Animation1 {
  /**
   * An array of channels, each of which targets an animation's sampler at a node's property. Different channels of the same animation can't have equal targets.
   */
  channels: [AnimationChannel, ...AnimationChannel[]];
  /**
   * An array of samplers that combines input and output accessors with an interpolation algorithm to define a keyframe graph (but not its target).
   */
  samplers: [AnimationSampler, ...AnimationSampler[]];
  name?: unknown;
  extensions?: unknown;
  extras?: unknown;
  [k: string]: unknown;
}
export interface AnimationChannel1 {
  /**
   * The index of a sampler in this animation used to compute the value for the target.
   */
  sampler: GlTFId;
  /**
   * The index of the node and TRS property to target.
   */
  target: AnimationChannelTarget;
  extensions?: unknown;
  extras?: unknown;
  [k: string]: unknown;
}
export interface AnimationChannelTarget1 {
  /**
   * The index of the node to target.
   */
  node?: GlTFId;
  /**
   * The name of the node's TRS property to modify, or the "weights" of the Morph Targets it instantiates. For the "translation" property, the values that are provided by the sampler are the translation along the x, y, and z axes. For the "rotation" property, the values are a quaternion in the order (x, y, z, w), where w is the scalar. For the "scale" property, the values are the scaling factors along the x, y, and z axes.
   */
  path: "translation" | "rotation" | "scale" | "weights" | string;
  extensions?: unknown;
  extras?: unknown;
  [k: string]: unknown;
}
export interface AnimationSampler1 {
  /**
   * The index of an accessor containing keyframe input values, e.g., time.
   */
  input: GlTFId;
  /**
   * Interpolation algorithm.
   */
  interpolation?: "LINEAR" | "STEP" | "CUBICSPLINE" | string;
  /**
   * The index of an accessor, containing keyframe output values.
   */
  output: GlTFId;
  extensions?: unknown;
  extras?: unknown;
  [k: string]: unknown;
}
export interface Asset1 {
  /**
   * A copyright message suitable for display to credit the content creator.
   */
  copyright?: string;
  /**
   * Tool that generated this glTF model.  Useful for debugging.
   */
  generator?: string;
  /**
   * The glTF version that this asset targets.
   */
  version: string;
  /**
   * The minimum glTF version that this asset targets.
   */
  minVersion?: string;
  extensions?: unknown;
  extras?: unknown;
  [k: string]: unknown;
}
export interface Buffer1 {
  /**
   * The uri of the buffer.
   */
  uri?: string;
  /**
   * The length of the buffer in bytes.
   */
  byteLength: number;
  name?: unknown;
  extensions?: unknown;
  extras?: unknown;
  [k: string]: unknown;
}
export interface BufferView1 {
  /**
   * The index of the buffer.
   */
  buffer: GlTFId;
  /**
   * The offset into the buffer in bytes.
   */
  byteOffset?: number;
  /**
   * The length of the bufferView in bytes.
   */
  byteLength: number;
  /**
   * The stride, in bytes.
   */
  byteStride?: number;
  /**
   * The target that the GPU buffer should be bound to.
   */
  target?: 34962 | 34963 | number;
  name?: unknown;
  extensions?: unknown;
  extras?: unknown;
  [k: string]: unknown;
}
export interface Camera1 {
  /**
   * An orthographic camera containing properties to create an orthographic projection matrix.
   */
  orthographic?: CameraOrthographic;
  /**
   * A perspective camera containing properties to create a perspective projection matrix.
   */
  perspective?: CameraPerspective;
  /**
   * Specifies if the camera uses a perspective or orthographic projection.
   */
  type: "perspective" | "orthographic" | string;
  name?: unknown;
  extensions?: unknown;
  extras?: unknown;
  [k: string]: unknown;
}
export interface CameraOrthographic1 {
  /**
   * The floating-point horizontal magnification of the view. Must not be zero.
   */
  xmag: number;
  /**
   * The floating-point vertical magnification of the view. Must not be zero.
   */
  ymag: number;
  /**
   * The floating-point distance to the far clipping plane. `zfar` must be greater than `znear`.
   */
  zfar: number;
  /**
   * The floating-point distance to the near clipping plane.
   */
  znear: number;
  extensions?: unknown;
  extras?: unknown;
  [k: string]: unknown;
}
export interface CameraPerspective1 {
  /**
   * The floating-point aspect ratio of the field of view.
   */
  aspectRatio?: number;
  /**
   * The floating-point vertical field of view in radians.
   */
  yfov: number;
  /**
   * The floating-point distance to the far clipping plane.
   */
  zfar?: number;
  /**
   * The floating-point distance to the near clipping plane.
   */
  znear: number;
  extensions?: unknown;
  extras?: unknown;
  [k: string]: unknown;
}
export interface Image2 {
  /**
   * The uri of the image.
   */
  uri?: string;
  /**
   * The image's MIME type. Required if `bufferView` is defined.
   */
  mimeType?: "image/jpeg" | "image/png" | string;
  /**
   * The index of the bufferView that contains the image. Use this instead of the image's uri property.
   */
  bufferView?: GlTFId;
  name?: unknown;
  extensions?: unknown;
  extras?: unknown;
  [k: string]: unknown;
}
export interface Material1 {
  name?: unknown;
  extensions?: unknown;
  extras?: unknown;
  /**
   * A set of parameter values that are used to define the metallic-roughness material model from Physically-Based Rendering (PBR) methodology. When not specified, all the default values of `pbrMetallicRoughness` apply.
   */
  pbrMetallicRoughness?: MaterialPBRMetallicRoughness;
  /**
   * The normal map texture.
   */
  normalTexture?: MaterialNormalTextureInfo;
  /**
   * The occlusion map texture.
   */
  occlusionTexture?: MaterialOcclusionTextureInfo;
  /**
   * The emissive map texture.
   */
  emissiveTexture?: TextureInfo;
  /**
   * The emissive color of the material.
   */
  emissiveFactor?: [number, number, number];
  /**
   * The alpha rendering mode of the material.
   */
  alphaMode?: "OPAQUE" | "MASK" | "BLEND" | string;
  /**
   * The alpha cutoff value of the material.
   */
  alphaCutoff?: number;
  /**
   * Specifies whether the material is double sided.
   */
  doubleSided?: boolean;
  [k: string]: unknown;
}
export interface MaterialPBRMetallicRoughness1 {
  /**
   * The material's base color factor.
   */
  baseColorFactor?: [number, number, number, number];
  /**
   * The base color texture.
   */
  baseColorTexture?: TextureInfo;
  /**
   * The metalness of the material.
   */
  metallicFactor?: number;
  /**
   * The roughness of the material.
   */
  roughnessFactor?: number;
  /**
   * The metallic-roughness texture.
   */
  metallicRoughnessTexture?: TextureInfo;
  extensions?: unknown;
  extras?: unknown;
  [k: string]: unknown;
}
export interface TextureInfo1 {
  /**
   * The index of the texture.
   */
  index: GlTFId;
  /**
   * The set index of texture's TEXCOORD attribute used for texture coordinate mapping.
   */
  texCoord?: number;
  extensions?: unknown;
  extras?: unknown;
  [k: string]: unknown;
}
export interface MaterialNormalTextureInfo1 {
  index?: unknown;
  texCoord?: unknown;
  /**
   * The scalar multiplier applied to each normal vector of the normal texture.
   */
  scale?: number;
  extensions?: unknown;
  extras?: unknown;
  [k: string]: unknown;
}
export interface MaterialOcclusionTextureInfo1 {
  index?: unknown;
  texCoord?: unknown;
  /**
   * A scalar multiplier controlling the amount of occlusion applied.
   */
  strength?: number;
  extensions?: unknown;
  extras?: unknown;
  [k: string]: unknown;
}
export interface Mesh1 {
  /**
   * An array of primitives, each defining geometry to be rendered with a material.
   */
  primitives: [MeshPrimitive, ...MeshPrimitive[]];
  /**
   * Array of weights to be applied to the Morph Targets.
   */
  weights?: [number, ...number[]];
  name?: unknown;
  extensions?: unknown;
  extras?: unknown;
  [k: string]: unknown;
}
export interface MeshPrimitive1 {
  /**
   * A dictionary object, where each key corresponds to mesh attribute semantic and each value is the index of the accessor containing attribute's data.
   */
  attributes: {
    [k: string]: GlTFId;
  };
  /**
   * The index of the accessor that contains the indices.
   */
  indices?: GlTFId;
  /**
   * The index of the material to apply to this primitive when rendering.
   */
  material?: GlTFId;
  /**
   * The type of primitives to render.
   */
  mode?: 0 | 1 | 2 | 3 | 4 | 5 | 6 | number;
  /**
   * An array of Morph Targets, each  Morph Target is a dictionary mapping attributes (only `POSITION`, `NORMAL`, and `TANGENT` supported) to their deviations in the Morph Target.
   */
  targets?: [
    {
      [k: string]: GlTFId;
    },
    ...{
      [k: string]: GlTFId;
    }[]
  ];
  extensions?: unknown;
  extras?: unknown;
  [k: string]: unknown;
}
export interface Node1 {
  /**
   * The index of the camera referenced by this node.
   */
  camera?: GlTFId;
  /**
   * The indices of this node's children.
   */
  children?: [GlTFId, ...GlTFId[]];
  /**
   * The index of the skin referenced by this node.
   */
  skin?: GlTFId;
  /**
   * A floating-point 4x4 transformation matrix stored in column-major order.
   */
  matrix?: [
    number,
    number,
    number,
    number,
    number,
    number,
    number,
    number,
    number,
    number,
    number,
    number,
    number,
    number,
    number,
    number
  ];
  /**
   * The index of the mesh in this node.
   */
  mesh?: GlTFId;
  /**
   * The node's unit quaternion rotation in the order (x, y, z, w), where w is the scalar.
   */
  rotation?: [number, number, number, number];
  /**
   * The node's non-uniform scale, given as the scaling factors along the x, y, and z axes.
   */
  scale?: [number, number, number];
  /**
   * The node's translation along the x, y, and z axes.
   */
  translation?: [number, number, number];
  /**
   * The weights of the instantiated Morph Target. Number of elements must match number of Morph Targets of used mesh.
   */
  weights?: [number, ...number[]];
  name?: unknown;
  extensions?: unknown;
  extras?: unknown;
  [k: string]: unknown;
}
export interface Sampler1 {
  /**
   * Magnification filter.
   */
  magFilter?: 9728 | 9729 | number;
  /**
   * Minification filter.
   */
  minFilter?: 9728 | 9729 | 9984 | 9985 | 9986 | 9987 | number;
  /**
   * s wrapping mode.
   */
  wrapS?: 33071 | 33648 | 10497 | number;
  /**
   * t wrapping mode.
   */
  wrapT?: 33071 | 33648 | 10497 | number;
  name?: unknown;
  extensions?: unknown;
  extras?: unknown;
  [k: string]: unknown;
}
export interface Scene1 {
  /**
   * The indices of each root node.
   */
  nodes?: [GlTFId, ...GlTFId[]];
  name?: unknown;
  extensions?: unknown;
  extras?: unknown;
  [k: string]: unknown;
}
export interface Skin1 {
  /**
   * The index of the accessor containing the floating-point 4x4 inverse-bind matrices.  The default is that each matrix is a 4x4 identity matrix, which implies that inverse-bind matrices were pre-applied.
   */
  inverseBindMatrices?: GlTFId;
  /**
   * The index of the node used as a skeleton root.
   */
  skeleton?: GlTFId;
  /**
   * Indices of skeleton nodes, used as joints in this skin.
   */
  joints: [GlTFId, ...GlTFId[]];
  name?: unknown;
  extensions?: unknown;
  extras?: unknown;
  [k: string]: unknown;
}
export interface Texture1 {
  /**
   * The index of the sampler used by this texture. When undefined, a sampler with repeat wrapping and auto filtering should be used.
   */
  sampler?: GlTFId;
  /**
   * The index of the image used by this texture. When undefined, it is expected that an extension or other mechanism will supply an alternate texture source, otherwise behavior is undefined.
   */
  source?: GlTFId;
  name?: unknown;
  extensions?: unknown;
  extras?: unknown;
  [k: string]: unknown;
}
export interface GlTF3 {
  [k: string]: unknown;
}
