(()=>{var e="undefined"!=typeof Float32Array?Float32Array:Array;function t(){var t=new e(3);return e!=Float32Array&&(t[0]=0,t[1]=0,t[2]=0),t}function n(t,n,r){var i=new e(3);return i[0]=t,i[1]=n,i[2]=r,i}function r(e,t,n){return e[0]=t[0]+n[0],e[1]=t[1]+n[1],e[2]=t[2]+n[2],e}function i(e,t,n){return e[0]=t[0]*n,e[1]=t[1]*n,e[2]=t[2]*n,e}function o(e,t,n){var r=t[0],i=t[1],o=t[2],a=n[3]*r+n[7]*i+n[11]*o+n[15];return a=a||1,e[0]=(n[0]*r+n[4]*i+n[8]*o+n[12])/a,e[1]=(n[1]*r+n[5]*i+n[9]*o+n[13])/a,e[2]=(n[2]*r+n[6]*i+n[10]*o+n[14])/a,e}function a(){var t=new e(16);return e!=Float32Array&&(t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[11]=0,t[12]=0,t[13]=0,t[14]=0),t[0]=1,t[5]=1,t[10]=1,t[15]=1,t}function s(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15],e}function l(e,t){var n=t[0],r=t[1],i=t[2],o=t[3],a=t[4],s=t[5],l=t[6],f=t[7],c=t[8],u=t[9],m=t[10],h=t[11],d=t[12],g=t[13],v=t[14],p=t[15],x=n*s-r*a,b=n*l-i*a,T=n*f-o*a,y=r*l-i*s,w=r*f-o*s,O=i*f-o*l,C=c*g-u*d,E=c*v-m*d,S=c*p-h*d,_=u*v-m*g,N=u*p-h*g,F=m*p-h*v,M=x*F-b*N+T*_+y*S-w*E+O*C;return M?(M=1/M,e[0]=(s*F-l*N+f*_)*M,e[1]=(i*N-r*F-o*_)*M,e[2]=(g*O-v*w+p*y)*M,e[3]=(m*w-u*O-h*y)*M,e[4]=(l*S-a*F-f*E)*M,e[5]=(n*F-i*S+o*E)*M,e[6]=(v*T-d*O-p*b)*M,e[7]=(c*O-m*T+h*b)*M,e[8]=(a*N-s*S+f*C)*M,e[9]=(r*S-n*N-o*C)*M,e[10]=(d*w-g*T+p*x)*M,e[11]=(u*T-c*w-h*x)*M,e[12]=(s*E-a*_-l*C)*M,e[13]=(n*_-r*E+i*C)*M,e[14]=(g*b-d*y-v*x)*M,e[15]=(c*y-u*b+m*x)*M,e):null}function f(e,t,n,r,i){var o,a=1/Math.tan(t/2);return e[0]=a/n,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=a,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=-1,e[12]=0,e[13]=0,e[15]=0,null!=i&&i!==1/0?(o=1/(r-i),e[10]=(i+r)*o,e[14]=2*i*r*o):(e[10]=-1,e[14]=-2*r),e}function c(e,t,n,r){var i=t[0],o=t[1],a=t[2],s=r[0],l=r[1],f=r[2],c=i-n[0],u=o-n[1],m=a-n[2],h=c*c+u*u+m*m;h>0&&(c*=h=1/Math.sqrt(h),u*=h,m*=h);var d=l*m-f*u,g=f*c-s*m,v=s*u-l*c;return(h=d*d+g*g+v*v)>0&&(d*=h=1/Math.sqrt(h),g*=h,v*=h),e[0]=d,e[1]=g,e[2]=v,e[3]=0,e[4]=u*v-m*g,e[5]=m*d-c*v,e[6]=c*g-u*d,e[7]=0,e[8]=c,e[9]=u,e[10]=m,e[11]=0,e[12]=i,e[13]=o,e[14]=a,e[15]=1,e}Math.random,Math.PI,Math.hypot||(Math.hypot=function(){for(var e=0,t=arguments.length;t--;)e+=arguments[t]*arguments[t];return Math.sqrt(e)}),t();var u=function(e,t,n){var r=t[0],i=t[1],o=t[2],a=t[3],s=t[4],l=t[5],f=t[6],c=t[7],u=t[8],m=t[9],h=t[10],d=t[11],g=t[12],v=t[13],p=t[14],x=t[15],b=n[0],T=n[1],y=n[2],w=n[3];return e[0]=b*r+T*s+y*u+w*g,e[1]=b*i+T*l+y*m+w*v,e[2]=b*o+T*f+y*h+w*p,e[3]=b*a+T*c+y*d+w*x,b=n[4],T=n[5],y=n[6],w=n[7],e[4]=b*r+T*s+y*u+w*g,e[5]=b*i+T*l+y*m+w*v,e[6]=b*o+T*f+y*h+w*p,e[7]=b*a+T*c+y*d+w*x,b=n[8],T=n[9],y=n[10],w=n[11],e[8]=b*r+T*s+y*u+w*g,e[9]=b*i+T*l+y*m+w*v,e[10]=b*o+T*f+y*h+w*p,e[11]=b*a+T*c+y*d+w*x,b=n[12],T=n[13],y=n[14],w=n[15],e[12]=b*r+T*s+y*u+w*g,e[13]=b*i+T*l+y*m+w*v,e[14]=b*o+T*f+y*h+w*p,e[15]=b*a+T*c+y*d+w*x,e};const m=5121,h=5123,d=5126,g=6408,v=9729,p=36160,x={Nearest:9728,Linear:v},b={...x,NearestMipmapNearest:9984,NearestMipmapLinear:9986,LinearMipmapNearest:9985,LinearMipmapLinear:9987},T=3553,y=d,w=35676,O=e=>e>>8&255,C="ANGLE_instanced_arrays",E={},S=[];class _{constructor(e,t){this.gl=e,this.type=34962,this.usage=35044,this.size=0,Object.assign(this,t),e.bindBuffer(this.type,this.glb=e.createBuffer()),e.bufferData(this.type,this.size,this.usage)}data(e,t=0){return this.gl.bindBuffer(this.type,this.glb),this.gl.bufferSubData(this.type,t,e),this}destroy(){this.gl.deleteBuffer(this.glb)}}class N{constructor(e,t,n=E){this.gl=e,this.type=3553,this.format=263169,this.wrapU=33071,this.wrapV=33071,this.magFilter=v,this.minFilter=v,Object.assign(this,t,n),this.glt=this.glrb=null;const[r,i]=this.size;this.format<=197381||(e.bindTexture(this.type,this.glt=e.createTexture()),e.texParameteri(this.type,10241,this.minFilter),e.texParameteri(this.type,10240,this.magFilter),e.texParameteri(this.type,10242,this.wrapU),e.texParameteri(this.type,10243,this.wrapV),e.texImage2D(this.type,0,g,r,i,0,g,m,null))}data(e,[t=0,n=0]=S,[r=this.size[0]-t,i=this.size[1]-n]=S){return this.gl.bindTexture(this.type,this.glt),ArrayBuffer.isView(e)?this.gl.texSubImage2D(this.type,0,t,n,r,i,g,m,e):this.gl.texSubImage2D(this.type,0,t,n,g,m,e),this}mipmap(){return this.gl.bindTexture(this.type,this.glt),this.gl.generateMipmap(this.type),this}destroy(){this.gl.deleteTexture(this.glt),this.gl.deleteRenderbuffer(this.glrb)}}class F{constructor(e,t=E){this.gl=e,this.color=[],this.depth=null,this.clearColor=!1,this.clearDepth=!1,this.clearStencil=!1,Object.assign(this,t),this.glfb=null,this.color[0]&&(e.bindFramebuffer(p,this.glfb=e.createFramebuffer()),e.framebufferTexture2D(p,36064,this.color[0].tex.type,this.color[0].tex.glt,0),this.depth&&e.framebufferRenderbuffer(p,36096,36161,this.depth.tex.glrb))}destroy(){this.gl.deleteFramebuffer(this.glfb)}resolve(){}}class M{constructor(e,t){this.gl=e,this.mode=4,this.indexFormat=h,Object.assign(this,t);let n=0;this.glp=function(e,t,n,r){const i=R(e,35633,t),o=R(e,35632,n),a=e.createProgram();e.attachShader(a,i),e.attachShader(a,o);for(const{attrs:t}of r)for(const n of t)e.bindAttribLocation(a,n.shaderLoc,n.name);return e.linkProgram(a),e.deleteShader(i),e.deleteShader(o),a}(e,t.vert,t.frag,this.buffers=t.buffers.map((({attrs:e,stride:t,instanced:r=!1})=>{const i=Array(e.length);let o=0;for(let t=0;t<e.length;++t,++n){const{name:r,format:a,offset:s=o,shaderLoc:l=n}=e[t];i[t]={name:r,format:a,offset:s,shaderLoc:l},o=Math.max(o,s)+4*O(a)}return{attrs:i,stride:t||o,instanced:r}})))}destroy(){this.gl.deleteProgram(this.glp)}}function I(e,t,n){n?e.enable(t):e.disable(t)}function R(e,t,n){const r=e.createShader(t);return e.shaderSource(r,n),e.compileShader(r),r}class A{constructor(e){this.gl=e,this.webgl2=!1,this.canvas=e.canvas,(this.exts={})[C]=e.getExtension(C),this.rctx=new D(e,this.feature(C))}buffer(e){return new _(this.gl,e)}texture(e,t){return new N(this.gl,e,t)}pipeline(e){return new M(this.gl,e)}pass(e){return new F(this.gl,e)}render(e){let{width:t,height:n}=this.gl.canvas;this.gl.viewport(0,0,t,n);let r=0;return e.clearColor&&(r|=16384,this.gl.clearColor(...e.clearColor)),!1!==e.clearDepth&&(r|=256,this.gl.clearDepth(e.clearDepth),this.gl.depthMask(!0)),r&&this.gl.clear(r),this.rctx}feature(e){return this.exts[e]}reset(){this.rctx.reset()}}class D{constructor(e,t){this.gl=e,this.inst=t,this.reset()}reset(){this.state={pipeObj:null,stencilRef:0}}pipeline(e){if(this.state.pipeObj!==e){this.state.pipeObj=e,this.gl.useProgram(e.glp),function(e,t,n=0){const{blend:r,depth:i,stencil:o,raster:a}=t;a&&(I(e,32926,!!a.alphaToCoverage),I(e,2884,!!a.cullMode),I(e,32823,!(!a.depthBiasSlopeScale&&!a.depthBias)),e.polygonOffset(a.depthBiasSlopeScale||0,a.depthBias||0),a.cullMode&&e.cullFace(a.cullMode),e.frontFace(a.frontFace||2305)),I(e,2929,!!i),i&&(e.depthMask(!!i.writeEnabled),e.depthFunc(i.compare||519))}(this.gl,e,this.state.stencilRef);for(let e=0;e<8;++e)this.gl.disableVertexAttribArray(e);for(const{attrs:t}of e.buffers)for(const{shaderLoc:e}of t)this.gl.enableVertexAttribArray(e)}return this}index({glb:e}){return this.gl.bindBuffer(34963,e),this}vertex(e,{glb:t}){const{attrs:n,stride:r,instanced:i}=this.state.pipeObj.buffers[e];this.gl.bindBuffer(34962,t);for(const{format:e,offset:t,shaderLoc:o}of n)this.gl.vertexAttribPointer(o,O(e),d,!1,r,t),this.inst?.vertexAttribDivisorANGLE(o,i?1:0);return this}uniforms(e){let t=0;for(const n in e){const r=e[n],i=this.state.pipeObj.uniforms[n].format,o=this.gl.getUniformLocation(this.state.pipeObj.glp,n);if(i&&o)if(r.length)switch(i){case 35676:this.gl.uniformMatrix4fv(o,!1,r);break;case 35675:this.gl.uniformMatrix3fv(o,!1,r);break;case 35666:this.gl.uniform4fv(o,r);break;case 35665:this.gl.uniform3fv(o,r);break;case 35664:this.gl.uniform2fv(o,r);break;default:this.gl.uniform1fv(o,r)}else"number"==typeof r?this.gl.uniform1f(o,r):(this.gl.activeTexture(33984+t),this.gl.bindTexture(r.type,r.glt),this.gl.uniform1i(o,t++))}return this}draw(e,t=1,n=0){const{mode:r}=this.state.pipeObj;return t>1?this.inst?.drawArraysInstancedANGLE(r,n,e,t):this.gl.drawArrays(r,n,e),this}drawIndexed(e,t=1,n=0){const{mode:r}=this.state.pipeObj;return t>1?this.inst?.drawElementsInstancedANGLE(r,e,h,2*n,t):this.gl.drawElements(r,e,h,2*n),this}viewport(e,t,n,r){return this.gl.viewport(e,t,n,r),this}scissor(e,t,n,r){return this}blendColor(e){return this}stencilRef(e){return this}end(){}}function L(){var t=new e(9);return e!=Float32Array&&(t[1]=0,t[2]=0,t[3]=0,t[5]=0,t[6]=0,t[7]=0),t[0]=1,t[4]=1,t[8]=1,t}var U;function V(){var t=new e(4);return e!=Float32Array&&(t[0]=0,t[1]=0,t[2]=0),t[3]=1,t}U=new e(4),e!=Float32Array&&(U[0]=0,U[1]=0,U[2]=0,U[3]=0),t(),n(1,0,0),n(0,1,0),V(),V(),L();const G=a(),P=V(),B=n(1,1,1),z=t();function j(e){return e.extras||(e.extras={}),e.extras}function H(e,t=e.scene||0){const n=[],r=e.scenes?.[t]?.nodes;if(r)for(let t=0;t<r.length;++t)$(e,r[t],G,n);return n.sort().filter(((e,t,n)=>t===n.indexOf(e)))}function $(e,n,r,i=null){const o=e.nodes?.[n];if(!o)return;i?.push(n);const f=j(o).matrix=j(o).matrix||a();var c,m,h,d,g,v,p,x,b,T,y,w,O,C,E,S,_,N,F,M,I,R,A;o.matrix?s(f,o.matrix):(o.rotation||o.scale||o.translation)&&(c=f,m=o.rotation||P,h=o.translation||z,d=o.scale||B,w=(g=m[0])*(b=g+g),O=g*(T=(v=m[1])+v),C=g*(y=(p=m[2])+p),E=v*T,S=v*y,_=p*y,N=(x=m[3])*b,F=x*T,M=x*y,I=d[0],R=d[1],A=d[2],c[0]=(1-(E+_))*I,c[1]=(O+M)*I,c[2]=(C-F)*I,c[3]=0,c[4]=(O-M)*R,c[5]=(1-(w+_))*R,c[6]=(S+N)*R,c[7]=0,c[8]=(C+F)*A,c[9]=(S-N)*A,c[10]=(1-(w+E))*A,c[11]=0,c[12]=h[0],c[13]=h[1],c[14]=h[2],c[15]=1);const D=j(o).model=j(o).model||a();u(D,r,f);const L=e.cameras?.[o.camera];if(L&&(l(j(L).view=j(L).view||a(),D),function(e,t,n,r){e[0]=t,e[1]=n,e[2]=r}(j(L).translation=j(L).translation||t(),D[12],D[13],D[14])),o.children)for(const t of o.children)$(e,t,D,i)}function k(e,n,a,s){const l=t();o(l,a.min,s);const f=t();o(f,a.max,s);const c=t();r(c,f,l),i(c,c,.5);const u=t();!function(e,t,n){e[0]=t[0]-n[0],e[1]=t[1]-n[1],e[2]=t[2]-n[2]}(u,f,c);const m=(d=(h=u)[0],g=h[1],v=h[2],Math.hypot(d,g,v));var h,d,g,v;for(const t of[0,1,2])e[t]=c[t]-m,n[t]=c[t]+m}function W(e,t){let n="";for(let r=0;r<8;++r)n+=`\n#ifdef USE_TARGET_${t}_${r}\n  ${e} += targetWeights[${r}] * TARGET_${t}_${r};\n#endif\n`;return n}const q=`\nprecision highp float;\n\nuniform mat4 model;\nuniform mat4 viewProj;\nuniform mat3 normalMatrix;\n\n#if defined(USE_COLOR_VEC4)\nattribute vec4 COLOR_0;\nvarying vec4 vColor0;\n#elif defined(USE_COLOR_VEC3)\nattribute vec3 COLOR_0;\nvarying vec4 vColor0;\n#endif\n\n#ifdef USE_TEXCOORD_0\nattribute vec2 TEXCOORD_0;\n#endif\n#ifdef USE_TEXCOORD_1\nattribute vec2 TEXCOORD_1;\n#endif\n\nvarying vec2 vTexCoord0;\nvarying vec2 vTexCoord1;\n\n\n#ifdef USE_JOINTS_0\nattribute vec4 JOINTS_0;\n#endif\n\n#ifdef USE_WEIGHTS_0\nattribute vec4 WEIGHTS_0;\n#endif\n\n#if defined(USE_WEIGHTS_0) && defined(USE_JOINTS_0)\n#define USE_SKINNING\n\n#ifndef NUM_JOINTS\n#define NUM_JOINTS 24\n#endif\n\nuniform mat4 jointMatrix[NUM_JOINTS];\n\nmat4 getSkinMatrix() {\n  mat4 skin =\n    WEIGHTS_0.x * jointMatrix[int(JOINTS_0.x)] +\n    WEIGHTS_0.y * jointMatrix[int(JOINTS_0.y)] +\n    WEIGHTS_0.z * jointMatrix[int(JOINTS_0.z)] +\n    WEIGHTS_0.w * jointMatrix[int(JOINTS_0.w)];\n\n  return skin;\n}\n#endif\n\n${["POSITION","NORMAL","TANGENT"].map((e=>{let t="";for(let n=0;n<8;++n)t+=`\n#ifdef USE_TARGET_${e}_${n}\n  attribute vec3 TARGET_${e}_${n};\n#endif\n`;return t})).join("\n")}\n\n#if defined(USE_TARGET_POSITION_0) || defined(USE_TARGET_NORMAL_0) || defined(USE_TARGET_TANGENT_0)\n#define USE_MORPHING\n#ifndef NUM_MORPHS\n#define NUM_MORPHS 8\n#endif\n\nuniform float targetWeights[NUM_MORPHS];\n\nvec4 getTargetPosition() {\n  vec4 pos = vec4(0);\n  ${W("pos.xyz","POSITION")}\n  return pos;\n}\n\nvec3 getTargetNormal() {\n  vec3 normal = vec3(0);\n  ${W("normal","NORMAL")}\n  return normal;\n}\n\nvec3 getTargetTangent() {\n  vec3 tangent = vec3(0);\n  ${W("tangent","TANGENT")}\n  return tangent;\n}\n\n#endif\n\n\nattribute vec3 POSITION;\nvarying vec3 vPosition;\n\nvec4 getPosition(void) {\n  vec4 pos = vec4(POSITION, 1.0);\n\n#ifdef USE_MORPHING\n  pos += getTargetPosition();\n#endif\n#ifdef USE_SKINNING\n  pos = getSkinMatrix() * pos;\n#endif\n\n  return pos;\n}\n\n#ifdef USE_NORMAL\nattribute vec3 NORMAL;\n\n#ifdef USE_TANGENT\nattribute vec4 TANGENT;\nvarying mat3 vTBN;\n\nvec3 getTangent() {\n  vec3 tan = TANGENT.xyz;\n\n#ifdef USE_MORPHING\n  tan += getTargetTangent();\n#endif\n#ifdef USE_SKINNING\n  tan = mat3(getSkinMatrix()) * tan;\n#endif\n\n  return normalize(tan);\n}\n#else\nvarying vec3 vNormal;\n#endif\n\nvec3 getNormal() {\n  vec3 norm = NORMAL;\n\n#ifdef USE_MORPHING\n  norm += getTargetNormal();\n#endif\n#ifdef USE_SKINNING\n  norm = mat3(getSkinMatrix()) * norm;\n#endif\n\n  return normalize(norm);\n}\n\n#endif\n\nvoid main(void) {\n  vec4 pos = model * getPosition();\n  vPosition = pos.xyz / pos.w;\n\n#ifdef USE_NORMAL\n#ifdef USE_TANGENT\n  vec3 tan = getTangent();\n  vec3 normW = normalize(normalMatrix * getNormal());\n  vec3 tanW = normalize(normalMatrix * tan);\n  vec3 bitanW = cross(normW, tanW) * TANGENT.w;\n  vTBN = mat3(tanW, bitanW, normW);\n#else\n  vNormal = normalize(normalMatrix * NORMAL);\n#endif\n#endif\n\n#if defined(USE_COLOR_VEC4)\n  vColor0 = COLOR_0;\n#elif defined(USE_COLOR_VEC3)\n  vColor0 = vec4(COLOR_0, 1.0);\n#endif\n\n  vTexCoord0 = vec2(0.0, 0.0);\n  vTexCoord1 = vec2(0.0, 0.0);\n#ifdef USE_TEXCOORD_0\n  vTexCoord0 = TEXCOORD_0;\n#endif\n#ifdef USE_TEXCOORD_1\n  vTexCoord1 = TEXCOORD_1;\n#endif\n\n  gl_Position = viewProj * pos;\n  gl_PointSize = 1.0;\n}\n`,J=a(),X=t(),K=a();function Q(e,t,n,r,i){const o=n.meshes?.[r.mesh];if(!o)return;var f,c,m,h,d,g,v,p,x,b,T,y,w,O,C,E,S,_,N,F,M,I,R,A,D,U,V,G,P,B,z;i.model=s(i.model||a(),j(r).model||J),i.normalMatrix=(f=i.normalMatrix||L(),m=(c=i.model)[0],h=c[1],d=c[2],g=c[3],v=c[4],p=c[5],x=c[6],b=c[7],T=c[8],y=c[9],w=c[10],O=c[11],C=c[12],E=c[13],S=c[14],(z=(N=m*p-h*v)*(B=w*(_=c[15])-O*S)-(F=m*x-d*v)*(P=y*_-O*E)+(M=m*b-g*v)*(G=y*S-w*E)+(I=h*x-d*p)*(V=T*_-O*C)-(R=h*b-g*p)*(U=T*S-w*C)+(A=d*b-g*x)*(D=T*E-y*C))?(z=1/z,f[0]=(p*B-x*P+b*G)*z,f[1]=(x*V-v*B-b*U)*z,f[2]=(v*P-p*V+b*D)*z,f[3]=(d*P-h*B-g*G)*z,f[4]=(m*B-d*V+g*U)*z,f[5]=(h*V-m*P-g*D)*z,f[6]=(E*A-S*R+_*I)*z,f[7]=(S*M-C*A-_*F)*z,f[8]=(C*R-E*M+_*N)*z,f):null);const H=l(a(),i.model);for(let a=0;a<o.primitives.length;++a){const s=o.primitives[a];let l=!1,f=0,c=0;const m=n.accessors?.[s.attributes.POSITION];if(!m)continue;f=m.count;const h={...i,...Z(e,n,s.material)};s.targets?.length&&(h.targetWeights=r.weights||o.weights||[0,0,0,0,0,0,0,0]);let d=0;const g=n.skins?.[r.skin];if(g){d=g.joints.length;const e=j(g).jointMatrix=j(g).jointMatrix||new Float32Array(16*d),t=ee(n,g);for(let r=0;r<d;++r){const i=n.nodes?.[g.joints[r]],o=i&&j(i).model||J,a=new Float32Array(e.buffer,e.byteOffset+64*r,16);u(a,o,new Float32Array(t.buffer,t.byteOffset+64*r,16)),u(a,H,a)}h.jointMatrix=e}const v=Y(e,n,r.mesh,a,d);t.pipeline(v).uniforms(h);for(let r=0;r<v.buffers.length;++r){const i=v.buffers[r].attrs[0].name,o=i.match(/TARGET_(.+)_(\d+)/),a=te(e,n,o?s.targets[o[2]][o[1]]:s.attributes[i],34962);a&&t.vertex(r,a)}{const r=n.accessors?.[s.indices];if(r){const i=te(e,n,s.indices,34963);i&&(t.index(i),f=r.count,c=(r.byteOffset||0)/(($=v.indexFormat)?$-5123+2:0),l=!0)}}l?t.drawIndexed(f,1,c):t.draw(f)}var $}function Y(e,t,n,r,i=0){const o=t.meshes[n].primitives[r];let a=j(o).pipeline;if(a)return a;const s=o.mode||4,l=t.materials?.[o.material];let f="OPAQUE",c=!1;l&&(c=l.doubleSided||!1,f=l.alphaMode||f);const u=function(e,t){const n=[];function r(e,t,r,i,o,a=0){const s=(a||0)%(o||4);n.push({attrs:[{name:e,format:i,offset:s,shaderLoc:t}],stride:o})}let i=0;const o=["POSITION","NORMAL","TANGENT","TEXCOORD_0","TEXCOORD_1","COLOR_0","JOINTS_0","WEIGHTS_0"];for(const n of o){const o=e.accessors?.[t.attributes[n]];if(!o)continue;const a=e.bufferViews?.[o.bufferView];if(!a)continue;const s=re(o.type,o.componentType,o.normalized);s&&r(n,i++,o.bufferView,s,a.byteStride,o.byteOffset)}if(t.targets){const n=["POSITION","NORMAL","TANGENT"];for(let o=0;o<t.targets.length;++o)for(const a of n){const n=e.accessors?.[t.targets[o][a]];if(!n)continue;const s=e.bufferViews?.[n.bufferView];s&&r(`TARGET_${a}_${o}`,i++,n.bufferView,768,s.byteStride,n.byteOffset)}}return n}(t,o);let m=5123;const h=t.accessors?.[o.indices];h&&5125===h.componentType&&(m=5125);const d=o.attributes.JOINTS_0&&o.attributes.WEIGHTS_0?12*Math.ceil(i/12):0,g=JSON.stringify([u,m,d,s,c,f]),v=j(t).pipelines=j(t).pipelines||{};if(a=v[g],a)return a;const p=[`ALPHAMODE_${f}`];for(const e of u)for(const t of e.attrs)p.push(`USE_${t.name}`);d>0&&p.push(`NUM_JOINTS ${d}`);const x=p.map((e=>`#define ${e}`)).join("\n"),b={};return d>0&&(b.jointMatrix={type:1,format:w}),o.targets?.length&&(b.targetWeights={type:1,format:y}),a=j(o).pipeline=v[g]=e.pipeline({vert:x+q,frag:x+"\n#ifdef GL_OES_standard_derivatives\n  #extension GL_OES_standard_derivatives : enable\n#endif\n\nprecision highp float;\n\nuniform float alphaCutoff;\nuniform vec3 cameraPosition;\n\nvarying vec3 vPosition;\n\n\nconst float GAMMA = 2.2;\n\nvec3 linearTosRGB(vec3 color) {\n  return pow(color, vec3(1.0/GAMMA));\n}\n\nvec3 sRGBToLinear(vec3 srgbIn) {\n  return vec3(pow(srgbIn.xyz, vec3(GAMMA)));\n}\n\nvec4 sRGBToLinear(vec4 srgbIn) {\n  return vec4(sRGBToLinear(srgbIn.xyz), srgbIn.w);\n}\n\n\nconst float PI = 3.141592653589793;\n\nvec3 specularF(vec3 r0, vec3 r90, float vDotH) {\n  return r0 + (r90 - r0) * pow(clamp(1.0 - vDotH, 0.0, 1.0), 5.0);\n}\n\nfloat specularD(float aSqr, float nDotH) {\n  float f = (nDotH * nDotH) * (aSqr - 1.0) + 1.0;\n  return aSqr / (PI * f * f);\n}\n\nfloat specularV(float aSqr, float nDotL, float nDotV) {\n  float gl = 1.0 / (nDotL + sqrt(aSqr + (1.0 - aSqr) * (nDotL * nDotL)));\n  float gv = 1.0 / (nDotV + sqrt(aSqr + (1.0 - aSqr) * (nDotV * nDotV)));\n  return gl * gv;\n}\n\nfloat specularBRDF(float aSqr, float nDotL, float nDotV, float nDotH) {\n  return specularV(aSqr, nDotL, nDotV) * specularD(aSqr, nDotH);\n}\n\nvec3 diffuseBRDF(vec3 color) {\n  return color / PI;\n}\n\n\nvarying vec2 vTexCoord0;\nvarying vec2 vTexCoord1;\n\nstruct TextureInfo {\n  sampler2D tex;\n  float texCoord;\n  float scale;\n};\n\nvec2 getTexCoord(TextureInfo tex) {\n  return mix(vTexCoord0, vTexCoord1, step(1.0, tex.texCoord));\n}\n\nvec4 texture(TextureInfo tex) {\n  return texture2D(tex.tex, getTexCoord(tex));\n}\n\nvec4 texture(TextureInfo tex, vec4 defaultValue) {\n  return mix(defaultValue, texture2D(tex.tex, getTexCoord(tex)), step(0.0, tex.texCoord));\n}\n\n\nuniform TextureInfo normalTexture;\n\n#ifdef USE_NORMAL\n#ifdef USE_TANGENT\nvarying mat3 vTBN;\n#else\nvarying vec3 vNormal;\n#endif\n#endif\n\nstruct NormalInfo {\n  vec3 ng;\n  vec3 n;\n  vec3 t;\n  vec3 b;\n};\n\nNormalInfo getNormalInfo(vec3 v) {\n  vec2 UV = getTexCoord(normalTexture);\n  vec3 uvDx = dFdx(vec3(UV, 0.0));\n  vec3 uvDy = dFdy(vec3(UV, 0.0));\n\n  vec3 t_ = (uvDy.t * dFdx(v) - uvDx.t * dFdy(v)) / (uvDx.s * uvDy.t - uvDy.s * uvDx.t);\n\n  vec3 n, t, b, ng;\n\n#ifdef USE_TANGENT\n  t = normalize(vTBN[0]);\n  b = normalize(vTBN[1]);\n  ng = normalize(vTBN[2]);\n#else\n#ifdef USE_NORMAL\n  ng = normalize(vNormal);\n#else\n  ng = normalize(cross(dFdx(v), dFdy(v)));\n#endif\n  t = normalize(t_ - ng * dot(ng, t_));\n  b = cross(ng, t);\n#endif\n\n  if (gl_FrontFacing == false) {\n    t *= -1.0;\n    b *= -1.0;\n    ng *= -1.0;\n  }\n\n  n = ng;\n  if (normalTexture.texCoord >= 0.0) {\n    n = texture(normalTexture).rgb * 2.0 - vec3(1.0);\n    n *= vec3(normalTexture.scale, normalTexture.scale, 1.0);\n    n = mat3(t, b, ng) * normalize(n);\n  }\n\n  NormalInfo info;\n  info.ng = ng;\n  info.t = t;\n  info.b = b;\n  info.n = n;\n  return info;\n}\n\n\nconst float MIN_ROUGHNESS = 0.04;\n\n#if defined(USE_COLOR_VEC4) || defined(USE_COLOR_VEC3)\nvarying vec4 vColor0;\n#endif\n\nuniform vec4 baseColorFactor;\nuniform TextureInfo baseColorTexture;\n\nuniform float metallicFactor;\nuniform float roughnessFactor;\nuniform TextureInfo metallicRoughnessTexture;\n\nuniform TextureInfo occlusionTexture;\n\nuniform vec3 emissiveFactor;\nuniform TextureInfo emissiveTexture;\n\nvec4 getVertexColor() {\n  vec4 color = vec4(1.0);\n#if defined(USE_COLOR_VEC4) || defined(USE_COLOR_VEC3)\n  color = vColor0;\n#endif\n  return color;\n}\n\nvec4 getBaseColor() {\n  vec4 baseColor = vec4(1.0);\n\n  baseColor *= baseColorFactor;\n  baseColor *= sRGBToLinear(texture(baseColorTexture, vec4(1.0)));\n\n  return baseColor * getVertexColor();\n}\n\nvec2 getMetallicRoughness() {\n  vec4 mrTex = texture(metallicRoughnessTexture, vec4(1.0));\n  return vec2(\n    clamp(metallicFactor * mrTex.b, 0.0, 1.0),\n    clamp(roughnessFactor * mrTex.g, MIN_ROUGHNESS, 1.0)\n  );\n}\n\nfloat getOcculsion() {\n  return texture(occlusionTexture, vec4(1.0)).r;\n}\n\nvec3 getEmissiveFactor() {\n  return emissiveFactor * texture(emissiveTexture, vec4(0.0)).rgb;\n}\n\n\n\nvoid main () {\n  vec4 baseColor = getBaseColor();\n#ifdef ALPHAMODE_OPAQUE\n  baseColor.a = 1.0;\n#endif\n\n  vec3 v = normalize(cameraPosition - vPosition);\n  NormalInfo normalInfo = getNormalInfo(vPosition);\n  vec3 n = normalInfo.n;\n\n  vec3 reflection = -normalize(reflect(v, n));\n  float nDotV = clamp(abs(dot(n, v)), 0.001, 1.0);\n\n  vec2 metallicRoughness = getMetallicRoughness();\n  float metallic = metallicRoughness[0];\n  float roughness = metallicRoughness[1];\n  float alphaRoughness = roughness * roughness;\n  float aSqr = alphaRoughness * alphaRoughness;\n\n  vec3 f0 = vec3(0.04);\n  vec3 diffuseColor = baseColor.rgb * (vec3(1.0) - f0) * (1.0 - metallic);\n  vec3 specularColor = mix(f0, baseColor.rgb, metallic);\n\n  float r0 = max(max(specularColor.r, specularColor.g), specularColor.b);\n  float r90 = clamp(r0 * 25.0, 0.0, 1.0);\n  vec3 specularEnvR0 = specularColor.rgb;\n  vec3 specularEnvR90 = vec3(1.0, 1.0, 1.0) * r90;\n\n  vec3 diffuseFinal = vec3(0.0);\n  vec3 specularFinal = vec3(0.0);\n\n  vec3 lightDirs[2];\n  lightDirs[0] = vec3(0.5, -0.707107, -0.5);\n  lightDirs[1] = vec3(-0.5, 0.707107, 0.5);\n  vec4 lightColors[2];\n  lightColors[0] = vec4(1.0, 1.0, 1.0, 1.0);\n  lightColors[1] = vec4(1.0, 1.0, 1.0, 0.5);\n\n  for (int i = 0; i < 2; ++i) {\n    vec3 intensity = lightColors[i].rgb * lightColors[i].a;\n    vec3 l = normalize(-lightDirs[i]);\n    vec3 h = normalize(l + v);\n    float nDotL = clamp(dot(n, l), 0.001, 1.0);\n    float nDotH = clamp(dot(n, h), 0.0, 1.0);\n    float vDotH = clamp(dot(v, h), 0.0, 1.0);\n  \n    vec3 F = specularF(specularEnvR0, specularEnvR90, vDotH);\n    vec3 diffuse = (1.0 - F) * diffuseBRDF(diffuseColor);\n    vec3 specular = max(vec3(0.0), F * specularBRDF(aSqr, nDotL, nDotV, nDotH));\n  \n    diffuseFinal += intensity * nDotL * diffuse;\n    specularFinal += intensity * nDotL * specular;\n  }\n\n  vec4 ambient = vec4(0.1);\n\n  vec3 ambientDiffuse = ambient.rgb * diffuseBRDF(diffuseColor);\n  diffuseFinal += ambientDiffuse;\n\n  vec3 colorFinal = diffuseFinal + specularFinal;\n\n  float ao = getOcculsion();\n  colorFinal = mix(colorFinal, colorFinal * ao, occlusionTexture.scale);\n\n  vec3 emissive = getEmissiveFactor();\n  colorFinal += emissive;\n\n#ifdef ALPHAMODE_MASK\n  if (baseColor.a < alphaCutoff) {\n    discard;\n  }\n  baseColor.a = 1.0;\n#else\n  alphaCutoff;\n#endif\n\n  gl_FragColor = vec4(linearTosRGB(colorFinal), baseColor.a);\n}\n",buffers:u,indexFormat:m,mode:s,depth:{compare:515,writeEnabled:!0},raster:{cullMode:c?0:1029},uniforms:{model:{type:1,format:w},viewProj:{type:1,format:w},normalMatrix:{type:1,format:35675},cameraPosition:{type:1,format:35665},alphaCutoff:{type:1,format:y},baseColorFactor:{type:1,format:35666},"baseColorTexture.tex":{type:2,format:T},"baseColorTexture.texCoord":{type:1,format:y},metallicFactor:{type:1,format:y},roughnessFactor:{type:1,format:y},"metallicRoughnessTexture.tex":{type:2,format:T},"metallicRoughnessTexture.texCoord":{type:1,format:y},"normalTexture.tex":{type:2,format:T},"normalTexture.texCoord":{type:1,format:y},"normalTexture.scale":{type:1,format:y},emissiveFactor:{type:1,format:35665},"emissiveTexture.tex":{type:2,format:T},"emissiveTexture.texCoord":{type:1,format:y},"occlusionTexture.tex":{type:2,format:T},"occlusionTexture.texCoord":{type:1,format:y},"occlusionTexture.scale":{type:1,format:y},...b}}),a}function Z(e,t,n){const r={alphaCutoff:0,baseColorFactor:[1,1,1,1],"baseColorTexture.tex":ne(e,t),"baseColorTexture.texCoord":-1,metallicFactor:1,roughnessFactor:1,"metallicRoughnessTexture.tex":ne(e,t),"metallicRoughnessTexture.texCoord":-1,"normalTexture.tex":ne(e,t),"normalTexture.texCoord":-1,"normalTexture.scale":1,emissiveFactor:[0,0,0],"emissiveTexture.tex":ne(e,t),"emissiveTexture.texCoord":-1,"occlusionTexture.tex":ne(e,t),"occlusionTexture.texCoord":-1,"occlusionTexture.scale":0};function i(n,i,o=null){n[i]&&(r[`${i}.tex`]=function(e,t,n){const r=t.textures?.[n];if(!r)return ne(e,t);let i=j(r).texture;if(i)return i;let o=null;const a={wrapU:10497,wrapV:10497,magFilter:x.Linear,minFilter:x.Linear},s=t.images?.[r.source];s&&(o=j(s).image);const l=t.samplers?.[r.sampler];if(l){if(l.magFilter&&(a.magFilter=l.magFilter),l.minFilter)switch(l.minFilter){case b.Nearest:case b.NearestMipmapNearest:case b.NearestMipmapLinear:a.minFilter=b.Nearest;break;default:a.minFilter=b.Linear}l.wrapS&&(a.wrapU=l.wrapS),l.wrapT&&(a.wrapV=l.wrapT)}return i=j(r).texture=e.texture({size:o?[o.naturalWidth,o.naturalHeight]:[1,1]},a),i.data(o||new Uint8Array([1,1,1,1])),i}(e,t,n[i].index),r[`${i}.texCoord`]=n[i].texCoord||0,o&&(r[`${i}.scale`]=n[i][o]||0))}const o=t.materials?.[n];if(o){if(o.pbrMetallicRoughness){const e=o.pbrMetallicRoughness;e.baseColorFactor&&(r.baseColorFactor=e.baseColorFactor),(e.metallicFactor||0===e.metallicFactor)&&(r.metallicFactor=e.metallicFactor),(e.roughnessFactor||0===e.roughnessFactor)&&(r.roughnessFactor=e.roughnessFactor),i(e,"baseColorTexture"),i(e,"metallicRoughnessTexture")}r.alphaCutoff=o.alphaCutoff||0,o.emissiveFactor&&(r.emissiveFactor=o.emissiveFactor),i(o,"emissiveTexture"),i(o,"occlusionTexture","strength"),i(o,"normalTexture","scale")}return r}function ee(e,t){let n=j(t).inverseBindMatrices;if(n)return n;const r=e.accessors?.[t.inverseBindMatrices];if(r){const t=e.bufferViews?.[r.bufferView];if(t){const e=j(t).bufferView;n=new Float32Array(e.buffer,e.byteOffset+(r.byteOffset||0),16*r.count)}}return n||(n=new Float32Array(16*t.joints.length)),j(t).inverseBindMatrices=n,n}function te(e,t,n,r){const i=t.accessors?.[n];if(!i)return null;const o=t.bufferViews?.[i.bufferView];if(!o)return null;const a=j(o).bufferView;if(34963===r){let t=j(o).gpuBuffer;return t||(t=j(o).gpuBuffer=e.buffer({type:o.target||r,size:o.byteLength}).data(a),t)}const s=j(o).gpuBuffers=j(o).gpuBuffers||{},l=o.byteStride||4,f=(i.byteOffset||0)%l,c=(i.byteOffset||0)-f,u=i.count*(("VEC2"===(g=i.type)?2:"VEC3"===g?3:"VEC4"===g?4:0)*((v=i.componentType)===d?4:v===h?2:v===m?1:0));var g,v;const p=`${c},${u}`;if(s[p])return s[p];const x=new Uint8Array(a.buffer,(a.byteOffset||0)+c,u);return s[p]=e.buffer({type:o.target||r,size:u}).data(x)}function ne(e,t){let n=j(t).blankTexture;return n||(n=j(t).blankTexture=e.texture({size:[1,1]}).data(new Uint8Array([255,255,255,255])),n)}function re(e,t,n=!1){switch(e){case"VEC2":if(t===d)return 512;if(t===h)return n?66052:516;break;case"VEC3":if(t===d)return 768;break;case"VEC4":if(t===d)return 1024;if(t===m)return n?66562:1026;if(t===h)return n?66564:1028}return null}function ie(e){return(new TextDecoder).decode(e)}function oe(e){return/^data:.*,.*$/i.test(e)||/^blob:.*$/i.test(e)}function ae(e,t){return""===e?"":/^(https?:)?\/\//i.test(e)||oe(e)?e:t+e}async function se(e,t=le){const n=e.uri?function(e){if(oe(e))return"";const t=e.split("/");return t.pop(),t.length?t.join("/")+"/":""}(e.uri):"";let r=e.glTF,i=e.binaryChunk;if(!r&&e.uri)if(e.uri.match(/\.glb$/)){const n=function(e){let t,n,r,i=0;ArrayBuffer.isView(e)?(r=e.buffer,i=e.byteOffset):r=e;const o=new DataView(r,i,12);if(1179937895!==o.getUint32(0,!0))throw new Error("Invalid GLB format");const a=o.getUint32(4,!0);if(2!==a)throw new Error("Unsupported GLB version: "+a);const s=new DataView(r,i+12);let l=0;for(;l<s.byteLength;){const e=s.getUint32(l,!0),o=s.getUint32(l+4,!0);if(l+=8,1313821514===o){const n=new Uint8Array(r,i+12+l,e);t=JSON.parse(ie(n))}else 5130562===o&&(n=new Uint8Array(r,i+12+l,e));l+=e}if(!t)throw new Error("Invalid GLB format: missing JSON content");if(!t.asset||"2.0"!==t.asset.minVersion&&"2.0"!==t.asset.version)throw new Error("Unsupported glTF version: 2.0 required");return{glTF:t,binaryChunk:n}}(await t(e.uri,"bin"));r=n.glTF,i=n.binaryChunk}else r=JSON.parse(await t(e.uri,"str"));if(!r)throw new Error("Failed to load glTF JSON");const o=await async function(e,t,n,r){if(e.buffers)for(let i=0;i<e.buffers?.length;++i){const o=e.buffers[i];if(j(o).buffer)continue;let a;const s=o.uri;if(s)a=await n(ae(s,r),"bin");else{if(0!==i||!t)throw new Error("Invalid glTF: missing uri for buffer "+i);a=t}j(o).buffer=a}if(e.bufferViews)for(let t=0;t<e.bufferViews?.length;++t){const n=e.bufferViews[t];if(j(n).bufferView)continue;const r=e.buffers?.[n.buffer];if(!r)throw new Error("Invalid glTF: invalid buffer for bufferView "+t);const i=j(r).buffer,o=new Uint8Array(i.buffer,(i.byteOffset||0)+(n.byteOffset||0),n.byteLength);j(n).bufferView=o}return e}(r,i,t,n);return await async function(e,t,n){if(e.images)for(let r=0;r<e.images.length;++r){const i=e.images[r];if(j(i).image)continue;const o=i.bufferView;let a,s=!1,l=i.uri;if(o){const t=e.bufferViews?.[o];if(!t)throw new Error("Invalid glTF: invalid bufferView for image "+r);const n=new Blob([j(t).bufferView],{type:i.mimeType});l=URL.createObjectURL(n),s=!0}if(!l)throw new Error("Invalid glTF: missing uri or bufferView for image "+r);try{a=await t(ae(l,n),"img")}finally{s&&URL.revokeObjectURL(l)}j(i).image=a}return e}(o,t,n)}function le(e,t){return"bin"===t?fetch(e).then((e=>e.arrayBuffer())).then((e=>new Uint8Array(e))):"img"===t?new Promise(((t,n)=>{const r=new Image;r.crossOrigin="anonymous",r.onerror=()=>n(new Error("Failed to load: "+e)),r.onload=()=>t(r),r.src=e})):fetch(e).then((e=>e.text()))}const fe=new URLSearchParams(window.location.search),ce=document.querySelector("canvas"),ue=ce.parentElement;let me=null;const he=((e,t)=>{const n=e.getContext("webgl",{powerPreference:"low-power"});return n?new A(n):null})(ce);if(he.gl.getExtension("OES_standard_derivatives"),!he)throw new Error("WebGL is unsupported");const de="https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/63f026b2aa957d3e8207f6dd798608993e33fb0d/2.0";function ge(){if(!me)return;const e=fe.get("camera"),t=fe.get("scene"),r=((null!==t&&parseInt(t))??me.scene)||0;!function(e,t,r={}){const i=t.nodes,o=t.scenes?.[(r.scene??t.scene)||0]?.nodes;if(!i||!o)return;const s=H(t);let c=J,m=J,h=X;if(r.camera){const i=t.cameras?.[r.camera.index||0];i&&(c=i.extras?.view||J,d=K,g=i,v=e.canvas.width/e.canvas.height,g?.orthographic?function(e,t,n,r,i,o,a){var s=1/(t-n),l=1/(r-i),f=1/(o-a);e[0]=-2*s,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=-2*l,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=2*f,e[11]=0,e[12]=(t+n)*s,e[13]=(i+r)*l,e[14]=(a+o)*f,e[15]=1}(d,-g.orthographic.xmag,g.orthographic.xmag,-g.orthographic.xmag/(v||1),g.orthographic.xmag/(v||1),g.orthographic.znear,g.orthographic.zfar):g?.perspective?f(d,g.perspective.yfov,v||g.perspective.aspectRatio||1,g.perspective.znear,g.perspective.zfar||1/0):function(e){e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1}(d),m=d,h=i.extras?.translation||X),r.camera.model&&(h=n(r.camera.model[12],r.camera.model[13],r.camera.model[14]),c=l(a(),r.camera.model)),m=r.camera.proj||m}var d,g,v;const p={cameraPosition:h,viewProj:u(K,m,c)},x=e.pass(),b=e.render(x);for(let n=0;n<s.length;++n)Q(e,b,t,i[s[n]],p);b.end(),x.destroy()}(he,me,{scene:r,camera:null!==e&&me.cameras?{index:parseInt(e)}:ve(me,r,he.canvas.width/he.canvas.height)})}function ve(e,o,s){const l=n(1,2,2);(function(e,t){var n=t[0],r=t[1],i=t[2],o=n*n+r*r+i*i;o>0&&(o=1/Math.sqrt(o)),e[0]=t[0]*o,e[1]=t[1]*o,e[2]=t[2]*o})(l,l),H(e,o);const[u,m]=function(e,n,r,i){for(let t=0;t<3;++t)e[t]=1/0,n[t]=-1/0;const o=r.scenes?.[i];if(!o)return[e,n];let a=(o.nodes||[]).slice();for(;a.length>0;){const i=r.nodes?.[a.pop()];if(!i)continue;a=a.concat(i.children||[]);const o=r.meshes?.[i.mesh];if(o&&o.primitives)for(const a of o.primitives){const o=r.accessors?.[a.attributes.POSITION];if(!o)continue;const s=t(),l=t();k(s,l,o,j(i).model||G);for(const t of[0,1,2])e[t]=Math.min(e[t],s[t]),n[t]=Math.max(n[t],l[t])}}return[e,n]}(t(),t(),e,o),h=Math.max(m[0]-u[0],m[1]-u[1]),d=Math.PI/4,g=d*s,v=h/2/Math.tan(d/2),p=h/2/Math.tan(g/2),x=Math.max(p,v);i(l,l,1.2*x);const b=(T=u,w=(y=m)[0]-T[0],O=y[1]-T[1],C=y[2]-T[2],Math.hypot(w,O,C));var T,y,w,O,C;let E=x+6*b,S=x-6*b;S=Math.max(S,E/1e4);const _=t();return r(_,u,m),i(_,_,.5),{model:c(a(),l,_,n(0,1,0)),proj:f(a(),d,s,S,E)}}function pe(){const e=window.devicePixelRatio||1,t=ue.clientWidth,n=ue.clientHeight;ce.width=t*e,ce.height=n*e,ce.style.width=`${t}px`,ce.style.height=`${n}px`,ge()}window.addEventListener("resize",pe,!1),pe(),async function(){let e=fe.get("url");if(!e){const t=await(await fetch(`${de}/model-index.json`)).json(),n=fe.get("model")||"DamagedHelmet",r=fe.get("variant")||"glTF",i=t.find((e=>e.name===n));e=`${de}/${n}/${r}/${i.variants[r]}`}const t=await se({uri:e});me=t,ge()}()})();