(()=>{var e="undefined"!=typeof Float32Array?Float32Array:Array;function n(){var n=new e(3);return e!=Float32Array&&(n[0]=0,n[1]=0,n[2]=0),n}function t(n,t,r){var i=new e(3);return i[0]=n,i[1]=t,i[2]=r,i}function r(e,n,t){return e[0]=n[0]+t[0],e[1]=n[1]+t[1],e[2]=n[2]+t[2],e}function i(e,n,t){return e[0]=n[0]*t,e[1]=n[1]*t,e[2]=n[2]*t,e}function o(e,n,t){var r=n[0],i=n[1],o=n[2],a=t[3]*r+t[7]*i+t[11]*o+t[15];return a=a||1,e[0]=(t[0]*r+t[4]*i+t[8]*o+t[12])/a,e[1]=(t[1]*r+t[5]*i+t[9]*o+t[13])/a,e[2]=(t[2]*r+t[6]*i+t[10]*o+t[14])/a,e}function a(){var n=new e(16);return e!=Float32Array&&(n[1]=0,n[2]=0,n[3]=0,n[4]=0,n[6]=0,n[7]=0,n[8]=0,n[9]=0,n[11]=0,n[12]=0,n[13]=0,n[14]=0),n[0]=1,n[5]=1,n[10]=1,n[15]=1,n}function s(e,n){return e[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=n[3],e[4]=n[4],e[5]=n[5],e[6]=n[6],e[7]=n[7],e[8]=n[8],e[9]=n[9],e[10]=n[10],e[11]=n[11],e[12]=n[12],e[13]=n[13],e[14]=n[14],e[15]=n[15],e}function f(e,n){var t=n[0],r=n[1],i=n[2],o=n[3],a=n[4],s=n[5],f=n[6],l=n[7],c=n[8],u=n[9],T=n[10],d=n[11],m=n[12],h=n[13],g=n[14],_=n[15],v=t*s-r*a,E=t*f-i*a,x=t*l-o*a,p=r*f-i*s,N=r*l-o*s,O=i*l-o*f,A=c*h-u*m,b=c*g-T*m,R=c*_-d*m,S=u*g-T*h,G=u*_-d*h,I=T*_-d*g,y=v*I-E*G+x*S+p*R-N*b+O*A;return y?(y=1/y,e[0]=(s*I-f*G+l*S)*y,e[1]=(i*G-r*I-o*S)*y,e[2]=(h*O-g*N+_*p)*y,e[3]=(T*N-u*O-d*p)*y,e[4]=(f*R-a*I-l*b)*y,e[5]=(t*I-i*R+o*b)*y,e[6]=(g*x-m*O-_*E)*y,e[7]=(c*O-T*x+d*E)*y,e[8]=(a*G-s*R+l*A)*y,e[9]=(r*R-t*G-o*A)*y,e[10]=(m*N-h*x+_*v)*y,e[11]=(u*x-c*N-d*v)*y,e[12]=(s*b-a*S-f*A)*y,e[13]=(t*S-r*b+i*A)*y,e[14]=(h*E-m*p-g*v)*y,e[15]=(c*p-u*E+T*v)*y,e):null}function l(e,n,t,r,i){var o,a=1/Math.tan(n/2);return e[0]=a/t,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=a,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=-1,e[12]=0,e[13]=0,e[15]=0,null!=i&&i!==1/0?(o=1/(r-i),e[10]=(i+r)*o,e[14]=2*i*r*o):(e[10]=-1,e[14]=-2*r),e}function c(e,n,t,r){var i=n[0],o=n[1],a=n[2],s=r[0],f=r[1],l=r[2],c=i-t[0],u=o-t[1],T=a-t[2],d=c*c+u*u+T*T;d>0&&(c*=d=1/Math.sqrt(d),u*=d,T*=d);var m=f*T-l*u,h=l*c-s*T,g=s*u-f*c;return(d=m*m+h*h+g*g)>0&&(m*=d=1/Math.sqrt(d),h*=d,g*=d),e[0]=m,e[1]=h,e[2]=g,e[3]=0,e[4]=u*g-T*h,e[5]=T*m-c*g,e[6]=c*h-u*m,e[7]=0,e[8]=c,e[9]=u,e[10]=T,e[11]=0,e[12]=i,e[13]=o,e[14]=a,e[15]=1,e}Math.random,Math.PI,Math.hypot||(Math.hypot=function(){for(var e=0,n=arguments.length;n--;)e+=arguments[n]*arguments[n];return Math.sqrt(e)}),n();var u=function(e,n,t){var r=n[0],i=n[1],o=n[2],a=n[3],s=n[4],f=n[5],l=n[6],c=n[7],u=n[8],T=n[9],d=n[10],m=n[11],h=n[12],g=n[13],_=n[14],v=n[15],E=t[0],x=t[1],p=t[2],N=t[3];return e[0]=E*r+x*s+p*u+N*h,e[1]=E*i+x*f+p*T+N*g,e[2]=E*o+x*l+p*d+N*_,e[3]=E*a+x*c+p*m+N*v,E=t[4],x=t[5],p=t[6],N=t[7],e[4]=E*r+x*s+p*u+N*h,e[5]=E*i+x*f+p*T+N*g,e[6]=E*o+x*l+p*d+N*_,e[7]=E*a+x*c+p*m+N*v,E=t[8],x=t[9],p=t[10],N=t[11],e[8]=E*r+x*s+p*u+N*h,e[9]=E*i+x*f+p*T+N*g,e[10]=E*o+x*l+p*d+N*_,e[11]=E*a+x*c+p*m+N*v,E=t[12],x=t[13],p=t[14],N=t[15],e[12]=E*r+x*s+p*u+N*h,e[13]=E*i+x*f+p*T+N*g,e[14]=E*o+x*l+p*d+N*_,e[15]=E*a+x*c+p*m+N*v,e};const T=5121,d=5123,m=5126,h=6408,g=9729,_=36160,v={Nearest:9728,Linear:g},E={...v,NearestMipmapNearest:9984,NearestMipmapLinear:9986,LinearMipmapNearest:9985,LinearMipmapLinear:9987},x=3553,p=m,N=e=>e>>8&255,O="ANGLE_instanced_arrays",A={},b=[];class R{constructor(e,n){this.gl=e,this.type=34962,this.usage=35044,this.size=0,Object.assign(this,n),e.bindBuffer(this.type,this.glb=e.createBuffer()),e.bufferData(this.type,this.size,this.usage)}data(e,n=0){return this.gl.bindBuffer(this.type,this.glb),this.gl.bufferSubData(this.type,n,e),this}destroy(){this.gl.deleteBuffer(this.glb)}}class S{constructor(e,n,t=A){this.gl=e,this.type=3553,this.format=263169,this.wrapU=33071,this.wrapV=33071,this.magFilter=g,this.minFilter=g,Object.assign(this,n,t),this.glt=this.glrb=null;const[r,i]=this.size;this.format<=197381||(e.bindTexture(this.type,this.glt=e.createTexture()),e.texParameteri(this.type,10241,this.minFilter),e.texParameteri(this.type,10240,this.magFilter),e.texParameteri(this.type,10242,this.wrapU),e.texParameteri(this.type,10243,this.wrapV),e.texImage2D(this.type,0,h,r,i,0,h,T,null))}data(e,[n=0,t=0]=b,[r=this.size[0]-n,i=this.size[1]-t]=b){return this.gl.bindTexture(this.type,this.glt),ArrayBuffer.isView(e)?this.gl.texSubImage2D(this.type,0,n,t,r,i,h,T,e):this.gl.texSubImage2D(this.type,0,n,t,h,T,e),this}mipmap(){return this.gl.bindTexture(this.type,this.glt),this.gl.generateMipmap(this.type),this}destroy(){this.gl.deleteTexture(this.glt),this.gl.deleteRenderbuffer(this.glrb)}}class G{constructor(e,n=A){this.gl=e,this.color=[],this.depth=null,this.clearColor=!1,this.clearDepth=!1,this.clearStencil=!1,Object.assign(this,n),this.glfb=null,this.color[0]&&(e.bindFramebuffer(_,this.glfb=e.createFramebuffer()),e.framebufferTexture2D(_,36064,this.color[0].tex.type,this.color[0].tex.glt,0),this.depth&&e.framebufferRenderbuffer(_,36096,36161,this.depth.tex.glrb))}destroy(){this.gl.deleteFramebuffer(this.glfb)}resolve(){}}class I{constructor(e,n){this.gl=e,this.mode=4,this.indexFormat=d,Object.assign(this,n);let t=0;this.glp=function(e,n,t,r){const i=C(e,35633,n),o=C(e,35632,t),a=e.createProgram();e.attachShader(a,i),e.attachShader(a,o);for(const{attrs:n}of r)for(const t of n)e.bindAttribLocation(a,t.shaderLoc,t.name);return e.linkProgram(a),e.deleteShader(i),e.deleteShader(o),a}(e,n.vert,n.frag,this.buffers=n.buffers.map((({attrs:e,stride:n,instanced:r=!1})=>{const i=Array(e.length);let o=0;for(let n=0;n<e.length;++n,++t){const{name:r,format:a,offset:s=o,shaderLoc:f=t}=e[n];i[n]={name:r,format:a,offset:s,shaderLoc:f},o=Math.max(o,s)+4*N(a)}return{attrs:i,stride:n||o,instanced:r}})))}destroy(){this.gl.deleteProgram(this.glp)}}function y(e,n,t){t?e.enable(n):e.disable(n)}function C(e,n,t){const r=e.createShader(n);return e.shaderSource(r,t),e.compileShader(r),r}class w{constructor(e){this.gl=e,this.webgl2=!1,this.canvas=e.canvas,(this.exts={})[O]=e.getExtension(O),this.rctx=new M(e,this.feature(O))}buffer(e){return new R(this.gl,e)}texture(e,n){return new S(this.gl,e,n)}pipeline(e){return new I(this.gl,e)}pass(e){return new G(this.gl,e)}render(e){let{width:n,height:t}=this.gl.canvas;this.gl.viewport(0,0,n,t);let r=0;return e.clearColor&&(r|=16384,this.gl.clearColor(...e.clearColor)),!1!==e.clearDepth&&(r|=256,this.gl.clearDepth(e.clearDepth),this.gl.depthMask(!0)),r&&this.gl.clear(r),this.rctx}feature(e){return this.exts[e]}reset(){this.rctx.reset()}}class M{constructor(e,n){this.gl=e,this.inst=n,this.reset()}reset(){this.state={pipeObj:null,stencilRef:0}}pipeline(e){if(this.state.pipeObj!==e){this.state.pipeObj=e,this.gl.useProgram(e.glp),function(e,n,t=0){const{blend:r,depth:i,stencil:o,raster:a}=n;a&&(y(e,32926,!!a.alphaToCoverage),y(e,2884,!!a.cullMode),y(e,32823,!(!a.depthBiasSlopeScale&&!a.depthBias)),e.polygonOffset(a.depthBiasSlopeScale||0,a.depthBias||0),a.cullMode&&e.cullFace(a.cullMode),e.frontFace(a.frontFace||2305)),y(e,2929,!!i),i&&(e.depthMask(!!i.writeEnabled),e.depthFunc(i.compare||519))}(this.gl,e,this.state.stencilRef);for(let e=0;e<8;++e)this.gl.disableVertexAttribArray(e);for(const{attrs:n}of e.buffers)for(const{shaderLoc:e}of n)this.gl.enableVertexAttribArray(e)}return this}index({glb:e}){return this.gl.bindBuffer(34963,e),this}vertex(e,{glb:n}){const{attrs:t,stride:r,instanced:i}=this.state.pipeObj.buffers[e];this.gl.bindBuffer(34962,n);for(const{format:e,offset:n,shaderLoc:o}of t)this.gl.vertexAttribPointer(o,N(e),m,!1,r,n),this.inst?.vertexAttribDivisorANGLE(o,i?1:0);return this}uniforms(e){let n=0;for(const t in e){const r=e[t],i=this.state.pipeObj.uniforms[t].format,o=this.gl.getUniformLocation(this.state.pipeObj.glp,t);if(i&&o)if(r.length)switch(i){case 35676:this.gl.uniformMatrix4fv(o,!1,r);break;case 35675:this.gl.uniformMatrix3fv(o,!1,r);break;case 35666:this.gl.uniform4fv(o,r);break;case 35665:this.gl.uniform3fv(o,r);break;case 35664:this.gl.uniform2fv(o,r);break;default:this.gl.uniform1fv(o,r)}else"number"==typeof r?this.gl.uniform1f(o,r):(this.gl.activeTexture(33984+n),this.gl.bindTexture(r.type,r.glt),this.gl.uniform1i(o,n++))}return this}draw(e,n=1,t=0){const{mode:r}=this.state.pipeObj;return n>1?this.inst?.drawArraysInstancedANGLE(r,t,e,n):this.gl.drawArrays(r,t,e),this}drawIndexed(e,n=1,t=0){const{mode:r}=this.state.pipeObj;return n>1?this.inst?.drawElementsInstancedANGLE(r,e,d,2*t,n):this.gl.drawElements(r,e,d,2*t),this}viewport(e,n,t,r){return this.gl.viewport(e,n,t,r),this}scissor(e,n,t,r){return this}blendColor(e){return this}stencilRef(e){return this}end(){}}function U(){var n=new e(9);return e!=Float32Array&&(n[1]=0,n[2]=0,n[3]=0,n[5]=0,n[6]=0,n[7]=0),n[0]=1,n[4]=1,n[8]=1,n}var F;function L(){var n=new e(4);return e!=Float32Array&&(n[0]=0,n[1]=0,n[2]=0),n[3]=1,n}F=new e(4),e!=Float32Array&&(F[0]=0,F[1]=0,F[2]=0,F[3]=0),n(),t(1,0,0),t(0,1,0),L(),L(),U();const P=a(),D=L(),V=t(1,1,1),z=n();function W(e){return e.extras||(e.extras={}),e.extras}function B(e,n=e.scene||0){const t=[],r=e.scenes?.[n]?.nodes;if(r)for(let n=0;n<r.length;++n)H(e,r[n],P,t);return t.sort().filter(((e,n,t)=>n===t.indexOf(e)))}function H(e,t,r,i=null){const o=e.nodes?.[t];if(!o)return;i?.push(t);const l=W(o).matrix=W(o).matrix||a();var c,T,d,m,h,g,_,v,E,x,p,N,O,A,b,R,S,G,I,y,C,w,M;o.matrix?s(l,o.matrix):(o.rotation||o.scale||o.translation)&&(c=l,T=o.rotation||D,d=o.translation||z,m=o.scale||V,N=(h=T[0])*(E=h+h),O=h*(x=(g=T[1])+g),A=h*(p=(_=T[2])+_),b=g*x,R=g*p,S=_*p,G=(v=T[3])*E,I=v*x,y=v*p,C=m[0],w=m[1],M=m[2],c[0]=(1-(b+S))*C,c[1]=(O+y)*C,c[2]=(A-I)*C,c[3]=0,c[4]=(O-y)*w,c[5]=(1-(N+S))*w,c[6]=(R+G)*w,c[7]=0,c[8]=(A+I)*M,c[9]=(R-G)*M,c[10]=(1-(N+b))*M,c[11]=0,c[12]=d[0],c[13]=d[1],c[14]=d[2],c[15]=1);const U=W(o).model=W(o).model||a();u(U,r,l);const F=e.cameras?.[o.camera];if(F&&(f(W(F).view=W(F).view||a(),U),function(e,n,t,r){e[0]=n,e[1]=t,e[2]=r}(W(F).translation=W(F).translation||n(),U[12],U[13],U[14])),o.children)for(const n of o.children)H(e,n,U,i)}function j(e,t,a,s){const f=n();o(f,a.min,s);const l=n();o(l,a.max,s);const c=n();r(c,l,f),i(c,c,.5);const u=n();!function(e,n,t){e[0]=n[0]-t[0],e[1]=n[1]-t[1],e[2]=n[2]-t[2]}(u,l,c);const T=(m=(d=u)[0],h=d[1],g=d[2],Math.hypot(m,h,g));var d,m,h,g;for(const n of[0,1,2])e[n]=c[n]-T,t[n]=c[n]+T}const k=a(),q=n(),J=a();function $(e,n,t,r,i){const o=t.meshes?.[r.mesh];if(o){var f,l,c,u,T,d,m,h,g,_,v,E,x,p,N,O,A,b,R,S,G,I,y,C,w,M,F,L,P,D,V,z;i.model=s(i.model||a(),W(r).model||k),i.normalMatrix=(f=i.normalMatrix||U(),c=(l=i.model)[0],u=l[1],T=l[2],d=l[3],m=l[4],h=l[5],g=l[6],_=l[7],v=l[8],E=l[9],x=l[10],p=l[11],N=l[12],O=l[13],A=l[14],(V=(R=c*h-u*m)*(D=x*(b=l[15])-p*A)-(S=c*g-T*m)*(P=E*b-p*O)+(G=c*_-d*m)*(L=E*A-x*O)+(I=u*g-T*h)*(F=v*b-p*N)-(y=u*_-d*h)*(M=v*A-x*N)+(C=T*_-d*g)*(w=v*O-E*N))?(V=1/V,f[0]=(h*D-g*P+_*L)*V,f[1]=(g*F-m*D-_*M)*V,f[2]=(m*P-h*F+_*w)*V,f[3]=(T*P-u*D-d*L)*V,f[4]=(c*D-T*F+d*M)*V,f[5]=(u*F-c*P-d*w)*V,f[6]=(O*C-A*y+b*I)*V,f[7]=(A*G-N*C-b*S)*V,f[8]=(N*y-O*G+b*R)*V,f):null);for(let a=0;a<o.primitives.length;++a){const s=o.primitives[a];let f=!1,l=0,c=0;const u=t.accessors?.[s.attributes.POSITION];if(!u)continue;l=u.count;const T=X(e,t,r.mesh,a);n.pipeline(T).uniforms({...i,...K(e,t,s.material)});for(let r=0;r<T.buffers.length;++r){const i=T.buffers[r].attrs[0].name,o=Q(e,t,s.attributes[i],34962);o&&n.vertex(r,o)}{const r=t.accessors?.[s.indices];if(r){const i=Q(e,t,s.indices,34963);i&&(n.index(i),l=r.count,c=(r.byteOffset||0)/((z=T.indexFormat)?z-5123+2:0),f=!0)}}f?n.drawIndexed(l,1,c):n.draw(l)}}}function X(e,n,t,r){const i=n.meshes[t].primitives[r];let o=W(i).pipeline;if(o)return o;const a=i.mode||4,s=n.materials?.[i.material];let f="OPAQUE",l=!1;s&&(l=s.doubleSided||!1,f=s.alphaMode||f);const c=function(e,n){const t=[];function r(e,n,r,i,o,a=0){const s=(a||0)%(o||4);t.push({attrs:[{name:e,format:i,offset:s,shaderLoc:n}],stride:o})}let i=0;const o=["POSITION","NORMAL","TANGENT","TEXCOORD_0","TEXCOORD_1","COLOR_0","JOINTS_0","WEIGHTS_0"];for(const t of o){const o=e.accessors?.[n.attributes[t]];if(!o)continue;const a=e.bufferViews?.[o.bufferView];if(!a)continue;const s=ee(o.type,o.componentType,o.normalized);s&&r(t,i++,o.bufferView,s,a.byteStride,o.byteOffset)}if(n.targets){const t=["POSITION","NORMAL","TANGENT"];for(let o=0;o<n.targets.length;++o)for(const a of t){const t=e.accessors?.[n.targets[o][a]];if(!t)continue;const s=e.bufferViews?.[t.bufferView];s&&r(`TARGET_${a}_${o}`,i++,t.bufferView,768,s.byteStride,t.byteOffset)}}return t}(n,i);let u=5123;const T=n.accessors?.[i.indices];T&&5125===T.componentType&&(u=5125);const d=JSON.stringify({buffers:c,indexFormat:u,mode:a,doubleSided:l,alphaMode:f}),m=W(n).pipelines=W(n).pipelines||{};if(o=m[d],o)return o;const h=[`ALPHAMODE_${f}`];for(const e of c)for(const n of e.attrs)h.push(`USE_${n.name}`);const g=h.map((e=>`#define ${e}`)).join("\n");return o=W(i).pipeline=m[d]=e.pipeline({vert:g+"\nprecision highp float;\n\nuniform mat4 model;\nuniform mat4 viewProj;\nuniform mat3 normalMatrix;\n\n#if defined(USE_COLOR_VEC4)\nattribute vec4 COLOR_0;\nvarying vec4 vColor0;\n#elif defined(USE_COLOR_VEC3)\nattribute vec3 COLOR_0;\nvarying vec4 vColor0;\n#endif\n\n#ifdef USE_TEXCOORD_0\nattribute vec2 TEXCOORD_0;\n#endif\n#ifdef USE_TEXCOORD_1\nattribute vec2 TEXCOORD_1;\n#endif\n\nvarying vec2 vTexCoord0;\nvarying vec2 vTexCoord1;\n\n\n#ifdef USE_JOINTS_0\nattribute vec4 JOINTS_0;\n#endif\n\n#ifdef USE_WEIGHTS_0\nattribute vec4 WEIGHTS_0;\n#endif\n\n#if defined(USE_WEIGHTS_0) && defined(USE_JOINTS_0)\n#define USE_SKINNING\n\n#ifndef NUM_JOINTS\n#define NUM_JOINTS 32\n#endif\n\nuniform mat4 jointMatrix[NUM_JOINTS];\nuniform mat4 jointNormalMatrix[NUM_JOINTS];\n\nmat4 getSkinMatrix() {\n  mat4 skin =\n    WEIGHTS_0.x * jointMatrix[int(JOINTS_0.x)] +\n    WEIGHTS_0.y * jointMatrix[int(JOINTS_0.y)] +\n    WEIGHTS_0.z * jointMatrix[int(JOINTS_0.z)] +\n    WEIGHTS_0.w * jointMatrix[int(JOINTS_0.w)];\n\n  return skin;\n}\n\nmat4 getSkinNormalMatrix() {\n  mat4 skin =\n    WEIGHTS_0.x * jointNormalMatrix[int(JOINTS_0.x)] +\n    WEIGHTS_0.y * jointNormalMatrix[int(JOINTS_0.y)] +\n    WEIGHTS_0.z * jointNormalMatrix[int(JOINTS_0.z)] +\n    WEIGHTS_0.w * jointNormalMatrix[int(JOINTS_0.w)];\n\n  return skin;\n}\n#endif\n\n#ifdef USE_TARGET_POSITION_0\nin vec3 TARGET_POSITION_0;\n#endif\n\n#ifdef USE_TARGET_POSITION_1\nin vec3 TARGET_POSITION_1;\n#endif\n\n#ifdef USE_TARGET_POSITION_2\nin vec3 TARGET_POSITION_2;\n#endif\n\n#ifdef USE_TARGET_POSITION_3\nin vec3 TARGET_POSITION_3;\n#endif\n\n#ifdef USE_TARGET_POSITION_4\nin vec3 TARGET_POSITION_4;\n#endif\n\n#ifdef USE_TARGET_POSITION_5\nin vec3 TARGET_POSITION_5;\n#endif\n\n#ifdef USE_TARGET_POSITION_6\nin vec3 TARGET_POSITION_6;\n#endif\n\n#ifdef USE_TARGET_POSITION_7\nin vec3 TARGET_POSITION_7;\n#endif\n\n#ifdef USE_TARGET_NORMAL_0\nin vec3 TARGET_NORMAL_0;\n#endif\n\n#ifdef USE_TARGET_NORMAL_1\nin vec3 TARGET_NORMAL_1;\n#endif\n\n#ifdef USE_TARGET_NORMAL_2\nin vec3 TARGET_NORMAL_2;\n#endif\n\n#ifdef USE_TARGET_NORMAL_3\nin vec3 TARGET_NORMAL_3;\n#endif\n\n#ifdef USE_TARGET_NORMAL_4\nin vec3 TARGET_NORMAL_4;\n#endif\n\n#ifdef USE_TARGET_NORMAL_5\nin vec3 TARGET_NORMAL_5;\n#endif\n\n#ifdef USE_TARGET_NORMAL_6\nin vec3 TARGET_NORMAL_6;\n#endif\n\n#ifdef USE_TARGET_NORMAL_7\nin vec3 TARGET_NORMAL_7;\n#endif\n\n#ifdef USE_TARGET_TANGENT_0\nin vec3 TARGET_TANGENT_0;\n#endif\n\n#ifdef USE_TARGET_TANGENT_1\nin vec3 TARGET_TANGENT_1;\n#endif\n\n#ifdef USE_TARGET_TANGENT_2\nin vec3 TARGET_TANGENT_2;\n#endif\n\n#ifdef USE_TARGET_TANGENT_3\nin vec3 TARGET_TANGENT_3;\n#endif\n\n#ifdef USE_TARGET_TANGENT_4\nin vec3 TARGET_TANGENT_4;\n#endif\n\n#ifdef USE_TARGET_TANGENT_5\nin vec3 TARGET_TANGENT_5;\n#endif\n\n#ifdef USE_TARGET_TANGENT_6\nin vec3 TARGET_TANGENT_6;\n#endif\n\n#ifdef USE_TARGET_TANGENT_7\nin vec3 TARGET_TANGENT_7;\n#endif\n\n\n#if defined(USE_TARGET_POSITION_0) || defined(USE_TARGET_NORMAL_0) || defined(USE_TARGET_TANGENT_0)\n#define USE_MORPHING\n#ifndef NUM_MORPHS\n#define NUM_MORPHS 8\n#endif\n\nuniform float targetWeights[NUM_MORPHS];\n\nvec4 getTargetPosition() {\n  vec4 pos = vec4(0);\n\n#ifdef USE_TARGET_POSITION_0\n  pos.xyz += targetWeights[0] * TARGET_POSITION_0;\n#endif\n\n#ifdef USE_TARGET_POSITION_1\n  pos.xyz += targetWeights[1] * TARGET_POSITION_1;\n#endif\n\n#ifdef USE_TARGET_POSITION_2\n  pos.xyz += targetWeights[2] * TARGET_POSITION_2;\n#endif\n\n#ifdef USE_TARGET_POSITION_3\n  pos.xyz += targetWeights[3] * TARGET_POSITION_3;\n#endif\n\n#ifdef USE_TARGET_POSITION_4\n  pos.xyz += targetWeights[4] * TARGET_POSITION_4;\n#endif\n\n#ifdef USE_TARGET_POSITION_5\n  pos.xyz += targetWeights[5] * TARGET_POSITION_5;\n#endif\n\n#ifdef USE_TARGET_POSITION_6\n  pos.xyz += targetWeights[6] * TARGET_POSITION_6;\n#endif\n\n#ifdef USE_TARGET_POSITION_7\n  pos.xyz += targetWeights[7] * TARGET_POSITION_7;\n#endif\n\n  return pos;\n}\n\nvec3 getTargetNormal() {\n  vec3 normal = vec3(0);\n\n#ifdef USE_TARGET_NORMAL_0\n  normal += targetWeights[0] * TARGET_NORMAL_0;\n#endif\n\n#ifdef USE_TARGET_NORMAL_1\n  normal += targetWeights[1] * TARGET_NORMAL_1;\n#endif\n\n#ifdef USE_TARGET_NORMAL_2\n  normal += targetWeights[2] * TARGET_NORMAL_2;\n#endif\n\n#ifdef USE_TARGET_NORMAL_3\n  normal += targetWeights[3] * TARGET_NORMAL_3;\n#endif\n\n#ifdef USE_TARGET_NORMAL_4\n  normal += targetWeights[4] * TARGET_NORMAL_4;\n#endif\n\n#ifdef USE_TARGET_NORMAL_5\n  normal += targetWeights[5] * TARGET_NORMAL_5;\n#endif\n\n#ifdef USE_TARGET_NORMAL_6\n  normal += targetWeights[6] * TARGET_NORMAL_6;\n#endif\n\n#ifdef USE_TARGET_NORMAL_7\n  normal += targetWeights[7] * TARGET_NORMAL_7;\n#endif\n\n  return normal;\n}\n\nvec3 getTargetTangent() {\n  vec3 tangent = vec3(0);\n\n#ifdef USE_TARGET_TANGENT_0\n  tangent += targetWeights[0] * TARGET_TANGENT_0;\n#endif\n\n#ifdef USE_TARGET_TANGENT_1\n  tangent += targetWeights[1] * TARGET_TANGENT_1;\n#endif\n\n#ifdef USE_TARGET_TANGENT_2\n  tangent += targetWeights[2] * TARGET_TANGENT_2;\n#endif\n\n#ifdef USE_TARGET_TANGENT_3\n  tangent += targetWeights[3] * TARGET_TANGENT_3;\n#endif\n\n#ifdef USE_TARGET_TANGENT_4\n  tangent += targetWeights[4] * TARGET_TANGENT_4;\n#endif\n\n#ifdef USE_TARGET_TANGENT_5\n  tangent += targetWeights[5] * TARGET_TANGENT_5;\n#endif\n\n#ifdef USE_TARGET_TANGENT_6\n  tangent += targetWeights[6] * TARGET_TANGENT_6;\n#endif\n\n#ifdef USE_TARGET_TANGENT_7\n  tangent += targetWeights[7] * TARGET_TANGENT_7;\n#endif\n\n  return tangent;\n}\n\n#endif\n\n\nattribute vec3 POSITION;\nvarying vec3 vPosition;\n\nvec4 getPosition(void) {\n  vec4 pos = vec4(POSITION, 1.0);\n\n#ifdef USE_MORPHING\n    pos += getTargetPosition();\n#endif\n#ifdef USE_SKINNING\n    pos = getSkinMatrix() * pos;\n#endif\n\n  return pos;\n}\n\n#ifdef USE_NORMAL\nattribute vec3 NORMAL;\n\n#ifdef USE_TANGENT\nattribute vec4 TANGENT;\nvarying mat3 vTBN;\n\nvec3 getTangent() {\n  vec3 tan = TANGENT.xyz;\n\n#ifdef USE_MORPHING\n  tan += getTargetTangent();\n#endif\n#ifdef USE_SKINNING\n  tan = mat3(getSkinMatrix()) * tan;\n#endif\n\n  return normalize(tan);\n}\n#else\nvarying vec3 vNormal;\n#endif\n\nvec3 getNormal() {\n  vec3 norm = NORMAL;\n\n#ifdef USE_MORPHING\n    norm += getTargetNormal();\n#endif\n#ifdef USE_SKINNING\n    norm = mat3(getSkinNormalMatrix()) * norm;\n#endif\n\n  return normalize(norm);\n}\n\n#endif\n\nvoid main(void) {\n  vec4 pos = model * getPosition();\n  vPosition = pos.xyz / pos.w;\n\n#ifdef USE_NORMAL\n#ifdef USE_TANGENT\n  vec3 tan = getTangent();\n  vec3 normW = normalize(normalMatrix * getNormal());\n  vec3 tanW = normalize(normalMatrix * tan);\n  vec3 bitanW = cross(normW, tanW) * TANGENT.w;\n  vTBN = mat3(tanW, bitanW, normW);\n#else\n  vNormal = normalize(normalMatrix * NORMAL);\n#endif\n#endif\n\n#if defined(USE_COLOR_VEC4)\n  vColor0 = COLOR_0;\n#elif defined(USE_COLOR_VEC3)\n  vColor0 = vec4(COLOR_0, 1.0);\n#endif\n\n  vTexCoord0 = vec2(0.0, 0.0);\n  vTexCoord1 = vec2(0.0, 0.0);\n#ifdef USE_TEXCOORD_0\n  vTexCoord0 = TEXCOORD_0;\n#endif\n#ifdef USE_TEXCOORD_1\n  vTexCoord1 = TEXCOORD_1;\n#endif\n\n  gl_Position = viewProj * pos;\n  gl_PointSize = 1.0;\n}\n",frag:g+"\n#ifdef GL_OES_standard_derivatives\n  #extension GL_OES_standard_derivatives : enable\n#endif\n\nprecision highp float;\n\nuniform float alphaCutoff;\nuniform vec3 cameraPosition;\n\nvarying vec3 vPosition;\n\n\nconst float GAMMA = 2.2;\n\nvec3 linearTosRGB(vec3 color) {\n  return pow(color, vec3(1.0/GAMMA));\n}\n\nvec3 sRGBToLinear(vec3 srgbIn) {\n  return vec3(pow(srgbIn.xyz, vec3(GAMMA)));\n}\n\nvec4 sRGBToLinear(vec4 srgbIn) {\n  return vec4(sRGBToLinear(srgbIn.xyz), srgbIn.w);\n}\n\n\nconst float PI = 3.141592653589793;\n\nvec3 specularF(vec3 r0, vec3 r90, float vDotH) {\n  return r0 + (r90 - r0) * pow(clamp(1.0 - vDotH, 0.0, 1.0), 5.0);\n}\n\nfloat specularD(float aSqr, float nDotH) {\n  float f = (nDotH * nDotH) * (aSqr - 1.0) + 1.0;\n  return aSqr / (PI * f * f);\n}\n\nfloat specularV(float aSqr, float nDotL, float nDotV) {\n  float gl = 1.0 / (nDotL + sqrt(aSqr + (1.0 - aSqr) * (nDotL * nDotL)));\n  float gv = 1.0 / (nDotV + sqrt(aSqr + (1.0 - aSqr) * (nDotV * nDotV)));\n  return gl * gv;\n}\n\nfloat specularBRDF(float aSqr, float nDotL, float nDotV, float nDotH) {\n  return specularV(aSqr, nDotL, nDotV) * specularD(aSqr, nDotH);\n}\n\nvec3 diffuseBRDF(vec3 color) {\n  return color / PI;\n}\n\n\nvarying vec2 vTexCoord0;\nvarying vec2 vTexCoord1;\n\nstruct TextureInfo {\n  sampler2D tex;\n  float texCoord;\n  float scale;\n};\n\nvec2 getTexCoord(TextureInfo tex) {\n  return mix(vTexCoord0, vTexCoord1, step(1.0, tex.texCoord));\n}\n\nvec4 texture(TextureInfo tex) {\n  return texture2D(tex.tex, getTexCoord(tex));\n}\n\nvec4 texture(TextureInfo tex, vec4 defaultValue) {\n  return mix(defaultValue, texture2D(tex.tex, getTexCoord(tex)), step(0.0, tex.texCoord));\n}\n\n\nuniform TextureInfo normalTexture;\n\n#ifdef USE_NORMAL\n#ifdef USE_TANGENT\nvarying mat3 vTBN;\n#else\nvarying vec3 vNormal;\n#endif\n#endif\n\nstruct NormalInfo {\n  vec3 ng;\n  vec3 n;\n  vec3 t;\n  vec3 b;\n};\n\nNormalInfo getNormalInfo(vec3 v) {\n  vec2 UV = getTexCoord(normalTexture);\n  vec3 uvDx = dFdx(vec3(UV, 0.0));\n  vec3 uvDy = dFdy(vec3(UV, 0.0));\n\n  vec3 t_ = (uvDy.t * dFdx(v) - uvDx.t * dFdy(v)) / (uvDx.s * uvDy.t - uvDy.s * uvDx.t);\n\n  vec3 n, t, b, ng;\n\n#ifdef USE_TANGENT\n  t = normalize(vTBN[0]);\n  b = normalize(vTBN[1]);\n  ng = normalize(vTBN[2]);\n#else\n#ifdef USE_NORMAL\n  ng = normalize(vNormal);\n#else\n  ng = normalize(cross(dFdx(v), dFdy(v)));\n#endif\n  t = normalize(t_ - ng * dot(ng, t_));\n  b = cross(ng, t);\n#endif\n\n  if (gl_FrontFacing == false) {\n    t *= -1.0;\n    b *= -1.0;\n    ng *= -1.0;\n  }\n\n  n = ng;\n  if (normalTexture.texCoord >= 0.0) {\n    n = texture(normalTexture).rgb * 2.0 - vec3(1.0);\n    n *= vec3(normalTexture.scale, normalTexture.scale, 1.0);\n    n = mat3(t, b, ng) * normalize(n);\n  }\n\n  NormalInfo info;\n  info.ng = ng;\n  info.t = t;\n  info.b = b;\n  info.n = n;\n  return info;\n}\n\n\nconst float MIN_ROUGHNESS = 0.04;\n\n#if defined(USE_COLOR_VEC4) || defined(USE_COLOR_VEC3)\nvarying vec4 vColor0;\n#endif\n\nuniform vec4 baseColorFactor;\nuniform TextureInfo baseColorTexture;\n\nuniform float metallicFactor;\nuniform float roughnessFactor;\nuniform TextureInfo metallicRoughnessTexture;\n\nuniform TextureInfo occlusionTexture;\n\nuniform vec3 emissiveFactor;\nuniform TextureInfo emissiveTexture;\n\nvec4 getVertexColor() {\n  vec4 color = vec4(1.0);\n#if defined(USE_COLOR_VEC4) || defined(USE_COLOR_VEC3)\n  color = vColor0;\n#endif\n  return color;\n}\n\nvec4 getBaseColor() {\n  vec4 baseColor = vec4(1.0);\n\n  baseColor *= baseColorFactor;\n  baseColor *= sRGBToLinear(texture(baseColorTexture, vec4(1.0)));\n\n  return baseColor * getVertexColor();\n}\n\nvec2 getMetallicRoughness() {\n  vec4 mrTex = texture(metallicRoughnessTexture, vec4(1.0));\n  return vec2(\n    clamp(metallicFactor * mrTex.b, 0.0, 1.0),\n    clamp(roughnessFactor * mrTex.g, MIN_ROUGHNESS, 1.0)\n  );\n}\n\nfloat getOcculsion() {\n  return texture(occlusionTexture, vec4(1.0)).r;\n}\n\nvec3 getEmissiveFactor() {\n  return emissiveFactor * texture(emissiveTexture, vec4(0.0)).rgb;\n}\n\n\n\nvoid main () {\n  vec4 baseColor = getBaseColor();\n#ifdef ALPHAMODE_OPAQUE\n  baseColor.a = 1.0;\n#endif\n\n  vec3 v = normalize(cameraPosition - vPosition);\n  NormalInfo normalInfo = getNormalInfo(vPosition);\n  vec3 n = normalInfo.n;\n\n  vec3 reflection = -normalize(reflect(v, n));\n  float nDotV = clamp(abs(dot(n, v)), 0.001, 1.0);\n\n  vec2 metallicRoughness = getMetallicRoughness();\n  float metallic = metallicRoughness[0];\n  float roughness = metallicRoughness[1];\n  float alphaRoughness = roughness * roughness;\n  float aSqr = alphaRoughness * alphaRoughness;\n\n  vec3 f0 = vec3(0.04);\n  vec3 diffuseColor = baseColor.rgb * (vec3(1.0) - f0) * (1.0 - metallic);\n  vec3 specularColor = mix(f0, baseColor.rgb, metallic);\n\n  float r0 = max(max(specularColor.r, specularColor.g), specularColor.b);\n  float r90 = clamp(r0 * 25.0, 0.0, 1.0);\n  vec3 specularEnvR0 = specularColor.rgb;\n  vec3 specularEnvR90 = vec3(1.0, 1.0, 1.0) * r90;\n\n  vec3 diffuseFinal = vec3(0.0);\n  vec3 specularFinal = vec3(0.0);\n\n  vec3 lightDirs[2];\n  lightDirs[0] = vec3(0.5, -0.707107, -0.5);\n  lightDirs[1] = vec3(-0.5, 0.707107, 0.5);\n  vec4 lightColors[2];\n  lightColors[0] = vec4(1.0, 1.0, 1.0, 1.0);\n  lightColors[1] = vec4(1.0, 1.0, 1.0, 0.5);\n\n  for (int i = 0; i < 2; ++i) {\n    vec3 intensity = lightColors[i].rgb * lightColors[i].a;\n    vec3 l = normalize(-lightDirs[i]);\n    vec3 h = normalize(l + v);\n    float nDotL = clamp(dot(n, l), 0.001, 1.0);\n    float nDotH = clamp(dot(n, h), 0.0, 1.0);\n    float vDotH = clamp(dot(v, h), 0.0, 1.0);\n  \n    vec3 F = specularF(specularEnvR0, specularEnvR90, vDotH);\n    vec3 diffuse = (1.0 - F) * diffuseBRDF(diffuseColor);\n    vec3 specular = max(vec3(0.0), F * specularBRDF(aSqr, nDotL, nDotV, nDotH));\n  \n    diffuseFinal += intensity * nDotL * diffuse;\n    specularFinal += intensity * nDotL * specular;\n  }\n\n  vec4 ambient = vec4(0.1);\n\n  vec3 ambientDiffuse = ambient.rgb * diffuseBRDF(diffuseColor);\n  diffuseFinal += ambientDiffuse;\n\n  vec3 colorFinal = diffuseFinal + specularFinal;\n\n  float ao = getOcculsion();\n  colorFinal = mix(colorFinal, colorFinal * ao, occlusionTexture.scale);\n\n  vec3 emissive = getEmissiveFactor();\n  colorFinal += emissive;\n\n#ifdef ALPHAMODE_MASK\n  if (baseColor.a < alphaCutoff) {\n    discard;\n  }\n  baseColor.a = 1.0;\n#else\n  alphaCutoff;\n#endif\n\n  gl_FragColor = vec4(linearTosRGB(colorFinal), baseColor.a);\n}\n",buffers:c,indexFormat:u,mode:a,depth:{compare:515,writeEnabled:!0},raster:{cullMode:l?0:1029},uniforms:{model:{type:1,format:35676},viewProj:{type:1,format:35676},normalMatrix:{type:1,format:35675},cameraPosition:{type:1,format:35665},alphaCutoff:{type:1,format:p},baseColorFactor:{type:1,format:35666},"baseColorTexture.tex":{type:2,format:x},"baseColorTexture.texCoord":{type:1,format:p},metallicFactor:{type:1,format:p},roughnessFactor:{type:1,format:p},"metallicRoughnessTexture.tex":{type:2,format:x},"metallicRoughnessTexture.texCoord":{type:1,format:p},"normalTexture.tex":{type:2,format:x},"normalTexture.texCoord":{type:1,format:p},"normalTexture.scale":{type:1,format:p},emissiveFactor:{type:1,format:35665},"emissiveTexture.tex":{type:2,format:x},"emissiveTexture.texCoord":{type:1,format:p},"occlusionTexture.tex":{type:2,format:x},"occlusionTexture.texCoord":{type:1,format:p},"occlusionTexture.scale":{type:1,format:p}}}),o}function K(e,n,t){const r={alphaCutoff:0,baseColorFactor:[1,1,1,1],"baseColorTexture.tex":Z(e,n),"baseColorTexture.texCoord":-1,metallicFactor:1,roughnessFactor:1,"metallicRoughnessTexture.tex":Z(e,n),"metallicRoughnessTexture.texCoord":-1,"normalTexture.tex":Z(e,n),"normalTexture.texCoord":-1,"normalTexture.scale":1,emissiveFactor:[0,0,0],"emissiveTexture.tex":Z(e,n),"emissiveTexture.texCoord":-1,"occlusionTexture.tex":Z(e,n),"occlusionTexture.texCoord":-1,"occlusionTexture.scale":0},i=n.materials?.[t];if(i){if(i.alphaCutoff&&(r.alphaCutoff=i.alphaCutoff),i.pbrMetallicRoughness){const t=i.pbrMetallicRoughness;t.baseColorFactor&&(r.baseColorFactor=t.baseColorFactor),t.baseColorTexture&&(r["baseColorTexture.tex"]=Y(e,n,t.baseColorTexture.index),r["baseColorTexture.texCoord"]=t.baseColorTexture.texCoord||0),(t.metallicFactor||0===t.metallicFactor)&&(r.metallicFactor=t.metallicFactor),(t.roughnessFactor||0===t.roughnessFactor)&&(r.roughnessFactor=t.roughnessFactor),t.metallicRoughnessTexture&&(r["metallicRoughnessTexture.tex"]=Y(e,n,t.metallicRoughnessTexture.index),r["metallicRoughnessTexture.texCoord"]=t.metallicRoughnessTexture.texCoord||0)}i.normalTexture&&(r["normalTexture.tex"]=Y(e,n,i.normalTexture.index),r["normalTexture.texCoord"]=i.normalTexture.texCoord||0,r["normalTexture.scale"]=i.normalTexture.scale||1),i.emissiveFactor&&(r.emissiveFactor=i.emissiveFactor),i.emissiveTexture&&(r["emissiveTexture.tex"]=Y(e,n,i.emissiveTexture.index),r["emissiveTexture.texCoord"]=i.emissiveTexture.texCoord||0),i.occlusionTexture&&(r["occlusionTexture.tex"]=Y(e,n,i.occlusionTexture.index),r["occlusionTexture.texCoord"]=i.occlusionTexture.texCoord||0,r["occlusionTexture.scale"]=i.occlusionTexture.strength||1)}return r}function Q(e,n,t,r){const i=n.accessors?.[t];if(!i)return null;const o=n.bufferViews?.[i.bufferView];if(!o)return null;const a=W(o).bufferView;if(34963===r){let n=W(o).gpuBuffer;return n||(n=W(o).gpuBuffer=e.buffer({type:o.target||r,size:o.byteLength}).data(a),n)}const s=W(o).gpuBuffers=W(o).gpuBuffers||{},f=o.byteStride||4,l=(i.byteOffset||0)%f,c=(i.byteOffset||0)-l,u=i.count*(("VEC2"===(h=i.type)?2:"VEC3"===h?3:"VEC4"===h?4:0)*((g=i.componentType)===m?4:g===d?2:g===T?1:0));var h,g;const _=`${c},${u}`;if(s[_])return s[_];const v=new Uint8Array(a.buffer,(a.byteOffset||0)+c,u);return s[_]=e.buffer({type:o.target||r,size:u}).data(v)}function Y(e,n,t){const r=n.textures?.[t];if(!r)return Z(e,n);let i=W(r).texture;if(i)return i;let o=null;const a={wrapU:10497,wrapV:10497,magFilter:v.Linear,minFilter:v.Linear},s=n.images?.[r.source];s&&(o=W(s).image);const f=n.samplers?.[r.sampler];if(f){if(f.magFilter&&(a.magFilter=f.magFilter),f.minFilter)switch(f.minFilter){case E.Nearest:case E.NearestMipmapNearest:case E.NearestMipmapLinear:a.minFilter=E.Nearest;break;default:a.minFilter=E.Linear}f.wrapS&&(a.wrapU=f.wrapS),f.wrapT&&(a.wrapV=f.wrapT)}return i=W(r).texture=e.texture({size:o?[o.naturalWidth,o.naturalHeight]:[1,1]},a),i.data(o||new Uint8Array([1,1,1,1])),i}function Z(e,n){let t=W(n).blankTexture;return t||(t=W(n).blankTexture=e.texture({size:[1,1]}).data(new Uint8Array([1,1,1,1])),t)}function ee(e,n,t=!1){switch(e){case"VEC2":if(n===m)return 512;if(n===d)return t?66052:516;break;case"VEC3":if(n===m)return 768;break;case"VEC4":if(n===m)return 1024;if(n===T)return t?66562:1026;if(n===d)return t?66564:1028}return null}function ne(e){return(new TextDecoder).decode(e)}function te(e){return/^data:.*,.*$/i.test(e)||/^blob:.*$/i.test(e)}function re(e,n){return""===e?"":/^(https?:)?\/\//i.test(e)||te(e)?e:n+e}async function ie(e,n=oe){const t=e.uri?function(e){if(te(e))return"";const n=e.split("/");return n.pop(),n.length?n.join("/")+"/":""}(e.uri):"";let r=e.glTF,i=e.binaryChunk;if(!r&&e.uri)if(e.uri.match(/\.glb$/)){const t=function(e){let n,t,r,i=0;ArrayBuffer.isView(e)?(r=e.buffer,i=e.byteOffset):r=e;const o=new DataView(r,i,12);if(1179937895!==o.getUint32(0,!0))throw new Error("Invalid GLB format");const a=o.getUint32(4,!0);if(2!==a)throw new Error("Unsupported GLB version: "+a);const s=new DataView(r,i+12);let f=0;for(;f<s.byteLength;){const e=s.getUint32(f,!0),o=s.getUint32(f+4,!0);if(f+=8,1313821514===o){const t=new Uint8Array(r,i+12+f,e);n=JSON.parse(ne(t))}else 5130562===o&&(t=new Uint8Array(r,i+12+f,e));f+=e}if(!n)throw new Error("Invalid GLB format: missing JSON content");if(!n.asset||"2.0"!==n.asset.minVersion&&"2.0"!==n.asset.version)throw new Error("Unsupported glTF version: 2.0 required");return{glTF:n,binaryChunk:t}}(await n(e.uri,"bin"));r=t.glTF,i=t.binaryChunk}else r=JSON.parse(await n(e.uri,"str"));if(!r)throw new Error("Failed to load glTF JSON");const o=await async function(e,n,t,r){if(e.buffers)for(let i=0;i<e.buffers?.length;++i){const o=e.buffers[i];if(W(o).buffer)continue;let a;const s=o.uri;if(s)a=await t(re(s,r),"bin");else{if(0!==i||!n)throw new Error("Invalid glTF: missing uri for buffer "+i);a=n}W(o).buffer=a}if(e.bufferViews)for(let n=0;n<e.bufferViews?.length;++n){const t=e.bufferViews[n];if(W(t).bufferView)continue;const r=e.buffers?.[t.buffer];if(!r)throw new Error("Invalid glTF: invalid buffer for bufferView "+n);const i=W(r).buffer,o=new Uint8Array(i.buffer,(i.byteOffset||0)+(t.byteOffset||0),t.byteLength);W(t).bufferView=o}return e}(r,i,n,t);return await async function(e,n,t){if(e.images)for(let r=0;r<e.images.length;++r){const i=e.images[r];if(W(i).image)continue;const o=i.bufferView;let a,s=!1,f=i.uri;if(o){const n=e.bufferViews?.[o];if(!n)throw new Error("Invalid glTF: invalid bufferView for image "+r);const t=new Blob([W(n).bufferView],{type:i.mimeType});f=URL.createObjectURL(t),s=!0}if(!f)throw new Error("Invalid glTF: missing uri or bufferView for image "+r);try{a=await n(re(f,t),"img")}finally{s&&URL.revokeObjectURL(f)}W(i).image=a}return e}(o,n,t)}function oe(e,n){return"bin"===n?fetch(e).then((e=>e.arrayBuffer())).then((e=>new Uint8Array(e))):"img"===n?new Promise(((n,t)=>{const r=new Image;r.crossOrigin="anonymous",r.onerror=()=>t(new Error("Failed to load: "+e)),r.onload=()=>n(r),r.src=e})):fetch(e).then((e=>e.text()))}const ae=new URLSearchParams(window.location.search),se=document.querySelector("canvas"),fe=se.parentElement;let le=null;const ce=((e,n)=>{const t=e.getContext("webgl",{powerPreference:"low-power"});return t?new w(t):null})(se);if(ce.gl.getExtension("OES_standard_derivatives"),!ce)throw new Error("WebGL is unsupported");const ue="https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/63f026b2aa957d3e8207f6dd798608993e33fb0d/2.0";function Te(){if(!le)return;const e=ae.get("camera"),n=ae.get("scene"),r=((null!==n&&parseInt(n))??le.scene)||0;!function(e,n,r={}){const i=n.nodes,o=n.scenes?.[(r.scene??n.scene)||0]?.nodes;if(!i||!o)return;const s=B(n);let c=k,T=k,d=q;if(r.camera){const i=n.cameras?.[r.camera.index||0];i&&(c=i.extras?.view||k,m=J,h=i,g=e.canvas.width/e.canvas.height,h?.orthographic?function(e,n,t,r,i,o,a){var s=1/(n-t),f=1/(r-i),l=1/(o-a);e[0]=-2*s,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=-2*f,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=2*l,e[11]=0,e[12]=(n+t)*s,e[13]=(i+r)*f,e[14]=(a+o)*l,e[15]=1}(m,-h.orthographic.xmag,h.orthographic.xmag,-h.orthographic.xmag/(g||1),h.orthographic.xmag/(g||1),h.orthographic.znear,h.orthographic.zfar):h?.perspective?l(m,h.perspective.yfov,g||h.perspective.aspectRatio||1,h.perspective.znear,h.perspective.zfar||1/0):function(e){e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1}(m),T=m,d=i.extras?.translation||q),r.camera.model&&(d=t(r.camera.model[12],r.camera.model[13],r.camera.model[14]),c=f(a(),r.camera.model)),T=r.camera.proj||T}var m,h,g;const _={cameraPosition:d,viewProj:u(J,T,c)},v=e.pass(),E=e.render(v);for(let t=0;t<s.length;++t)$(e,E,n,i[s[t]],_);E.end(),v.destroy()}(ce,le,{scene:r,camera:null!==e&&le.cameras?{index:parseInt(e)}:de(le,r,ce.canvas.width/ce.canvas.height)})}function de(e,o,s){const f=t(1,2,2);(function(e,n){var t=n[0],r=n[1],i=n[2],o=t*t+r*r+i*i;o>0&&(o=1/Math.sqrt(o)),e[0]=n[0]*o,e[1]=n[1]*o,e[2]=n[2]*o})(f,f),B(e,o);const[u,T]=function(e,t,r,i){for(let n=0;n<3;++n)e[n]=1/0,t[n]=-1/0;const o=r.scenes?.[i];if(!o)return[e,t];let a=(o.nodes||[]).slice();for(;a.length>0;){const i=r.nodes?.[a.pop()];if(!i)continue;a=a.concat(i.children||[]);const o=r.meshes?.[i.mesh];if(o&&o.primitives)for(const a of o.primitives){const o=r.accessors?.[a.attributes.POSITION];if(!o)continue;const s=n(),f=n();j(s,f,o,W(i).model||P);for(const n of[0,1,2])e[n]=Math.min(e[n],s[n]),t[n]=Math.max(t[n],f[n])}}return[e,t]}(n(),n(),e,o),d=Math.max(T[0]-u[0],T[1]-u[1]),m=Math.PI/4,h=m*s,g=d/2/Math.tan(m/2),_=d/2/Math.tan(h/2),v=Math.max(_,g);i(f,f,1.2*v);const E=(x=u,N=(p=T)[0]-x[0],O=p[1]-x[1],A=p[2]-x[2],Math.hypot(N,O,A));var x,p,N,O,A;let b=v+6*E,R=v-6*E;R=Math.max(R,b/1e4);const S=n();return r(S,u,T),i(S,S,.5),{model:c(a(),f,S,t(0,1,0)),proj:l(a(),m,s,R,b)}}function me(){const e=window.devicePixelRatio||1,n=fe.clientWidth,t=fe.clientHeight;se.width=n*e,se.height=t*e,se.style.width=`${n}px`,se.style.height=`${t}px`,Te()}window.addEventListener("resize",me,!1),me(),async function(){let e=ae.get("url");if(!e){const n=await(await fetch(`${ue}/model-index.json`)).json(),t=ae.get("model")||"DamagedHelmet",r=ae.get("variant")||"glTF",i=n.find((e=>e.name===t));e=`${ue}/${t}/${r}/${i.variants[r]}`}const n=await ie({uri:e});le=n,Te()}()})();