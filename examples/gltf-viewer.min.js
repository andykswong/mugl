(()=>{var e="undefined"!=typeof Float32Array?Float32Array:Array;function t(){var t=new e(3);return e!=Float32Array&&(t[0]=0,t[1]=0,t[2]=0),t}function n(t,n,r){var o=new e(3);return o[0]=t,o[1]=n,o[2]=r,o}function r(e,t,n){return e[0]=t[0]+n[0],e[1]=t[1]+n[1],e[2]=t[2]+n[2],e}function o(e,t,n){return e[0]=t[0]*n,e[1]=t[1]*n,e[2]=t[2]*n,e}function i(e,t,n){var r=t[0],o=t[1],i=t[2],a=n[3]*r+n[7]*o+n[11]*i+n[15];return a=a||1,e[0]=(n[0]*r+n[4]*o+n[8]*i+n[12])/a,e[1]=(n[1]*r+n[5]*o+n[9]*i+n[13])/a,e[2]=(n[2]*r+n[6]*o+n[10]*i+n[14])/a,e}Math.random,Math.PI,Math.hypot||(Math.hypot=function(){for(var e=0,t=arguments.length;t--;)e+=arguments[t]*arguments[t];return Math.sqrt(e)}),t();const a=5120,s=5121,l=5122,f=5123,c=5126,u=6408,h=9729,g=36160,m={Nearest:9728,Linear:h},d={...m,NearestMipmapNearest:9984,NearestMipmapLinear:9986,LinearMipmapNearest:9985,LinearMipmapLinear:9987},p=3553,v=c,b=35676,x=[c,a,s,l,f],T=[4,1,1,2,2],y=255,O=e=>T[e&y]*w(e),w=e=>e>>8&y,C=e=>x[e&y],S=e=>!!(e>>16),N=e=>e-5123+2,_={},L=[];class E{constructor(e,t){this.gl=e,this.type=34962,this.usage=35044,this.size=0,Object.assign(this,t),e.bindBuffer(this.type,this.glb=e.createBuffer()),e.bufferData(this.type,this.size,this.usage)}data(e,t=0){return this.gl.bindBuffer(this.type,this.glb),this.gl.bufferSubData(this.type,t,e),this}destroy(){this.gl.deleteBuffer(this.glb)}}class M{constructor(e,t,n=_){this.gl=e,this.type=3553,this.format=263169,this.wrapU=33071,this.wrapV=33071,this.magFilter=h,this.minFilter=h,Object.assign(this,t,n),this.glt=this.glrb=null;const[r,o]=this.size;this.format<=197381||(e.bindTexture(this.type,this.glt=e.createTexture()),e.texParameteri(this.type,10241,this.minFilter),e.texParameteri(this.type,10240,this.magFilter),e.texParameteri(this.type,10242,this.wrapU),e.texParameteri(this.type,10243,this.wrapV),e.texImage2D(this.type,0,u,r,o,0,u,s,null))}data(e,[t=0,n=0]=L,[r=this.size[0]-t,o=this.size[1]-n]=L){return this.gl.bindTexture(this.type,this.glt),ArrayBuffer.isView(e)?this.gl.texSubImage2D(this.type,0,t,n,r,o,u,s,e):this.gl.texSubImage2D(this.type,0,t,n,u,s,e),this}mipmap(){return this.gl.bindTexture(this.type,this.glt),this.gl.generateMipmap(this.type),this}destroy(){this.gl.deleteTexture(this.glt),this.gl.deleteRenderbuffer(this.glrb)}}class I{constructor(e,t=_){this.gl=e,this.color=[],this.depth=null,this.clearColor=!1,this.clearDepth=!1,this.clearStencil=!1,Object.assign(this,t),this.glfb=null,this.color[0]&&(e.bindFramebuffer(g,this.glfb=e.createFramebuffer()),e.framebufferTexture2D(g,36064,this.color[0].tex.type,this.color[0].tex.glt,0),this.depth&&e.framebufferRenderbuffer(g,36096,36161,this.depth.tex.glrb))}destroy(){this.gl.deleteFramebuffer(this.glfb)}resolve(){}}class F{constructor(e,t){this.gl=e,this.mode=4,this.indexFormat=f,Object.assign(this,t);let n=0;this.glp=function(e,t,n,r){const o=R(e,35633,t),i=R(e,35632,n),a=e.createProgram();e.attachShader(a,o),e.attachShader(a,i);for(const{attrs:t}of r)for(const n of t)e.bindAttribLocation(a,n.shaderLoc,n.name);return e.linkProgram(a),e.deleteShader(o),e.deleteShader(i),a}(e,t.vert,t.frag,this.buffers=t.buffers.map((({attrs:e,stride:t,instanced:r=!1})=>{const o=Array(e.length);let i=0;for(let t=0;t<e.length;++t,++n){const{name:r,format:a,offset:s=i,shaderLoc:l=n}=e[t];o[t]={name:r,format:a,offset:s,shaderLoc:l},i=Math.max(i,s)+O(a)}return{attrs:o,stride:t||i,instanced:r}})))}destroy(){this.gl.deleteProgram(this.glp)}}function A(e,t,n){n?e.enable(t):e.disable(t)}function R(e,t,n){const r=e.createShader(t);return e.shaderSource(r,n),e.compileShader(r),r}class U{constructor(e){this.gl=e,this.webgl2=!1,this.exts={},this.canvas=e.canvas,this.rctx=new D(e,this.feature("ANGLE_instanced_arrays"))}buffer(e){return new E(this.gl,e)}texture(e,t){return new M(this.gl,e,t)}pipeline(e){return new F(this.gl,e)}pass(e){return new I(this.gl,e)}render(e){let{width:t,height:n}=this.gl.canvas;this.gl.viewport(0,0,t,n);let r=0;return e.clearColor&&(r|=16384,this.gl.clearColor(...e.clearColor),this.gl.colorMask(!0,!0,!0,!0)),!1!==e.clearDepth&&(r|=256,this.gl.clearDepth(e.clearDepth),this.gl.depthMask(!0)),r&&this.gl.clear(r),this.rctx}feature(e){return this.exts[e]=this.exts[e]||this.gl.getExtension(e)}reset(){this.rctx.reset()}}class D{constructor(e,t){this.gl=e,this.inst=t,this.reset()}reset(){this.state={pipeObj:null,stencilRef:0}}pipeline(e){if(this.state.pipeObj!==e){this.state.pipeObj=e,this.gl.useProgram(e.glp),function(e,t,n=0){const{blend:r,depth:o,stencil:i,raster:a}=t;if(a&&(A(e,32926,!!a.alphaToCoverage),A(e,2884,!!a.cullMode),A(e,32823,!(!a.depthBiasSlopeScale&&!a.depthBias)),e.polygonOffset(a.depthBiasSlopeScale||0,a.depthBias||0),a.cullMode&&e.cullFace(a.cullMode),e.frontFace(a.frontFace||2305)),A(e,2929,!!o),o&&(e.depthMask(!!o.writeEnabled),e.depthFunc(o.compare||519)),A(e,3042,!!r),r){const t=r.colorMask||y;e.colorMask(!!(1&t),!!(2&t),!!(4&t),!!(8&t)),e.blendFuncSeparate(r.srcFactorRGB||1,r.dstFactorRGB||0,r.srcFactorAlpha||1,r.dstFactorAlpha||0),e.blendEquationSeparate(r.opRGB||32774,r.opAlpha||32774)}}(this.gl,e,this.state.stencilRef);for(let e=0;e<8;++e)this.gl.disableVertexAttribArray(e);for(const{attrs:t}of e.buffers)for(const{shaderLoc:e}of t)this.gl.enableVertexAttribArray(e)}return this}index({glb:e}){return this.gl.bindBuffer(34963,e),this}vertex(e,{glb:t}){const{attrs:n,stride:r,instanced:o}=this.state.pipeObj.buffers[e];this.gl.bindBuffer(34962,t);for(const{format:e,offset:t,shaderLoc:i}of n)this.gl.vertexAttribPointer(i,w(e),C(e),S(e),r,t),this.inst?.vertexAttribDivisorANGLE(i,o?1:0);return this}uniforms(e){let t=0;for(const n in e){const r=e[n],o=this.state.pipeObj.uniforms[n].format,i=this.gl.getUniformLocation(this.state.pipeObj.glp,n);if(o&&i)if(r.length)switch(o){case 35676:this.gl.uniformMatrix4fv(i,!1,r);break;case 35675:this.gl.uniformMatrix3fv(i,!1,r);break;case 35666:this.gl.uniform4fv(i,r);break;case 35665:this.gl.uniform3fv(i,r);break;case 35664:this.gl.uniform2fv(i,r);break;default:this.gl.uniform1fv(i,r)}else"number"==typeof r?this.gl.uniform1f(i,r):(this.gl.activeTexture(33984+t),this.gl.bindTexture(r.type,r.glt),this.gl.uniform1i(i,t++))}return this}draw(e,t=1,n=0){const{mode:r}=this.state.pipeObj;return t>1?this.inst?.drawArraysInstancedANGLE(r,n,e,t):this.gl.drawArrays(r,n,e),this}drawIndexed(e,t=1,n=0){const{indexFormat:r,mode:o}=this.state.pipeObj;return t>1?this.inst?.drawElementsInstancedANGLE(o,e,r,n*N(r),t):this.gl.drawElements(o,e,r,n*N(r)),this}viewport(e,t,n,r){return this.gl.viewport(e,t,n,r),this}scissor(e,t,n,r){return this}blendColor(e){return this.gl.blendColor(...e),this}stencilRef(e){return this}end(){}}function P(){var t=new e(16);return e!=Float32Array&&(t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[11]=0,t[12]=0,t[13]=0,t[14]=0),t[0]=1,t[5]=1,t[10]=1,t[15]=1,t}function G(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15],e}function B(e,t){var n=t[0],r=t[1],o=t[2],i=t[3],a=t[4],s=t[5],l=t[6],f=t[7],c=t[8],u=t[9],h=t[10],g=t[11],m=t[12],d=t[13],p=t[14],v=t[15],b=n*s-r*a,x=n*l-o*a,T=n*f-i*a,y=r*l-o*s,O=r*f-i*s,w=o*f-i*l,C=c*d-u*m,S=c*p-h*m,N=c*v-g*m,_=u*p-h*d,L=u*v-g*d,E=h*v-g*p,M=b*E-x*L+T*_+y*N-O*S+w*C;return M?(M=1/M,e[0]=(s*E-l*L+f*_)*M,e[1]=(o*L-r*E-i*_)*M,e[2]=(d*w-p*O+v*y)*M,e[3]=(h*O-u*w-g*y)*M,e[4]=(l*N-a*E-f*S)*M,e[5]=(n*E-o*N+i*S)*M,e[6]=(p*T-m*w-v*x)*M,e[7]=(c*w-h*T+g*x)*M,e[8]=(a*L-s*N+f*C)*M,e[9]=(r*N-n*L-i*C)*M,e[10]=(m*O-d*T+v*b)*M,e[11]=(u*T-c*O-g*b)*M,e[12]=(s*S-a*_-l*C)*M,e[13]=(n*_-r*S+o*C)*M,e[14]=(d*x-m*y-p*b)*M,e[15]=(c*y-u*x+h*b)*M,e):null}function V(e,t,n,r,o){var i,a=1/Math.tan(t/2);return e[0]=a/n,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=a,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=-1,e[12]=0,e[13]=0,e[15]=0,null!=o&&o!==1/0?(i=1/(r-o),e[10]=(o+r)*i,e[14]=2*o*r*i):(e[10]=-1,e[14]=-2*r),e}function z(e,t,n,r){var o=t[0],i=t[1],a=t[2],s=r[0],l=r[1],f=r[2],c=o-n[0],u=i-n[1],h=a-n[2],g=c*c+u*u+h*h;g>0&&(c*=g=1/Math.sqrt(g),u*=g,h*=g);var m=l*h-f*u,d=f*c-s*h,p=s*u-l*c;return(g=m*m+d*d+p*p)>0&&(m*=g=1/Math.sqrt(g),d*=g,p*=g),e[0]=m,e[1]=d,e[2]=p,e[3]=0,e[4]=u*p-h*d,e[5]=h*m-c*p,e[6]=c*d-u*m,e[7]=0,e[8]=c,e[9]=u,e[10]=h,e[11]=0,e[12]=o,e[13]=i,e[14]=a,e[15]=1,e}var H=function(e,t,n){var r=t[0],o=t[1],i=t[2],a=t[3],s=t[4],l=t[5],f=t[6],c=t[7],u=t[8],h=t[9],g=t[10],m=t[11],d=t[12],p=t[13],v=t[14],b=t[15],x=n[0],T=n[1],y=n[2],O=n[3];return e[0]=x*r+T*s+y*u+O*d,e[1]=x*o+T*l+y*h+O*p,e[2]=x*i+T*f+y*g+O*v,e[3]=x*a+T*c+y*m+O*b,x=n[4],T=n[5],y=n[6],O=n[7],e[4]=x*r+T*s+y*u+O*d,e[5]=x*o+T*l+y*h+O*p,e[6]=x*i+T*f+y*g+O*v,e[7]=x*a+T*c+y*m+O*b,x=n[8],T=n[9],y=n[10],O=n[11],e[8]=x*r+T*s+y*u+O*d,e[9]=x*o+T*l+y*h+O*p,e[10]=x*i+T*f+y*g+O*v,e[11]=x*a+T*c+y*m+O*b,x=n[12],T=n[13],y=n[14],O=n[15],e[12]=x*r+T*s+y*u+O*d,e[13]=x*o+T*l+y*h+O*p,e[14]=x*i+T*f+y*g+O*v,e[15]=x*a+T*c+y*m+O*b,e};function k(){var t=new e(9);return e!=Float32Array&&(t[1]=0,t[2]=0,t[3]=0,t[5]=0,t[6]=0,t[7]=0),t[0]=1,t[4]=1,t[8]=1,t}function j(e){return e.extras||(e.extras={}),e.extras}function $(e,t){let n=j(t).input||null;if(!n){const r=e.accessors?.[t.input];if(r){const{buffer:o,byteOffset:i=0}=J(e,r);j(t).input=n=new Float32Array(o.buffer,i+o.byteOffset,(o.byteLength-i)/4)}}return n}function W(e,t){let n=j(t).output||null;if(!n){const r=e.accessors?.[t.output];if(r){const{buffer:o,byteOffset:i=0}=J(e,r);let c=Float32Array;switch(r.componentType){case a:c=Int8Array;break;case s:c=Uint8Array;break;case l:case f:c=Uint16Array}j(t).output=n=new c(o.buffer,i+o.byteOffset,(o.byteLength-i)/c.BYTES_PER_ELEMENT)}}return n}function q(e){switch(e.type){case"VEC2":if(e.componentType===c)return 512;if(e.componentType===f)return e.normalized?66052:516;if(e.componentType===s)return e.normalized?66050:514;break;case"VEC3":if(e.componentType===c)return 768;break;case"VEC4":if(e.componentType===c)return 1024;if(e.componentType===s)return e.normalized?66562:1026;if(e.componentType===f)return e.normalized?66564:1028}return null}function J(e,t){let n=j(t).buffer,r=j(t).byteOffset||0;if(n)return{buffer:n,byteOffset:r};const o=function(e){let t=0;switch(e.type){case"SCALAR":t=1;break;case"VEC2":t=2;break;case"VEC3":t=3;break;case"VEC4":case"MAT2":t=4;break;case"MAT3":t=9;break;case"MAT4":t=16}let n=0;switch(e.componentType){case a:case s:n=1;break;case l:case f:n=2;break;case 5125:case c:n=4}return t*n}(t);let i=t.count*o;const u=e.bufferViews?.[t.bufferView];if(u){const a=X(e,u),s=u.byteStride||1;r=(t.byteOffset||0)%s,i=t.count*(u.byteStride||o);const l=(t.byteOffset||0)-r;n=new Uint8Array(a.buffer,a.byteOffset+l,i)}if(t.sparse){const{count:a,indices:{bufferView:l,byteOffset:c=0,componentType:u},values:{bufferView:h,byteOffset:g=0}}=t.sparse,m=e.bufferViews?.[l],d=e.bufferViews?.[h];if(m&&d){const t=new Uint8Array(i);n&&t.set(n,r);const l=X(e,m),h=X(e,d),p=new(u===s?Uint8Array:u===f?Uint16Array:Uint32Array)(l.buffer,l.byteOffset+c,a),v=new Uint8Array(h.buffer,h.byteOffset+g,a*o);for(let e=0;e<a;++e){const n=p[e]*o;for(let r=0;r<o;++r)t[n+r]=v[e*o+r]}r=0,n=t}}return n?(j(t).buffer=n,j(t).byteOffset=r):n=new Uint8Array,{buffer:n,byteOffset:r}}function X(e,t){let n=j(t).buffer;if(!n){const r=e.buffers?.[t.buffer];if(r){const e=r.extras.buffer;n=new Uint8Array(e.buffer,e.byteOffset+(t.byteOffset||0),t.byteLength)}else n=new Uint8Array;j(t).buffer=n}return n}function K(e,t){let n="";for(let r=0;r<8;++r)n+=`\n#ifdef USE_${t}_${r}\n  ${e} += targetWeights[${r}] * ${t}_${r};\n#endif\n`;return n}const Q=`\nprecision highp float;\n\nuniform mat4 model;\nuniform mat4 viewProj;\nuniform mat3 normalMatrix;\n\n#ifdef USE_COLOR_0\n#if defined(COLOR_0_VEC3)\nattribute vec3 COLOR_0;\n#else\nattribute vec4 COLOR_0;\n#endif\nvarying vec4 vColor0;\n#endif\n\n#ifdef USE_TEXCOORD_0\nattribute vec2 TEXCOORD_0;\n#endif\n#ifdef USE_TEXCOORD_1\nattribute vec2 TEXCOORD_1;\n#endif\n\nvarying vec2 vTexCoord0;\nvarying vec2 vTexCoord1;\n\n\n#ifdef USE_JOINTS_0\nattribute vec4 JOINTS_0;\n#endif\n\n#ifdef USE_WEIGHTS_0\nattribute vec4 WEIGHTS_0;\n#endif\n\n#if defined(USE_WEIGHTS_0) && defined(USE_JOINTS_0)\n#define USE_SKINNING\n\n#ifndef NUM_JOINTS\n#define NUM_JOINTS 24\n#endif\n\nuniform mat4 jointMatrix[NUM_JOINTS];\n\nmat4 getSkinMatrix() {\n  mat4 skin =\n    WEIGHTS_0.x * jointMatrix[int(JOINTS_0.x)] +\n    WEIGHTS_0.y * jointMatrix[int(JOINTS_0.y)] +\n    WEIGHTS_0.z * jointMatrix[int(JOINTS_0.z)] +\n    WEIGHTS_0.w * jointMatrix[int(JOINTS_0.w)];\n\n  return skin;\n}\n#endif\n\n${["POSITION","NORMAL","TANGENT"].map((e=>{let t="";for(let n=0;n<8;++n)t+=`\n#ifdef USE_${e}_${n}\n  attribute vec3 ${e}_${n};\n#endif\n`;return t})).join("\n")}\n\n#if defined(USE_POSITION_0) || defined(USE_NORMAL_0) || defined(USE_TANGENT_0)\n#define USE_MORPHING\n#ifndef NUM_MORPHS\n#define NUM_MORPHS 8\n#endif\n\nuniform float targetWeights[NUM_MORPHS];\n\nvec4 getTargetPosition() {\n  vec4 pos = vec4(0);\n  ${K("pos.xyz","POSITION")}\n  return pos;\n}\n\nvec3 getTargetNormal() {\n  vec3 normal = vec3(0);\n  ${K("normal","NORMAL")}\n  return normal;\n}\n\nvec3 getTargetTangent() {\n  vec3 tangent = vec3(0);\n  ${K("tangent","TANGENT")}\n  return tangent;\n}\n\n#endif\n\n\nattribute vec3 POSITION;\nvarying vec3 vPosition;\n\nvec4 getPosition() {\n  vec4 pos = vec4(POSITION, 1.0);\n\n#ifdef USE_MORPHING\n  pos += getTargetPosition();\n#endif\n#ifdef USE_SKINNING\n  pos = getSkinMatrix() * pos;\n#endif\n\n  return pos;\n}\n\n#ifdef USE_NORMAL\nattribute vec3 NORMAL;\n\n#ifdef USE_TANGENT\nattribute vec4 TANGENT;\nvarying mat3 vTBN;\n\nvec3 getTangent() {\n  vec3 tan = TANGENT.xyz;\n\n#ifdef USE_MORPHING\n  tan += getTargetTangent();\n#endif\n#ifdef USE_SKINNING\n  tan = mat3(getSkinMatrix()) * tan;\n#endif\n\n  return normalize(tan);\n}\n#else\nvarying vec3 vNormal;\n#endif\n\nvec3 getNormal() {\n  vec3 norm = NORMAL;\n\n#ifdef USE_MORPHING\n  norm += getTargetNormal();\n#endif\n#ifdef USE_SKINNING\n  norm = mat3(getSkinMatrix()) * norm;\n#endif\n\n  return normalize(norm);\n}\n\n#endif\n\nvoid main(void) {\n  vec4 pos = model * getPosition();\n  vPosition = pos.xyz / pos.w;\n\n#ifdef USE_NORMAL\n#ifdef USE_TANGENT\n  vec3 tan = getTangent();\n  vec3 normW = normalize(normalMatrix * getNormal());\n  vec3 tanW = normalize(normalMatrix * tan);\n  vec3 bitanW = cross(normW, tanW) * TANGENT.w;\n  vTBN = mat3(tanW, bitanW, normW);\n#else\n  vNormal = normalize(normalMatrix * NORMAL);\n#endif\n#endif\n\n#ifdef USE_COLOR_0\n#if defined(COLOR_0_VEC3)\n  vColor0 = vec4(COLOR_0, 1.0);\n#else\n  vColor0 = COLOR_0;\n#endif\n#endif\n\n  vTexCoord0 = vec2(0.0, 0.0);\n  vTexCoord1 = vec2(0.0, 0.0);\n#ifdef USE_TEXCOORD_0\n  vTexCoord0 = TEXCOORD_0;\n#endif\n#ifdef USE_TEXCOORD_1\n  vTexCoord1 = TEXCOORD_1;\n#endif\n\n  gl_Position = viewProj * pos;\n  gl_PointSize = 1.0;\n}\n`;var Y;function Z(){var t=new e(4);return e!=Float32Array&&(t[0]=0,t[1]=0,t[2]=0),t[3]=1,t}function ee(e,t,n,r){var o,i,a,s,l,f=t[0],c=t[1],u=t[2],h=t[3],g=n[0],m=n[1],d=n[2],p=n[3];return(i=f*g+c*m+u*d+h*p)<0&&(i=-i,g=-g,m=-m,d=-d,p=-p),1-i>1e-6?(o=Math.acos(i),a=Math.sin(o),s=Math.sin((1-r)*o)/a,l=Math.sin(r*o)/a):(s=1-r,l=r),e[0]=s*f+l*g,e[1]=s*c+l*m,e[2]=s*u+l*d,e[3]=s*h+l*p,e}function te(e){return(new TextDecoder).decode(e)}function ne(e){return/^data:.*,.*$/i.test(e)||/^blob:.*$/i.test(e)}function re(e,t){return""===e?"":/^(https?:)?\/\//i.test(e)||ne(e)?e:t+e}function oe(e,t,n=0,r=0,o=t.length-r){for(let i=0;i<o;++i)e[n+i]=t[r+i];return e}Y=new e(4),e!=Float32Array&&(Y[0]=0,Y[1]=0,Y[2]=0,Y[3]=0),t(),n(1,0,0),n(0,1,0),Z(),Z(),k();const ie=P(),ae=Z(),se=n(1,1,1),le=t();function fe(e,t,n,r=null){const o=e.nodes?.[t];if(!o)return;r?.push(t);const i=j(o),a=i.matrix=i.matrix||P();var s,l,f,c,u,h,g,m,d,p,v,b,x,T,y,O,w,C,S,N,_,L,E;o.matrix?G(a,o.matrix):(o.rotation||o.scale||o.translation||i.rotation||i.scale||i.translation)&&(s=a,l=i.rotation||o.rotation||ae,f=i.translation||o.translation||le,c=i.scale||o.scale||se,b=(u=l[0])*(d=u+u),x=u*(p=(h=l[1])+h),T=u*(v=(g=l[2])+g),y=h*p,O=h*v,w=g*v,C=(m=l[3])*d,S=m*p,N=m*v,_=c[0],L=c[1],E=c[2],s[0]=(1-(y+w))*_,s[1]=(x+N)*_,s[2]=(T-S)*_,s[3]=0,s[4]=(x-N)*L,s[5]=(1-(b+w))*L,s[6]=(O+C)*L,s[7]=0,s[8]=(T+S)*E,s[9]=(O-C)*E,s[10]=(1-(b+y))*E,s[11]=0,s[12]=f[0],s[13]=f[1],s[14]=f[2],s[15]=1);const M=i.model=H(i.model||P(),n,a);if(o.children)for(const t of o.children)fe(e,t,M,r)}function ce(e,n){const r=e.cameras?.[n.camera];if(r){const e=j(n).model=j(n).model||ie;j(r).view=B(j(r).view||P(),e),j(r).translation=(o=j(r).translation||t(),i=e[12],a=e[13],s=e[14],o[0]=i,o[1]=a,o[2]=s,o)}var o,i,a,s}function ue(e,t){const n=e.skins?.[t.skin];if(n){const r=n.joints.length,o=j(t).jointMatrix=j(t).jointMatrix||new Float32Array(16*r),i=function(e,t){let n=j(t).inverseBindMatrices;if(!n){const r=e.accessors?.[t.inverseBindMatrices];if(r){const{buffer:o,byteOffset:i}=J(e,r);n=new Float32Array(o.buffer,o.byteOffset+i+(r.byteOffset||0),16*t.joints.length)}else n=new Float32Array(16*t.joints.length);j(t).inverseBindMatrices=n}return n}(e,n);for(let a=0;a<r;++a){const r=e.nodes[n.joints[a]],s=new Float32Array(o.buffer,o.byteOffset+64*a,16);B(s,j(t).model||ie),H(s,s,r&&j(r).model||ie),H(s,s,new Float32Array(i.buffer,i.byteOffset+64*a,16))}}}const he=["POSITION","NORMAL","TANGENT"],ge=/(POSITION|NORMAL|TANGENT)_(\d+)/,me=P(),de=t(),pe=P();function ve(e,t,n,r,o,i,a){var s,l,f,c,u,h,g,m,d,x,T,y,O,C,S,N,_,L,E,M,I,F,A,R,U,D,B,V,z,H,$;a.model=G(a.model||P(),j(r).model||me),s=a.normalMatrix=a.normalMatrix||k(),f=(l=a.model)[0],c=l[1],u=l[2],h=l[3],g=l[4],m=l[5],d=l[6],x=l[7],T=l[8],y=l[9],O=l[10],C=l[11],S=l[12],N=l[13],_=l[14],($=(E=f*m-c*g)*(H=O*(L=l[15])-C*_)-(M=f*d-u*g)*(z=y*L-C*N)+(I=f*x-h*g)*(V=y*_-O*N)+(F=c*d-u*m)*(B=T*L-C*S)-(A=c*x-h*m)*(D=T*_-O*S)+(R=u*x-h*d)*(U=T*N-y*S))&&($=1/$,s[0]=(m*H-d*z+x*V)*$,s[1]=(d*B-g*H-x*D)*$,s[2]=(g*z-m*B+x*U)*$,s[3]=(u*z-c*H-h*V)*$,s[4]=(f*H-u*B+h*D)*$,s[5]=(c*B-f*z-h*U)*$,s[6]=(N*R-_*A+L*F)*$,s[7]=(_*I-S*R-L*M)*$,s[8]=(S*A-N*I+L*E)*$,s)||function(e){e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=1,e[5]=0,e[6]=0,e[7]=0,e[8]=1}(a.normalMatrix);let W=!1,X=0,K=n.accessors?.[i.attributes.POSITION]?.count||0;if(!K)return;const Y={...a,...be(e,n,i.material)};i.targets&&(Y.targetWeights=j(r).weights||r.weights||o.weights||[0,0,0,0,0,0,0,0]);let Z=0;const ee=n.skins?.[r.skin];if(i.attributes.JOINTS_0&&i.attributes.WEIGHTS_0&&ee){Z=ee.joints.length;const e=j(r).jointMatrix=j(r).jointMatrix||new Float32Array(16*Z);Y.jointMatrix=e}const te=function(e,t,n,r=0){let o=j(n).pipeline;if(o)return o;const i=n.mode||4,a=t.materials?.[n.material];let s="OPAQUE",l=!1,f=!1;a&&(l=a.doubleSided||!1,s=a.alphaMode||s,f=!!a.extensions?.KHR_materials_unlit);const c=function(e,t){const n={},r=[];let o=0;function i(t){if(!t.sparse){const o=J(e,t).buffer,i=`${t.bufferView},${o.byteOffset},${o.byteLength}`;if(i in n)return r[n[i]];n[i]=r.length}const o={attrs:[],stride:e.bufferViews?.[t.bufferView]?.byteStride};return r.push(o),o}for(const n of["POSITION","NORMAL","TANGENT","TEXCOORD_0","TEXCOORD_1","COLOR_0","JOINTS_0","WEIGHTS_0"]){const r=e.accessors?.[t.attributes[n]];if(r){const e=q(r);if(!e)continue;i(r).attrs.push({name:n,format:e,shaderLoc:o,offset:j(r).byteOffset||0}),o++}}if(t.targets){const n=new Array(3);for(let r=0;r<t.targets.length;++r){let a=0;for(let o=0;o<he.length;++o)(n[o]=e.accessors?.[t.targets[r][he[o]]])&&++a;if(o+a>16)break;for(let e=0;e<he.length;++e){const t=n[e];t&&(i(t).attrs.push({name:`${he[e]}_${r}`,format:768,shaderLoc:o,offset:j(t).byteOffset||0}),o++)}}}return r}(t,n),u=5125===t.accessors?.[n.indices]?.componentType?5125:5123,h=n.attributes.JOINTS_0&&n.attributes.WEIGHTS_0?12*Math.ceil(r/12):0,g=JSON.stringify([c,l,s,h,u,i,f]),m=j(t).pipelines=j(t).pipelines||{};if(o=m[g],o)return o;const d=[`ALPHAMODE_${s}`];for(const e of c)for(const t of e.attrs)d.push(`USE_${t.name}`),"COLOR_0"===t.name&&3===w(t.format)&&d.push("COLOR_0_VEC3");h>0&&d.push(`NUM_JOINTS ${h}`),f&&d.push("MATERIAL_UNLIT");const x=d.map((e=>`#define ${e}`)).join("\n"),T={};return h>0&&(T.jointMatrix={type:1,format:b}),n.targets&&(T.targetWeights={type:1,format:v}),o=j(n).pipeline=m[g]=e.pipeline({vert:x+Q,frag:x+"\n#ifdef GL_OES_standard_derivatives\n  #extension GL_OES_standard_derivatives : enable\n#endif\n\nprecision highp float;\n\nuniform float alphaCutoff;\nuniform vec3 cameraPosition;\n\nvarying vec3 vPosition;\n\n\nconst float GAMMA = 2.2;\n\nvec3 linearTosRGB(vec3 color) {\n  return pow(color, vec3(1./GAMMA));\n}\n\nvec3 sRGBToLinear(vec3 srgbIn) {\n  return vec3(pow(srgbIn.xyz, vec3(GAMMA)));\n}\n\nvec4 sRGBToLinear(vec4 srgbIn) {\n  return vec4(sRGBToLinear(srgbIn.xyz), srgbIn.w);\n}\n\n\nconst float PI = 3.141592653589793;\n\nvec3 specularF(vec3 r0, vec3 r90, float vDotH) {\n  return r0 + (r90 - r0) * pow(clamp(1. - vDotH, 0., 1.), 5.);\n}\n\nfloat specularD(float aSqr, float nDotH) {\n  float f = (nDotH * nDotH) * (aSqr - 1.) + 1.;\n  return aSqr / (PI * f * f);\n}\n\nfloat specularV(float aSqr, float nDotL, float nDotV) {\n  float gl = 1. / (nDotL + sqrt(aSqr + (1. - aSqr) * (nDotL * nDotL)));\n  float gv = 1. / (nDotV + sqrt(aSqr + (1. - aSqr) * (nDotV * nDotV)));\n  return gl * gv;\n}\n\nfloat specularBRDF(float aSqr, float nDotL, float nDotV, float nDotH) {\n  return specularV(aSqr, nDotL, nDotV) * specularD(aSqr, nDotH);\n}\n\nvec3 diffuseBRDF(vec3 color) {\n  return color / PI;\n}\n\n\nvarying vec2 vTexCoord0;\nvarying vec2 vTexCoord1;\n\nstruct TextureInfo {\n  sampler2D tex;\n  float texCoord;\n  float scale;\n};\n\nvec2 getTexCoord(TextureInfo tex) {\n  return mix(vTexCoord0, vTexCoord1, step(1., tex.texCoord));\n}\n\nvec4 texture(TextureInfo tex) {\n  return texture2D(tex.tex, getTexCoord(tex));\n}\n\nvec4 texture(TextureInfo tex, vec4 defaultValue) {\n  return mix(defaultValue, texture2D(tex.tex, getTexCoord(tex)), step(0., tex.texCoord));\n}\n\n\nuniform TextureInfo normalTexture;\n\n#ifdef USE_NORMAL\n#ifdef USE_TANGENT\nvarying mat3 vTBN;\n#else\nvarying vec3 vNormal;\n#endif\n#endif\n\nstruct NormalInfo {\n  vec3 ng;\n  vec3 n;\n  vec3 t;\n  vec3 b;\n};\n\nNormalInfo getNormalInfo(vec3 v) {\n  vec3 n, t, b, ng;\n\n#ifdef USE_TANGENT\n  t = normalize(vTBN[0]);\n  b = normalize(vTBN[1]);\n  ng = normalize(vTBN[2]);\n#else\n#ifdef USE_NORMAL\n  ng = normalize(vNormal);\n#else\n  ng = normalize(cross(dFdx(v), dFdy(v)));\n#endif\n  vec2 UV = getTexCoord(normalTexture);\n  vec3 uvDx = dFdx(vec3(UV, 0.));\n  vec3 uvDy = dFdy(vec3(UV, 0.));\n  vec3 t_ = (uvDy.t * dFdx(v) - uvDx.t * dFdy(v)) / (uvDx.s * uvDy.t - uvDy.s * uvDx.t);\n\n  t = normalize(t_ - ng * dot(ng, t_));\n  b = cross(ng, t);\n#endif\n\n  if (gl_FrontFacing == false) {\n    t *= -1.;\n    b *= -1.;\n    ng *= -1.;\n  }\n\n  n = ng;\n  if (normalTexture.texCoord >= 0.) {\n    n = texture(normalTexture).rgb * 2. - vec3(1.);\n    n *= vec3(normalTexture.scale, normalTexture.scale, 1.);\n    n = mat3(t, b, ng) * normalize(n);\n  }\n\n  NormalInfo ni;\n  ni.ng = ng;\n  ni.t = t;\n  ni.b = b;\n  ni.n = n;\n  return ni;\n}\n\n\nconst float MIN_ROUGHNESS = .04;\n\n#ifdef USE_COLOR_0\nvarying vec4 vColor0;\n#endif\n\nuniform vec4 baseColorFactor;\nuniform TextureInfo baseColorTexture;\n\nuniform float metallicFactor;\nuniform float roughnessFactor;\nuniform TextureInfo metallicRoughnessTexture;\n\nuniform TextureInfo occlusionTexture;\n\nuniform vec3 emissiveFactor;\nuniform TextureInfo emissiveTexture;\n\nvec4 getVertexColor() {\n  vec4 color = vec4(1.);\n#ifdef USE_COLOR_0\n  color = vColor0;\n#endif\n  return color;\n}\n\nvec4 getBaseColor() {\n  vec4 baseColor = vec4(1.);\n\n  baseColor *= baseColorFactor;\n  baseColor *= sRGBToLinear(texture(baseColorTexture, vec4(1.)));\n\n  return baseColor * getVertexColor();\n}\n\nvec2 getMetallicRoughness() {\n  vec4 mrTex = texture(metallicRoughnessTexture, vec4(1.));\n  return vec2(\n    clamp(metallicFactor * mrTex.b, 0., 1.),\n    clamp(roughnessFactor * mrTex.g, MIN_ROUGHNESS, 1.)\n  );\n}\n\nfloat getOcculsion() {\n  return texture(occlusionTexture, vec4(1.)).r;\n}\n\nvec3 getEmissiveFactor() {\n  return emissiveFactor * sRGBToLinear(texture(emissiveTexture, vec4(0)).rgb);\n}\n\n\n\n#define LIGHT_DIRECTIONAL 0\n#define LIGHT_POINT 1\n#define LIGHT_SPOT 2\n\nint getLightType(mat4 light) {\n  return int(light[0].x);\n}\n\nvec2 getLightConeCos(mat4 light) {\n  return light[0].yz;\n}\n\nvec4 getLightColor(mat4 light) {\n  return light[1];\n}\n\nfloat getLightRange(mat4 light) {\n  return light[2].w;\n}\n\nvec3 getLightDirection(mat4 light) {\n  return light[2].xyz;\n}\n\nvec3 getLightPosition(mat4 light) {\n  return light[3].xyz;\n}\n\nfloat getRangeAttenuation(float range, float distance) {\n  if (range <= 0.) {\n    return 1. / pow(distance, 2.);\n  }\n  return max(min(1.0 - pow(distance / range, 4.), 1.), 0.) / pow(distance, 2.);\n}\n\nfloat getSpotAttenuation(vec3 pointToLight, vec3 direction, vec2 coneCos) {\n  float actualCos = dot(normalize(direction), normalize(-pointToLight));\n  float scale = 1. / max(.001, coneCos[0] - coneCos[1]);\n  float offset = -coneCos[1] * scale;\n  float att = clamp(actualCos * scale + offset, 0., 1.);\n  return att * att;\n}\n\nvec3 getPointToLight(mat4 light, vec3 position) {\n  return getLightType(light) != LIGHT_DIRECTIONAL ? getLightPosition(light) - position : -getLightDirection(light);\n}\n\nvec3 getLighIntensity(mat4 light, vec3 pointToLight) {\n  vec4 color = getLightColor(light);\n  vec3 intensity = color.rgb * color.a;\n\n  if (getLightType(light) != LIGHT_DIRECTIONAL) {\n    intensity *= getRangeAttenuation(getLightRange(light), length(pointToLight));\n  }\n  if (getLightType(light) == LIGHT_SPOT) {\n    intensity *= getSpotAttenuation(pointToLight, getLightDirection(light), getLightConeCos(light));\n  }\n\n  return intensity;\n}\n\n\nvoid main () {\n  vec4 baseColor = getBaseColor();\n#ifdef ALPHAMODE_OPAQUE\n  baseColor.a = 1.0;\n#endif\n\n#ifdef MATERIAL_UNLIT\n  gl_FragColor = (vec4(linearTosRGB(baseColor.rgb), baseColor.a));\n  return;\n#endif\n\n  vec3 v = normalize(cameraPosition - vPosition);\n  NormalInfo normalInfo = getNormalInfo(vPosition);\n  vec3 n = normalInfo.n;\n\n  vec3 reflection = -normalize(reflect(v, n));\n  float nDotV = clamp(abs(dot(n, v)), 0.001, 1.0);\n\n  vec2 metallicRoughness = getMetallicRoughness();\n  float metallic = metallicRoughness[0];\n  float roughness = metallicRoughness[1];\n  float alphaRoughness = roughness * roughness;\n  float aSqr = alphaRoughness * alphaRoughness;\n\n  vec3 f0 = vec3(0.04);\n  vec3 diffuseColor = baseColor.rgb * (vec3(1.0) - f0) * (1.0 - metallic);\n  vec3 specularColor = mix(f0, baseColor.rgb, metallic);\n\n  float r0 = max(max(specularColor.r, specularColor.g), specularColor.b);\n  float r90 = clamp(r0 * 25.0, 0.0, 1.0);\n  vec3 specularEnvR0 = specularColor.rgb;\n  vec3 specularEnvR90 = vec3(1.0, 1.0, 1.0) * r90;\n\n  vec3 diffuseFinal = vec3(0.0);\n  vec3 specularFinal = vec3(0.0);\n\n  #define NUM_LIGHTS 4\n\n  mat4 lights[4];\n  lights[0] = mat4(\n    0., 0., 0., 0.,\n    1., 1., 1., 1.,\n    .5, -.707, -.5, 0.,\n    0., 0., 0., 0.\n  );\n  lights[1] = mat4(\n    0., 0., 0., 0.,\n    1., 1., 1., .5,\n    -.5, .707, .5, 0.,\n    0., 0., 0., 0.\n  );\n  lights[2] = mat4(\n    0., 0., 0., 0.,\n    1., 1., 1., .25,\n    .5, .707, -.5, 0.,\n    0., 0., 0., 0.\n  );\n  lights[3] = mat4(\n    0., 0., 0., 0.,\n    1., 1., 1., .25,\n    -.5, -.707, .5, 0.,\n    0., 0., 0., 0.\n  );\n\n#ifdef NUM_LIGHTS\n  for (int i = 0; i < NUM_LIGHTS; ++i) {\n    vec3 pointToLight = getPointToLight(lights[i], vPosition);\n    vec3 intensity = getLighIntensity(lights[i], pointToLight);\n    vec3 l = normalize(pointToLight);\n    vec3 h = normalize(l + v);\n    float nDotL = clamp(dot(n, l), 0.001, 1.0);\n    float nDotH = clamp(dot(n, h), 0.0, 1.0);\n    float vDotH = clamp(dot(v, h), 0.0, 1.0);\n  \n    vec3 F = specularF(specularEnvR0, specularEnvR90, vDotH);\n    vec3 diffuse = (1.0 - F) * diffuseBRDF(diffuseColor);\n    vec3 specular = max(vec3(0.0), F * specularBRDF(aSqr, nDotL, nDotV, nDotH));\n\n    diffuseFinal += intensity * nDotL * diffuse;\n    specularFinal += intensity * nDotL * specular;\n  }\n#endif\n\n  vec4 ambient = vec4(0.1);\n\n  vec3 ambientDiffuse = ambient.rgb * diffuseBRDF(diffuseColor);\n  diffuseFinal += ambientDiffuse;\n\n  vec3 colorFinal = diffuseFinal + specularFinal;\n\n  float ao = getOcculsion();\n  colorFinal = mix(colorFinal, colorFinal * ao, occlusionTexture.scale);\n\n  vec3 emissive = getEmissiveFactor();\n  colorFinal += emissive;\n\n#ifdef ALPHAMODE_MASK\n  if (baseColor.a < alphaCutoff) {\n    discard;\n  }\n  baseColor.a = 1.0;\n#else\n  alphaCutoff;\n#endif\n\n  gl_FragColor = vec4(linearTosRGB(colorFinal), baseColor.a);\n}\n",buffers:c,indexFormat:u,mode:i,depth:{compare:515,writeEnabled:!("BLEND"===s)},blend:"BLEND"===s?{srcFactorRGB:770,dstFactorRGB:771,srcFactorAlpha:1,dstFactorAlpha:771}:void 0,raster:{cullMode:l?0:1029},uniforms:{model:{type:1,format:b},viewProj:{type:1,format:b},normalMatrix:{type:1,format:35675},cameraPosition:{type:1,format:35665},alphaCutoff:{type:1,format:v},baseColorFactor:{type:1,format:35666},"baseColorTexture.tex":{type:2,format:p},"baseColorTexture.texCoord":{type:1,format:v},metallicFactor:{type:1,format:v},roughnessFactor:{type:1,format:v},"metallicRoughnessTexture.tex":{type:2,format:p},"metallicRoughnessTexture.texCoord":{type:1,format:v},"normalTexture.tex":{type:2,format:p},"normalTexture.texCoord":{type:1,format:v},"normalTexture.scale":{type:1,format:v},emissiveFactor:{type:1,format:35665},"emissiveTexture.tex":{type:2,format:p},"emissiveTexture.texCoord":{type:1,format:v},"occlusionTexture.tex":{type:2,format:p},"occlusionTexture.texCoord":{type:1,format:v},"occlusionTexture.scale":{type:1,format:v},...T}}),o}(e,n,i,Z);t.pipeline(te).uniforms(Y);for(let r=0;r<te.buffers.length;++r){const o=te.buffers[r].attrs[0].name,a=ge.exec(o),s=xe(e,n,a?i.targets[a[2]][a[1]]:i.attributes[o],34962);s&&t.vertex(r,s)}const ne=n.accessors?.[i.indices];if(ne){const r=xe(e,n,i.indices,34963);r&&(t.index(r),K=ne.count,X=j(ne).byteOffset||0,W=!0)}W?t.drawIndexed(K,1,X):t.draw(K)}function be(e,t,n){const r={alphaCutoff:.5,baseColorFactor:[1,1,1,1],"baseColorTexture.tex":Te(e,t),"baseColorTexture.texCoord":-1,metallicFactor:1,roughnessFactor:1,"metallicRoughnessTexture.tex":Te(e,t),"metallicRoughnessTexture.texCoord":-1,"normalTexture.tex":Te(e,t),"normalTexture.texCoord":-1,"normalTexture.scale":1,emissiveFactor:[0,0,0],"emissiveTexture.tex":Te(e,t),"emissiveTexture.texCoord":-1,"occlusionTexture.tex":Te(e,t),"occlusionTexture.texCoord":-1,"occlusionTexture.scale":0};function o(n,o,i=null){n[o]&&(r[`${o}.tex`]=function(e,t,n){const r=t.textures?.[n];if(!r)return Te(e,t);let o=j(r).texture;if(o)return o;let i=null;const a={wrapU:10497,wrapV:10497,magFilter:m.Linear,minFilter:m.Linear},s=t.images?.[r.source];s&&(i=s.extras.image);const l=t.samplers?.[r.sampler];if(l)switch(a.wrapU=l.wrapS||a.wrapU,a.wrapV=l.wrapT||a.wrapV,a.magFilter=l.magFilter||a.magFilter,l.minFilter){case d.Nearest:case d.NearestMipmapNearest:case d.NearestMipmapLinear:a.minFilter=d.Nearest}return o=j(r).texture=e.texture({size:i?[i.naturalWidth,i.naturalHeight]:[1,1]},a),o.data(i||new Uint8Array([255,255,255,255])),o}(e,t,n[o].index),r[`${o}.texCoord`]=n[o].texCoord||0,i&&(r[`${o}.scale`]=n[o][i]??r[`${o}.scale`]))}const i=t.materials?.[n];if(i){if(i.pbrMetallicRoughness){const e=i.pbrMetallicRoughness;r.baseColorFactor=e.baseColorFactor||r.baseColorFactor,(e.metallicFactor||0===e.metallicFactor)&&(r.metallicFactor=e.metallicFactor),(e.roughnessFactor||0===e.roughnessFactor)&&(r.roughnessFactor=e.roughnessFactor),o(e,"baseColorTexture"),o(e,"metallicRoughnessTexture")}r.alphaCutoff=i.alphaCutoff??r.alphaCutoff,r.emissiveFactor=i.emissiveFactor||r.emissiveFactor,o(i,"emissiveTexture"),o(i,"occlusionTexture","strength"),o(i,"normalTexture","scale")}return r}function xe(e,t,n,r){const o=t.accessors?.[n];if(!o)return null;const i=34963===r&&o.componentType===s;if(o.sparse||i){let n=j(o).gpuBuffer;if(!n){const a=J(t,o);let s=a.buffer;if(i){const e=new Uint16Array(s.byteLength);for(let t=0;t<s.byteLength;++t)e[t]=s[a.byteOffset+t];s=j(o).buffer=new Uint8Array(e.buffer,0,e.byteLength),j(o).byteOffset=0}n=j(o).gpuBuffer=e.buffer({type:r,size:s.byteLength}).data(s)}return n}const a=t.bufferViews?.[o.bufferView];if(!a)return null;const l=j(a).gpuBuffers=j(a).gpuBuffers||{},f=J(t,o).buffer,c=`${f.byteOffset},${f.byteLength}`;return l[c]?l[c]:l[c]=e.buffer({type:a.target||r,size:f.byteLength}).data(f)}function Te(e,t){let n=j(t).blankTexture;return n||(n=j(t).blankTexture=e.texture({size:[1,1]}).data(new Uint8Array([255,255,255,255])),n)}const ye=1179937895;async function Oe(e,t=we){const n=e.uri?function(e){if(ne(e))return"";const t=e.split(/[?#]/)[0].split("/");return t.pop(),t.length?t.join("/")+"/":""}(e.uri):"";let r=e.glTF,o=e.binaryChunk;if(!r&&e.uri){const n=await t(e.uri,"bin");if(i=n,new DataView(i.buffer||i,i.byteOffset||0,4).getUint32(0,!0)===ye){const e=function(e){let t,n;const r=e.buffer||e,o=e.byteOffset||0,i=new DataView(r,o,12);if(i.getUint32(0,!0)!==ye)throw new Error("Invalid GLB format");const a=i.getUint32(4,!0);if(2!==a)throw new Error("Unsupported GLB version: "+a);const s=new DataView(r,o+12);let l=0;for(;l<s.byteLength;){const e=s.getUint32(l,!0),i=s.getUint32(l+4,!0);if(l+=8,1313821514===i){const n=new Uint8Array(r,o+12+l,e);t=JSON.parse(te(n))}else 5130562===i&&(n=new Uint8Array(r,o+12+l,e));l+=e}if(!t)throw new Error("Invalid GLB format: missing JSON content");if(!t.asset||"2.0"!==t.asset.minVersion&&"2.0"!==t.asset.version)throw new Error("Unsupported glTF version: 2.0 required");return{glTF:t,binaryChunk:n}}(n);r=e.glTF,o=e.binaryChunk}else r=JSON.parse(te(n))}var i;if(!r)throw new Error("Failed to load glTF JSON");const a=await async function(e,t,n,r){if(e.buffers)for(let o=0;o<e.buffers.length;++o){const i=e.buffers[o];if(j(i).buffer)continue;let a;const s=i.uri;if(s)a=await n(re(s,r),"bin");else{if(0!==o||!t)throw new Error("Invalid glTF: missing uri for buffer "+o);a=t}j(i).buffer=a}return e}(r,o,t,n);return await async function(e,t,n){if(e.images)for(let r=0;r<e.images.length;++r){const o=e.images[r];if(j(o).image)continue;const i=o.bufferView;let a,s=!1,l=o.uri;if(i){const t=e.bufferViews?.[i];if(!t)throw new Error("Invalid glTF: invalid bufferView for image "+r);const n=new Blob([X(e,t)],{type:o.mimeType});l=URL.createObjectURL(n),s=!0}if(!l)throw new Error("Invalid glTF: missing uri or bufferView for image "+r);try{a=await t(re(l,n),"img")}finally{s&&URL.revokeObjectURL(l)}j(o).image=a}return e}(a,t,n)}function we(e,t){return"img"===t?new Promise(((t,n)=>{const r=new Image;r.crossOrigin="anonymous",r.onerror=()=>n(new Error("Failed to load: "+e)),r.onload=()=>t(r),r.src=e})):fetch(e).then((e=>e.arrayBuffer())).then((e=>new Uint8Array(e)))}const Ce=P();function Se(e,i,a,s){const l=function(e,t){var n=t[0],r=t[1],o=t[2],i=n*n+r*r+o*o;return i>0&&(i=1/Math.sqrt(i)),e[0]=t[0]*i,e[1]=t[1]*i,e[2]=t[2]*i,e}(t(),a),[f,c]=function(e,n,r,o){for(let t=0;t<3;++t)e[t]=1/0,n[t]=-1/0;const i=t(),a=t();let s=(o.nodes||[]).slice();for(;s.length>0;){const t=r.nodes?.[s.pop()];if(!t)continue;s=s.concat(t.children||[]);const o=r.meshes?.[t.mesh];if(o)for(const s of o.primitives){const o=r.accessors?.[s.attributes.POSITION];if(o){Me(i,a,o,t.extras?.model||Ce);for(let t=0;t<3;++t)e[t]=Math.min(e[t],i[t]),n[t]=Math.max(n[t],a[t])}}}return[e,n]}(t(),t(),e,e.scenes[i]),u=Math.max(c[0]-f[0],c[1]-f[1]),h=Math.PI/4,g=h*s,m=u/2/Math.tan(h/2),d=u/2/Math.tan(g/2),p=Math.max(d,m);o(l,l,-1.2*p);const v=(b=f,T=(x=c)[0]-b[0],y=x[1]-b[1],O=x[2]-b[2],Math.hypot(T,y,O));var b,x,T,y,O;let w=p+6*v,C=p-6*v;C=Math.max(C,w/1e4);const S=t();return r(S,f,c),o(S,S,.5),{model:z(P(),l,S,n(0,1,0)),proj:V(P(),h,s,C,w)}}const Ne=t(),_e=t(),Le=t(),Ee=t();function Me(e,t,n,a){i(Ne,n.min,a),i(_e,n.max,a),r(Le,_e,Ne),o(Le,Le,.5),function(e,t,n){e[0]=t[0]-n[0],e[1]=t[1]-n[1],e[2]=t[2]-n[2]}(Ee,_e,Le);const s=(f=(l=Ee)[0],c=l[1],u=l[2],Math.hypot(f,c,u));var l,f,c,u;for(let n=0;n<3;++n)e[n]=Le[n]-s,t[n]=Le[n]+s}const Ie=n(-1,-2,-2),Fe=new URLSearchParams(window.location.search),Ae=document.querySelector("canvas"),Re=Ae.parentElement;let Ue=null,De=0,Pe=0;const Ge=((e,t)=>{const n=e.getContext("webgl",{powerPreference:"low-power"});return n?new U(n):null})(Ae);Ge.feature("OES_standard_derivatives"),Ge.feature("OES_element_index_uint");const Be="https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/63f026b2aa957d3e8207f6dd798608993e33fb0d/2.0";function Ve(e=0){if(window.requestAnimationFrame(Ve),!Ue)return;De||(De=e);const t=e-De,r=Fe.get("camera"),o=Fe.get("scene"),i=((null!==o&&parseInt(o))??Ue.scene)||0;Ue.animations?.length&&(function(e,t,n=0,r=!1){const o=function(e,t){let n=j(t).duration||0;for(const r of t.channels){const o=e.nodes?.[r.target.node],i=e.accessors?.[t.samplers[r.sampler]?.input];o&&i&&(n=Math.max(n,i.max?.[0]||0))}return j(t).duration=n}(e,t),i=r?n-Math.floor(n/o)*o:Math.min(n,o);for(const n of t.channels){const r=e.nodes?.[n.target.node],o=t.samplers[n.sampler];if(!r||!o)continue;const a=$(e,o),s=W(e,o);if(!a?.length||!s)continue;const l=a.length,f=a[0],c=a[l-1];let u,h;if(i<=f)u=h=0;else if(i>=c)u=h=l-1;else{let e=j(n).lastKeyframe||0;for(a[e]>i&&(e=0),u=e,h=u+1;h<l&&!(a[u]<=i&&a[h]>i);++u,++h);}j(n).lastKeyframe=u;const g=n.target.path;let m=3;switch(g){case"rotation":m=4;break;case"weights":m=r.weights?.length||e.meshes?.[r.mesh]?.weights?.length||0}if(!m)continue;let d=o.interpolation;u===h&&(d="STEP");const p=a[u],v=a[h],b=(i-p)/(v-p),x=j(r)[g]=j(r)[g]||new Array(m),T=new Array(m);switch(d){case"STEP":oe(x,s,0,u*m,m);break;case"CUBICSPLINE":{const e=v-p,t=b*b,n=b*t;for(let r=0;r<m;++r)x[r]=(2*n-3*t+1)*s[(3*u+1)*m+r]+(n-2*t+b)*e*s[(3*u+2)*m+r]+(-2*n+3*t)*s[(3*h+1)*m+r]+(n-t)*e*s[3*h*m+r];break}default:if("rotation"===g)oe(x,s,0,u*m,m),oe(T,s,0,h*m,m),ee(x,x,T,b);else for(let e=0;e<m;++e)x[e]=(1-b)*s[u*m+e]+b*s[h*m+e]}}return n<o}(Ue,Ue.animations[Pe],t/1e3)||(De=e,Pe=(Pe+1)%Ue.animations.length)),function(e,t,r={}){const o=(r.scene??t.scene)||0,i=t.nodes,a=t.scenes?.[o]?.nodes;if(!i||!a)return;const s=function(e,t={}){let n=[];const r=e.scenes?.[(t.scene??e.scene)||0]?.nodes;if(r)for(let t=0;t<r.length;++t)fe(e,r[t],ie,n);n=n.sort().filter(((e,t,n)=>!t||e!==n[t-1]));for(const t of n){const n=e.nodes[t];"camera"in n&&ce(e,n),"skin"in n&&ue(e,n)}return n}(t,{scene:o});let l=me,f=me,c=de;if(r.camera){const o=t.cameras?.[r.camera.index||0];o&&(l=o.extras?.view||me,u=pe,h=o,g=e.canvas.width/e.canvas.height,h?.orthographic?function(e,t,n,r,o,i,a){var s=1/(t-n),l=1/(r-o),f=1/(i-a);e[0]=-2*s,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=-2*l,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=2*f,e[11]=0,e[12]=(t+n)*s,e[13]=(o+r)*l,e[14]=(a+i)*f,e[15]=1}(u,-h.orthographic.xmag,h.orthographic.xmag,-h.orthographic.xmag/(g||1),h.orthographic.xmag/(g||1),h.orthographic.znear,h.orthographic.zfar):h?.perspective?V(u,h.perspective.yfov,g||h.perspective.aspectRatio||1,h.perspective.znear,h.perspective.zfar||1/0):function(e){e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1}(u),f=u,c=o.extras?.translation||de),r.camera.model&&(c=n(r.camera.model[12],r.camera.model[13],r.camera.model[14]),l=B(P(),r.camera.model)),f=r.camera.proj||f}var u,h,g;const m={cameraPosition:c,viewProj:H(pe,f,l)},d=e.pass(),p=e.render(d),v=[];for(let n=0;n<s.length;++n){const r=i[s[n]],o=t.meshes?.[r.mesh];if(o)for(let n=0;n<o.primitives.length;++n){const i=o.primitives[n];"BLEND"===t.materials?.[i.material]?.alphaMode?v.push({node:r,mesh:o,primitive:i}):ve(e,p,t,r,o,i,m)}}for(const n of v)ve(e,p,t,n.node,n.mesh,n.primitive,m);p.end(),d.destroy()}(Ge,Ue,{scene:i,camera:Ue.cameras?{index:parseInt(r)||0}:Se(Ue,i,Ie,Ge.canvas.width/Ge.canvas.height)})}function ze(){const e=window.devicePixelRatio||1,t=Re.clientWidth,n=Re.clientHeight;Ae.width=t*e,Ae.height=n*e,Ae.style.width=`${t}px`,Ae.style.height=`${n}px`}window.addEventListener("resize",ze,!1),ze(),async function(){let e=Fe.get("url");if(!e){const t=await(await fetch(`${Be}/model-index.json`)).json(),n=Fe.get("model")||"BrainStem",r=Fe.get("variant")||"glTF",o=t.find((e=>e.name===n));e=`${Be}/${n}/${r}/${o.variants[r]}`}const t=await Oe({uri:e});Ue=t,Ve()}()})();