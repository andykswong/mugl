import{BYTE_MASK,vertexSize,vertexType,vertexNormalized,indexSize}from"../device/index.js";import{GLenum}from"../../common/gl/index.js";import{GL_EXT_DRAW_BUFFERS,GL_EXT_INSTANCING,MAX_VERTEX_ATTRIBS}from"./const.js";import{NGL_ENABLE_BLEND,NGL_ENABLE_MRT,NGL_ENABLE_OFFSCREEN,NGL_ENABLE_SCISSOR,NGL_ENABLE_STENCIL,NGL_ENABLE_TEXTURE}from"./config.js";import{GLBuffer,GLPipeline,GLRenderPass,GLShader,GLTexture,applyPipelineState}from"./resources.js";import{EMPTY_TEXTURE,renderPassLite}from"./stubs.js";export const getNGLDevice=(canvas,options)=>{const gl=canvas.getContext("webgl",options);if(!gl){return null}return new NanoGLRenderingDevice(gl)};class NanoGLRenderingDevice{constructor(gl){this.webgl2=false;this.gl=gl;this.canvas=gl.canvas;if(NGL_ENABLE_MRT){this.d=this.feature(GL_EXT_DRAW_BUFFERS)}this.r=new NanoGLRenderPassContext(gl,this.feature(GL_EXT_INSTANCING))}get width(){return this.gl.drawingBufferWidth}get height(){return this.gl.drawingBufferHeight}buffer(desc){return new GLBuffer(this.gl,desc)}texture(desc,sampler){if(NGL_ENABLE_TEXTURE){return new GLTexture(this.gl,desc,sampler)}return EMPTY_TEXTURE}shader(desc){return new GLShader(this.gl,desc)}pipeline(desc){return new GLPipeline(this.gl,desc)}pass(desc={}){if(NGL_ENABLE_TEXTURE&&NGL_ENABLE_OFFSCREEN){return new GLRenderPass(this.gl,desc,this.d)}return renderPassLite(desc)}render(pass){let width=this.width,height=this.height;if(NGL_ENABLE_OFFSCREEN){if(pass.props.color){({width,height}=pass.props.color[0].tex.props)}this.gl.bindFramebuffer(GLenum.FRAMEBUFFER,pass.glfb)}this.gl.viewport(0,0,width,height);if(NGL_ENABLE_SCISSOR){this.gl.disable(GLenum.SCISSOR_TEST)}let clearMask=0;if(pass.props.clearColor){clearMask|=GLenum.COLOR_BUFFER_BIT;this.gl.clearColor(...pass.props.clearColor);if(NGL_ENABLE_BLEND){this.gl.colorMask(true,true,true,true)}}if(!isNaN(pass.props.clearDepth)){clearMask|=GLenum.DEPTH_BUFFER_BIT;this.gl.clearDepth(pass.props.clearDepth);this.gl.depthMask(true)}if(NGL_ENABLE_STENCIL&&!isNaN(pass.props.clearStencil)){clearMask|=GLenum.STENCIL_BUFFER_BIT;this.gl.clearStencil(pass.props.clearStencil);this.gl.stencilMask(BYTE_MASK)}if(clearMask){this.gl.clear(clearMask)}return this.r}feature(extension){return this.gl.getExtension(extension)}reset(){this.r.reset()}}class NanoGLRenderPassContext{constructor(gl,inst){this.gl=gl;this.inst=inst;this.reset()}reset(){this.s={p:null,r:0}}pipeline(pipeline){if(this.s.p!==pipeline){this.s.p=pipeline;this.gl.useProgram(pipeline.glp);applyPipelineState(this.gl,pipeline.props,this.s.r);for(let i=0;i<MAX_VERTEX_ATTRIBS;++i){this.gl.disableVertexAttribArray(i)}for(const{attrs}of pipeline.props.buffers){for(const{shaderLoc}of attrs){this.gl.enableVertexAttribArray(shaderLoc)}}}return this}index({glb}){this.gl.bindBuffer(GLenum.ELEMENT_ARRAY_BUFFER,glb);return this}vertex(slot,{glb}){const{attrs,stride,instanced}=this.s.p.props.buffers[slot];this.gl.bindBuffer(GLenum.ARRAY_BUFFER,glb);for(const{format,offset,shaderLoc}of attrs){this.gl.vertexAttribPointer(shaderLoc,vertexSize(format),vertexType(format),vertexNormalized(format),stride,offset);this.inst&&this.inst.vertexAttribDivisorANGLE(shaderLoc,instanced?1:0)}return this}uniforms(bindings){let texId=0;for(const binding of bindings){const loc=this.gl.getUniformLocation(this.s.p.glp,binding.name);if(loc){if(binding.values||binding.valueBuffer){const uniform=this.s.p.props.uniforms.find(u=>u.name===binding.name);if(uniform){switch(uniform.valueFormat){case GLenum.FLOAT_MAT4:this.gl.uniformMatrix4fv(loc,false,binding.values||binding.valueBuffer);break;case GLenum.FLOAT_MAT3:this.gl.uniformMatrix3fv(loc,false,binding.values||binding.valueBuffer);break;case GLenum.FLOAT_VEC4:this.gl.uniform4fv(loc,binding.values||binding.valueBuffer);break;case GLenum.FLOAT_VEC3:this.gl.uniform3fv(loc,binding.values||binding.valueBuffer);break;case GLenum.FLOAT_VEC2:this.gl.uniform2fv(loc,binding.values||binding.valueBuffer);break;default:this.gl.uniform1fv(loc,binding.values||binding.valueBuffer);}}}else if(NGL_ENABLE_TEXTURE&&binding.tex){this.gl.activeTexture(GLenum.TEXTURE0+texId);this.gl.bindTexture(binding.tex.props.type,binding.tex.glt);this.gl.uniform1i(loc,texId++)}else if(!isNaN(binding.value)){this.gl.uniform1f(loc,binding.value)}}}return this}draw(vertexCount,instanceCount=1,firstVertex=0){const{props:{mode},i}=this.s.p;if(i){this.inst&&this.inst.drawArraysInstancedANGLE(mode,firstVertex,vertexCount,instanceCount)}else{this.gl.drawArrays(mode,firstVertex,vertexCount)}return this}drawIndexed(indexCount,instanceCount=1,firstIndex=0){const{props:{indexFormat,mode},i}=this.s.p;if(i){this.inst&&this.inst.drawElementsInstancedANGLE(mode,indexCount,indexFormat,firstIndex*indexSize(indexFormat),instanceCount)}else{this.gl.drawElements(mode,indexCount,indexFormat,firstIndex*indexSize(indexFormat))}return this}viewport(x,y,width,height){this.gl.viewport(x,y,width,height);return this}scissor(x,y,width,height){if(NGL_ENABLE_SCISSOR){this.gl.scissor(x,y,width,height)}return this}blendColor(color){if(NGL_ENABLE_BLEND){this.gl.blendColor(...color)}return this}stencilRef(stencilRef){if(NGL_ENABLE_STENCIL){const stencil=this.s.p&&this.s.p.props.stencil;if(stencil){var _stencil$readMask;const readMask=(_stencil$readMask=stencil.readMask)!==null&&_stencil$readMask!==void 0?_stencil$readMask:BYTE_MASK;this.gl.stencilFuncSeparate(GLenum.FRONT,stencil.frontCompare||GLenum.ALWAYS,stencilRef,readMask);this.gl.stencilFuncSeparate(GLenum.BACK,stencil.backCompare||GLenum.ALWAYS,stencilRef,readMask)}this.s.r=stencilRef}return this}end(){}}
//# sourceMappingURL=device.js.map