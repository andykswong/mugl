import{array,mat4,quat,transform,vec3}from"munum";import{getAnimationDuration,getAnimationSamplerInput,getAnimationSamplerOutput,getExtras,getInverseBindMatrices}from"./gltf-utils.js";const I4=mat4.create();const Iq=quat.create();const S3=vec3.create(1,1,1);const Z3=vec3.create();export function updateGlTF(glTF,options={}){var _glTF$scenes,_glTF$scenes2,_options$scene;let activeNodes=[];const rootNodes=(_glTF$scenes=glTF.scenes)===null||_glTF$scenes===void 0?void 0:(_glTF$scenes2=_glTF$scenes[((_options$scene=options.scene)!==null&&_options$scene!==void 0?_options$scene:glTF.scene)||0])===null||_glTF$scenes2===void 0?void 0:_glTF$scenes2.nodes;if(rootNodes){for(let i=0;i<rootNodes.length;++i){updateGlTFNode(glTF,rootNodes[i],I4,activeNodes)}}activeNodes=activeNodes.sort().filter((n,i,a)=>!i||n!==a[i-1]);for(const nodeId of activeNodes){const node=glTF.nodes[nodeId];if("camera"in node){updateGlTFCamera(glTF,node)}if("skin"in node){updateGlTFSkin(glTF,node)}}return activeNodes}export function updateGlTFAnimation(glTF,animation,time=0,loop=false){var _targetNode$weights,_glTF$meshes,_glTF$meshes2,_glTF$meshes2$weights;const duration=getAnimationDuration(glTF,animation);const currentTime=loop?time-Math.floor(time/duration)*duration:Math.min(time,duration);for(const channel of animation.channels){var _glTF$nodes;const targetNode=(_glTF$nodes=glTF.nodes)===null||_glTF$nodes===void 0?void 0:_glTF$nodes[channel.target.node];const sampler=animation.samplers[channel.sampler];if(!targetNode||!sampler){continue}const input=getAnimationSamplerInput(glTF,sampler);const output=getAnimationSamplerOutput(glTF,sampler);if(!(input!==null&&input!==void 0&&input.length)||!output){continue}const sampleCount=input.length;const startTime=input[0];const endTime=input[sampleCount-1];let currentKeyframe;let nextKeyframe;if(currentTime<=startTime){currentKeyframe=nextKeyframe=0}else if(currentTime>=endTime){currentKeyframe=nextKeyframe=sampleCount-1}else{let lastKeyFrame=getExtras(channel).lastKeyframe||0;if(input[lastKeyFrame]>currentTime){lastKeyFrame=0}for(currentKeyframe=lastKeyFrame,nextKeyframe=currentKeyframe+1;nextKeyframe<sampleCount;++currentKeyframe,++nextKeyframe){if(input[currentKeyframe]<=currentTime&&input[nextKeyframe]>currentTime){break}}}getExtras(channel).lastKeyframe=currentKeyframe;const path=channel.target.path;let componentSize=3;switch(path){case"rotation":componentSize=4;break;case"weights":componentSize=((_targetNode$weights=targetNode.weights)===null||_targetNode$weights===void 0?void 0:_targetNode$weights.length)||((_glTF$meshes=glTF.meshes)===null||_glTF$meshes===void 0?void 0:(_glTF$meshes2=_glTF$meshes[targetNode.mesh])===null||_glTF$meshes2===void 0?void 0:(_glTF$meshes2$weights=_glTF$meshes2.weights)===null||_glTF$meshes2$weights===void 0?void 0:_glTF$meshes2$weights.length)||0;break;}if(!componentSize){continue}let interpolation=sampler.interpolation;if(currentKeyframe===nextKeyframe){interpolation="STEP"}const previousTime=input[currentKeyframe];const nextTime=input[nextKeyframe];const t=(currentTime-previousTime)/(nextTime-previousTime);const value=getExtras(targetNode)[path]=getExtras(targetNode)[path]||new Array(componentSize);const tmp=new Array(componentSize);switch(interpolation){case"STEP":array.copy(output,value,currentKeyframe*componentSize,0,componentSize);break;case"CUBICSPLINE":{const deltaTime=nextTime-previousTime;const t2=t*t,t3=t*t2;for(let i=0;i<componentSize;++i){value[i]=(2*t3-3*t2+1)*output[(currentKeyframe*3+1)*componentSize+i]+(t3-2*t2+t)*deltaTime*output[(currentKeyframe*3+2)*componentSize+i]+(-2*t3+3*t2)*output[(nextKeyframe*3+1)*componentSize+i]+(t3-t2)*deltaTime*output[nextKeyframe*3*componentSize+i]}break}default:{if(path==="rotation"){array.copy(output,value,currentKeyframe*componentSize,0,componentSize);array.copy(output,tmp,nextKeyframe*componentSize,0,componentSize);quat.slerp(value,tmp,t,value)}else{for(let i=0;i<componentSize;++i){value[i]=(1-t)*output[currentKeyframe*componentSize+i]+t*output[nextKeyframe*componentSize+i]}}break}}}return time<duration}function updateGlTFNode(glTF,nodeId,origin,activeNodes=null){var _glTF$nodes2;const node=(_glTF$nodes2=glTF.nodes)===null||_glTF$nodes2===void 0?void 0:_glTF$nodes2[nodeId];if(!node){return}activeNodes===null||activeNodes===void 0?void 0:activeNodes.push(nodeId);const nodeExtras=getExtras(node);const matrix=nodeExtras.matrix=nodeExtras.matrix||mat4.create();if(node.matrix){mat4.copy(node.matrix,matrix)}else if(node.rotation||node.scale||node.translation||nodeExtras.rotation||nodeExtras.scale||nodeExtras.translation){transform(nodeExtras.translation||node.translation||Z3,nodeExtras.rotation||node.rotation||Iq,nodeExtras.scale||node.scale||S3,matrix)}const model=nodeExtras.model=mat4.mul(origin,matrix,nodeExtras.model||mat4.create());if(node.children){for(const child of node.children){updateGlTFNode(glTF,child,model,activeNodes)}}}function updateGlTFCamera(glTF,node){var _glTF$cameras;const camera=(_glTF$cameras=glTF.cameras)===null||_glTF$cameras===void 0?void 0:_glTF$cameras[node.camera];if(camera){const model=getExtras(node).model=getExtras(node).model||I4;getExtras(camera).view=mat4.invert(model,getExtras(camera).view||mat4.create());getExtras(camera).translation=[model[12],model[13],model[14]]}}function updateGlTFSkin(glTF,node){var _glTF$skins;const skin=(_glTF$skins=glTF.skins)===null||_glTF$skins===void 0?void 0:_glTF$skins[node.skin];if(skin){const numJoints=skin.joints.length;const jointMatrix=getExtras(node).jointMatrix=getExtras(node).jointMatrix||new Float32Array(numJoints*16);const inverseBindMatrices=getInverseBindMatrices(glTF,skin);for(let i=0;i<numJoints;++i){const jointNode=glTF.nodes[skin.joints[i]];const jointMat=new Float32Array(jointMatrix.buffer,jointMatrix.byteOffset+16*4*i,16);const invBind=new Float32Array(inverseBindMatrices.buffer,inverseBindMatrices.byteOffset+16*4*i,16);mat4.invert(getExtras(node).model||I4,jointMat);mat4.mul(jointMat,jointNode&&getExtras(jointNode).model||I4,jointMat);mat4.mul(jointMat,invBind,jointMat)}}}
//# sourceMappingURL=update.js.map