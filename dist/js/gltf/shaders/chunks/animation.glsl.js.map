{"version":3,"sources":["../../../../../src/js/gltf/shaders/chunks/animation.glsl.ts"],"names":["MUGL_TF_MORPH_TARGETS","addTarget","out","attr","frag","i","MORPH_FN","map","join"],"mappings":"OAASA,qB,uBAET,QAASC,CAAAA,SAAT,CAAmBC,GAAnB,CAAgCC,IAAhC,CAAsD,CACpD,GAAIC,CAAAA,IAAI,CAAG,EAAX,CACA,IAAK,GAAIC,CAAAA,CAAC,CAAG,CAAb,CAAgBA,CAAC,CAAGL,qBAApB,CAA2C,EAAEK,CAA7C,CAAgD,CAC9CD,IAAI,EAAK;AACb,aAAaD,IAAK,IAAGE,CAAE;AACvB,IAAIH,GAAI,qBAAoBG,CAAE,OAAMF,IAAK,IAAGE,CAAE;AAC9C;AACA,CACG,CACD,MAAOD,CAAAA,IACR,CAED,KAAME,CAAAA,QAAQ,CAAGN,qBAAqB,CAAI;AAC1C,EAAE,CAAC,UAAD,CAAa,QAAb,CAAuB,SAAvB,EAAkCO,GAAlC,CAA+CJ,IAAD,EAA0B,CACxE,GAAIC,CAAAA,IAAI,CAAG,EAAX,CACA,IAAK,GAAIC,CAAAA,CAAC,CAAG,CAAb,CAAgBA,CAAC,CAAGL,qBAApB,CAA2C,EAAEK,CAA7C,CAAgD,CAC9CD,IAAI,EAAK;AACb,aAAaD,IAAK,IAAGE,CAAE;AACvB,mBAAmBF,IAAK,IAAGE,CAAE;AAC7B;AACA,CACG,CACD,MAAOD,CAAAA,IACR,CAVC,EAUCI,IAVD,CAUM,IAVN,CAUY;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAIP,SAAS,CAAC,SAAD,CAAY,UAAZ,CAAwB;AACrC;AACA;AACA;AACA;AACA;AACA,IAAIA,SAAS,CAAC,QAAD,CAAW,QAAX,CAAqB;AAClC;AACA;AACA;AACA;AACA;AACA,IAAIA,SAAS,CAAC,SAAD,CAAY,SAAZ,CAAuB;AACpC;AACA;AACA;AACA;AACA,CAxCsC,CAwClC,EAxCJ,CA4CA,cAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAEK,QAAS;AACX,CA7BA","sourcesContent":["import { MUGL_TF_MORPH_TARGETS } from '../../config';\r\n\r\nfunction addTarget(out: string, attr: string): string {\r\n  let frag = '';\r\n  for (let i = 0; i < MUGL_TF_MORPH_TARGETS; ++i) {\r\n    frag += `\r\n#ifdef USE_${attr}_${i}\r\n  ${out} += targetWeights[${i}] * ${attr}_${i};\r\n#endif\r\n`;\r\n  }\r\n  return frag;\r\n}\r\n\r\nconst MORPH_FN = MUGL_TF_MORPH_TARGETS ? `\r\n${['POSITION', 'NORMAL', 'TANGENT'].map<string>((attr: string): string => {\r\n  let frag = '';\r\n  for (let i = 0; i < MUGL_TF_MORPH_TARGETS; ++i) {\r\n    frag += `\r\n#ifdef USE_${attr}_${i}\r\n  attribute vec3 ${attr}_${i};\r\n#endif\r\n`;\r\n  }\r\n  return frag;\r\n}).join('\\n')}\r\n\r\n#if defined(USE_POSITION_0) || defined(USE_NORMAL_0) || defined(USE_TANGENT_0)\r\n#define USE_MORPH\r\n#ifndef NUM_MORPHS\r\n#define NUM_MORPHS 8\r\n#endif\r\n\r\nuniform float targetWeights[NUM_MORPHS];\r\n\r\nvec4 getTargetPosition() {\r\n  vec4 pos = vec4(0);\r\n  ${addTarget('pos.xyz', 'POSITION')}\r\n  return pos;\r\n}\r\n\r\nvec3 getTargetNormal() {\r\n  vec3 normal = vec3(0);\r\n  ${addTarget('normal', 'NORMAL')}\r\n  return normal;\r\n}\r\n\r\nvec3 getTargetTangent() {\r\n  vec3 tangent = vec3(0);\r\n  ${addTarget('tangent', 'TANGENT')}\r\n  return tangent;\r\n}\r\n\r\n#endif\r\n` : '';\r\n\r\n// TODO: Do we need inverse transpose joint matrix for normal matrix?\r\n// TODO: To support min MAX_VERTEX_UNIFORM_VECTORS = 128, use bone texture instead?\r\nexport default `\r\n#ifdef USE_JOINTS_0\r\nattribute vec4 JOINTS_0;\r\n#endif\r\n\r\n#ifdef USE_WEIGHTS_0\r\nattribute vec4 WEIGHTS_0;\r\n#endif\r\n\r\n#if defined(USE_WEIGHTS_0) && defined(USE_JOINTS_0)\r\n#define USE_SKIN\r\n\r\n#ifndef NUM_JOINTS\r\n#define NUM_JOINTS 24\r\n#endif\r\n\r\nuniform mat4 jointMatrix[NUM_JOINTS];\r\n\r\nmat4 getSkinMatrix() {\r\n  mat4 skin =\r\n    WEIGHTS_0.x * jointMatrix[int(JOINTS_0.x)] +\r\n    WEIGHTS_0.y * jointMatrix[int(JOINTS_0.y)] +\r\n    WEIGHTS_0.z * jointMatrix[int(JOINTS_0.z)] +\r\n    WEIGHTS_0.w * jointMatrix[int(JOINTS_0.w)];\r\n\r\n  return skin;\r\n}\r\n#endif\r\n${MORPH_FN}\r\n`;\r\n"],"file":"animation.glsl.js"}