import{mat4,ortho,perspective}from"munum";import{GLenum}from"../../common/gl/index.js";import{VertexFormat}from"../device/index.js";export function getExtras(property){if(!property.extras){property.extras={}}return property.extras}export function traverseNode(glTF,nodeId,callback,parent=null){var _glTF$nodes;const node=(_glTF$nodes=glTF.nodes)===null||_glTF$nodes===void 0?void 0:_glTF$nodes[nodeId];if(node&&!callback(node,parent)&&node.children){for(const childNodeId of node.children){traverseNode(glTF,childNodeId,callback,node)}}}export function getAnimationDuration(glTF,animation){let duration=getExtras(animation).duration||0;for(const channel of animation.channels){var _glTF$nodes2,_glTF$accessors,_animation$samplers$c;const targetNode=(_glTF$nodes2=glTF.nodes)===null||_glTF$nodes2===void 0?void 0:_glTF$nodes2[channel.target.node];const accessor=(_glTF$accessors=glTF.accessors)===null||_glTF$accessors===void 0?void 0:_glTF$accessors[(_animation$samplers$c=animation.samplers[channel.sampler])===null||_animation$samplers$c===void 0?void 0:_animation$samplers$c.input];if(targetNode&&accessor){var _accessor$max;duration=Math.max(duration,((_accessor$max=accessor.max)===null||_accessor$max===void 0?void 0:_accessor$max[0])||0)}}return getExtras(animation).duration=duration}export function getAnimationSamplerInput(glTF,sampler){let input=getExtras(sampler).input||null;if(!input){var _glTF$accessors2;const accessor=(_glTF$accessors2=glTF.accessors)===null||_glTF$accessors2===void 0?void 0:_glTF$accessors2[sampler.input];if(accessor){const{buffer,byteOffset=0}=getAccessorData(glTF,accessor);getExtras(sampler).input=input=new Float32Array(buffer.buffer,byteOffset+buffer.byteOffset,(buffer.byteLength-byteOffset)/4)}}return input}export function getAnimationSamplerOutput(glTF,sampler){let output=getExtras(sampler).output||null;if(!output){var _glTF$accessors3;const accessor=(_glTF$accessors3=glTF.accessors)===null||_glTF$accessors3===void 0?void 0:_glTF$accessors3[sampler.output];if(accessor){const{buffer,byteOffset=0}=getAccessorData(glTF,accessor);let Type=Float32Array;switch(accessor.componentType){case GLenum.BYTE:Type=Int8Array;break;case GLenum.UNSIGNED_BYTE:Type=Uint8Array;break;case GLenum.SHORT:Type=Uint16Array;break;case GLenum.UNSIGNED_SHORT:Type=Uint16Array;break;}getExtras(sampler).output=output=new Type(buffer.buffer,byteOffset+buffer.byteOffset,(buffer.byteLength-byteOffset)/Type.BYTES_PER_ELEMENT)}}return output}export function getAnimationOutputValue(buffer,index){if(buffer instanceof Int8Array){return Math.max(buffer[index]/127,-1)}if(buffer instanceof Uint8Array){return buffer[index]/255}if(buffer instanceof Int16Array){return Math.max(buffer[index]/32767,-1)}if(buffer instanceof Uint16Array){return buffer[index]/65535}return buffer[index]}export function getAccessorVertexFormat(accessor){switch(accessor.type){case"VEC2":if(accessor.componentType===GLenum.FLOAT){return VertexFormat.Float2}else if(accessor.componentType===GLenum.UNSIGNED_SHORT){return accessor.normalized?VertexFormat.UShort2N:VertexFormat.UShort2}else if(accessor.componentType===GLenum.UNSIGNED_BYTE){return accessor.normalized?VertexFormat.UChar2N:VertexFormat.UChar2}break;case"VEC3":if(accessor.componentType===GLenum.FLOAT){return VertexFormat.Float3}break;case"VEC4":if(accessor.componentType===GLenum.FLOAT){return VertexFormat.Float4}else if(accessor.componentType===GLenum.UNSIGNED_BYTE){return accessor.normalized?VertexFormat.UChar4N:VertexFormat.UChar4}else if(accessor.componentType===GLenum.UNSIGNED_SHORT){return accessor.normalized?VertexFormat.UShort4N:VertexFormat.UShort4}break;}return null}export function getAccessorElementSize(accessor){let length=0;switch(accessor.type){case"SCALAR":length=1;break;case"VEC2":length=2;break;case"VEC3":length=3;break;case"VEC4":case"MAT2":length=4;break;case"MAT3":length=9;break;case"MAT4":length=16;break;}let size=0;switch(accessor.componentType){case GLenum.BYTE:case GLenum.UNSIGNED_BYTE:size=1;break;case GLenum.SHORT:case GLenum.UNSIGNED_SHORT:size=2;break;case GLenum.UNSIGNED_INT:case GLenum.FLOAT:size=4;break;}return length*size}export function getAccessorData(glTF,accessor){var _glTF$bufferViews;let buffer=getExtras(accessor).buffer;let byteOffset=getExtras(accessor).byteOffset||0;if(buffer){return{buffer,byteOffset}}const elementSize=getAccessorElementSize(accessor);let bufferLength=accessor.count*elementSize;const bufferView=(_glTF$bufferViews=glTF.bufferViews)===null||_glTF$bufferViews===void 0?void 0:_glTF$bufferViews[accessor.bufferView];if(bufferView){const bufferViewData=getBufferViewData(glTF,bufferView);const alignment=bufferView.byteStride||1;byteOffset=(accessor.byteOffset||0)%alignment;bufferLength=accessor.count*(bufferView.byteStride||elementSize);const bufferOffset=(accessor.byteOffset||0)-byteOffset;buffer=new Uint8Array(bufferViewData.buffer,bufferViewData.byteOffset+bufferOffset,bufferLength)}if(accessor.sparse){var _glTF$bufferViews2,_glTF$bufferViews3;const{count,indices:{bufferView:indexViewId,byteOffset:indexViewOffset=0,componentType},values:{bufferView:valueViewId,byteOffset:valueViewOffset=0}}=accessor.sparse;const indexView=(_glTF$bufferViews2=glTF.bufferViews)===null||_glTF$bufferViews2===void 0?void 0:_glTF$bufferViews2[indexViewId];const valueView=(_glTF$bufferViews3=glTF.bufferViews)===null||_glTF$bufferViews3===void 0?void 0:_glTF$bufferViews3[valueViewId];if(indexView&&valueView){const sparseBuffer=new Uint8Array(bufferLength);if(buffer){sparseBuffer.set(buffer,byteOffset)}const indexBuffer=getBufferViewData(glTF,indexView);const valueBuffer=getBufferViewData(glTF,valueView);const IndexBufferType=componentType===GLenum.UNSIGNED_BYTE?Uint8Array:componentType===GLenum.UNSIGNED_SHORT?Uint16Array:Uint32Array;const indices=new IndexBufferType(indexBuffer.buffer,indexBuffer.byteOffset+indexViewOffset,count);const values=new Uint8Array(valueBuffer.buffer,valueBuffer.byteOffset+valueViewOffset,count*elementSize);for(let j=0;j<count;++j){const index=indices[j]*elementSize;for(let k=0;k<elementSize;++k){sparseBuffer[index+k]=values[j*elementSize+k]}}byteOffset=0;buffer=sparseBuffer}}if(buffer){getExtras(accessor).buffer=buffer;getExtras(accessor).byteOffset=byteOffset}else{buffer=new Uint8Array}return{buffer,byteOffset}}export function getBufferViewData(glTF,bufferView){let bufferViewData=getExtras(bufferView).buffer;if(!bufferViewData){var _glTF$buffers;const buffer=(_glTF$buffers=glTF.buffers)===null||_glTF$buffers===void 0?void 0:_glTF$buffers[bufferView.buffer];if(buffer){const bufferData=buffer.extras.buffer;bufferViewData=new Uint8Array(bufferData.buffer,bufferData.byteOffset+(bufferView.byteOffset||0),bufferView.byteLength)}else{bufferViewData=new Uint8Array}getExtras(bufferView).buffer=bufferViewData}return bufferViewData}export function getCameraProjection(out,camera,aspectRatio){if(camera!==null&&camera!==void 0&&camera.orthographic){ortho(-camera.orthographic.xmag,camera.orthographic.xmag,-camera.orthographic.xmag/(aspectRatio||1),camera.orthographic.xmag/(aspectRatio||1),camera.orthographic.znear,camera.orthographic.zfar,out)}else if(camera!==null&&camera!==void 0&&camera.perspective){perspective(aspectRatio||camera.perspective.aspectRatio||1,camera.perspective.yfov,camera.perspective.znear,camera.perspective.zfar||Infinity,out)}else{mat4.id(out)}return out}export function getInverseBindMatrices(glTF,skin){let matrices=getExtras(skin).inverseBindMatrices;if(!matrices){var _glTF$accessors4;const accessor=(_glTF$accessors4=glTF.accessors)===null||_glTF$accessors4===void 0?void 0:_glTF$accessors4[skin.inverseBindMatrices];if(accessor){const{buffer,byteOffset}=getAccessorData(glTF,accessor);matrices=new Float32Array(buffer.buffer,buffer.byteOffset+byteOffset,16*skin.joints.length)}else{matrices=new Float32Array(16*skin.joints.length)}getExtras(skin).inverseBindMatrices=matrices}return matrices}export function getSceneLights(glTF,scene){const lights=[];if(scene.nodes){for(const nodeId of scene.nodes){traverseNode(glTF,nodeId,node=>{var _node$extensions;const light=(_node$extensions=node.extensions)===null||_node$extensions===void 0?void 0:_node$extensions.KHR_lights_punctual;if(light){lights.push(light)}})}}return lights}
//# sourceMappingURL=gltf-utils.js.map