{"version":3,"sources":["../../../src/js/gltf/glb.ts"],"names":["decodeText","GLB_HEADER_MAGIC","GLB_HEADER_LENGTH","GLBChunkType","Json","Bin","isGLB","data","DataView","buffer","byteOffset","getUint32","parseGLB","glTF","binaryChunk","bufferOffset","headerView","Error","version","chunkView","chunkIndex","byteLength","chunkLength","chunkType","jsonChunk","Uint8Array","JSON","parse","asset","minVersion"],"mappings":"OAGSA,U,kBAET,KAAMC,CAAAA,gBAAgB,CAAG,UAAzB,CAEA,KAAMC,CAAAA,iBAAiB,CAAG,EAA1B,CAEA,KAAMC,CAAAA,YAAY,CAAG,CACnBC,IAAI,CAAE,UADa,CAEnBC,GAAG,CAAE,OAFc,CAArB,CAQA,MAAO,SAASC,CAAAA,KAAT,CAAeC,IAAf,CAA4C,CACjD,MAAO,IAAIC,CAAAA,QAAJ,CAAcD,IAAD,CAA0BE,MAA1B,EAAoCF,IAAjD,CAAwDA,IAAD,CAA0BG,UAA1B,EAAwC,CAA/F,CAAkG,CAAlG,EACJC,SADI,CACM,CADN,CACS,IADT,IACmBV,gBAC3B,CAKA,MAAO,SAASW,CAAAA,QAAT,CAAkBL,IAAlB,CAAsE,CAC5E,GAAIM,CAAAA,IAAJ,CACA,GAAIC,CAAAA,WAAJ,CAGA,KAAML,CAAAA,MAAmB,CAAIF,IAAD,CAA0BE,MAA1B,EAAoCF,IAAhE,CACA,KAAMQ,CAAAA,YAAY,CAAIR,IAAD,CAA0BG,UAA1B,EAAwC,CAA7D,CAGA,KAAMM,CAAAA,UAAU,CAAG,GAAIR,CAAAA,QAAJ,CAAaC,MAAb,CAAqBM,YAArB,CAAmCb,iBAAnC,CAAnB,CACA,GAAIc,UAAU,CAACL,SAAX,CAAqB,CAArB,CAAwB,IAAxB,IAAkCV,gBAAtC,CAAwD,CACtD,KAAM,IAAIgB,CAAAA,KAAJ,CAAU,oBAAV,CACP,CACD,KAAMC,CAAAA,OAAO,CAAGF,UAAU,CAACL,SAAX,CAAqB,CAArB,CAAwB,IAAxB,CAAhB,CACA,GAAIO,OAAO,GAAK,CAAhB,CAAmB,CACjB,KAAM,IAAID,CAAAA,KAAJ,CAAU,4BAA8BC,OAAxC,CACP,CAGD,KAAMC,CAAAA,SAAS,CAAG,GAAIX,CAAAA,QAAJ,CAAaC,MAAb,CAAqBM,YAAY,CAAGb,iBAApC,CAAlB,CACA,GAAIkB,CAAAA,UAAU,CAAG,CAAjB,CACA,MAAOA,UAAU,CAAGD,SAAS,CAACE,UAA9B,CAA0C,CACxC,KAAMC,CAAAA,WAAW,CAAGH,SAAS,CAACR,SAAV,CAAoBS,UAApB,CAAgC,IAAhC,CAApB,CACA,KAAMG,CAAAA,SAAS,CAAGJ,SAAS,CAACR,SAAV,CAAoBS,UAAU,CAAG,CAAjC,CAAoC,IAApC,CAAlB,CACAA,UAAU,EAAI,CAAd,CAEA,GAAIG,SAAS,GAAKpB,YAAY,CAACC,IAA/B,CAAqC,CACnC,KAAMoB,CAAAA,SAAS,CAAG,GAAIC,CAAAA,UAAJ,CAAehB,MAAf,CAAuBM,YAAY,CAAGb,iBAAf,CAAmCkB,UAA1D,CAAsEE,WAAtE,CAAlB,CACAT,IAAI,CAAGa,IAAI,CAACC,KAAL,CAAW3B,UAAU,CAACwB,SAAD,CAArB,CACR,CAHD,IAGO,IAAID,SAAS,GAAKpB,YAAY,CAACE,GAA/B,CAAoC,CACzCS,WAAW,CAAG,GAAIW,CAAAA,UAAJ,CAAehB,MAAf,CAAuBM,YAAY,CAAGb,iBAAf,CAAmCkB,UAA1D,CAAsEE,WAAtE,CACf,CAGDF,UAAU,EAAIE,WACf,CAGD,GAAI,CAACT,IAAL,CAAW,CACP,KAAM,IAAII,CAAAA,KAAJ,CAAU,0CAAV,CACT,CACD,GAAI,CAACJ,IAAI,CAACe,KAAN,EAAgBf,IAAI,CAACe,KAAL,CAAWC,UAAX,GAA0B,KAA1B,EAAmChB,IAAI,CAACe,KAAL,CAAWV,OAAX,GAAuB,KAA9E,CAAsF,CACpF,KAAM,IAAID,CAAAA,KAAJ,CAAU,wCAAV,CACP,CAED,MAAO,CAAEJ,IAAF,CAAQC,WAAR,CACR","sourcesContent":["import { MarkRequired } from 'ts-essentials';\r\nimport { GlTF } from '../gltf-spec/glTF2';\r\nimport { GlTFFile } from './types';\r\nimport { decodeText } from './utils';\r\n\r\nconst GLB_HEADER_MAGIC = 0x46546C67; // ASCII string 'glTF' in little endian\r\n\r\nconst GLB_HEADER_LENGTH = 12;\r\n\r\nconst GLBChunkType = {\r\n  Json: 0x4E4F534A,\r\n  Bin: 0x004E4942\r\n} as const;\r\n\r\n/**\r\n * Check if data is in GLB format, by checking the header magic\r\n */\r\nexport function isGLB(data: BufferSource): boolean {\r\n  return new DataView((data as ArrayBufferView).buffer || data, (data as ArrayBufferView).byteOffset || 0, 4)\r\n    .getUint32(0, true) === GLB_HEADER_MAGIC;\r\n}\r\n\r\n/**\r\n * Parse a GLB (binary glTF) binary blob into a GlTF JSON and binary data chunk.\r\n */\r\n export function parseGLB(data: BufferSource): MarkRequired<GlTFFile, 'glTF'> {\r\n  let glTF: GlTF | undefined;\r\n  let binaryChunk: Uint8Array | undefined;\r\n\r\n  // Get array buffer and offset from data\r\n  const buffer: ArrayBuffer = (data as ArrayBufferView).buffer || data;\r\n  const bufferOffset = (data as ArrayBufferView).byteOffset || 0;\r\n\r\n  // Validate header magic and version\r\n  const headerView = new DataView(buffer, bufferOffset, GLB_HEADER_LENGTH);\r\n  if (headerView.getUint32(0, true) !== GLB_HEADER_MAGIC) {\r\n    throw new Error('Invalid GLB format');\r\n  }\r\n  const version = headerView.getUint32(4, true);\r\n  if (version !== 2) {\r\n    throw new Error('Unsupported GLB version: ' + version);\r\n  }\r\n\r\n  // Parse binary chunks\r\n  const chunkView = new DataView(buffer, bufferOffset + GLB_HEADER_LENGTH);\r\n  let chunkIndex = 0;\r\n  while (chunkIndex < chunkView.byteLength) {\r\n    const chunkLength = chunkView.getUint32(chunkIndex, true);\r\n    const chunkType = chunkView.getUint32(chunkIndex + 4, true);\r\n    chunkIndex += 8;\r\n\r\n    if (chunkType === GLBChunkType.Json) {\r\n      const jsonChunk = new Uint8Array(buffer, bufferOffset + GLB_HEADER_LENGTH + chunkIndex, chunkLength);\r\n      glTF = JSON.parse(decodeText(jsonChunk));\r\n    } else if (chunkType === GLBChunkType.Bin) {\r\n      binaryChunk = new Uint8Array(buffer, bufferOffset + GLB_HEADER_LENGTH + chunkIndex, chunkLength);\r\n    }\r\n    // else ignore chunk\r\n\r\n    chunkIndex += chunkLength;\r\n  }\r\n\r\n  // Validate glTF JSON and version\r\n  if (!glTF) {\r\n      throw new Error('Invalid GLB format: missing JSON content');\r\n  }\r\n  if (!glTF.asset || (glTF.asset.minVersion !== '2.0' && glTF.asset.version !== '2.0')) {\r\n    throw new Error('Unsupported glTF version: 2.0 required');\r\n  }\r\n\r\n  return { glTF, binaryChunk };\r\n}\r\n"],"file":"glb.js"}