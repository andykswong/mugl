import{GLenum,IndexFormat,PrimitiveType,TexType,UniformFormat,UniformType,vertexByteSize}from"../../common/index.js";import{MAX_VERTEX_ATTRIBS}from"./const.js";import{DEFAULT_RASTER_STATE,DEFAULT_DEPTH_STATE,DEFAULT_STENCIL_STATE,DEFAULT_BLEND_STATE}from"./pipestate.js";import{createProgram}from"./shader.js";export class GLPipeline{constructor(context,props){var _props$mode;const gl=this.gl=context.gl;const hasAttr=Array(MAX_VERTEX_ATTRIBS);let nextShaderLoc=0;let hasInstanced=false;const buffers=props.buffers.map(({attrs:descAttrs,stride=0,instanced=false})=>{hasInstanced=hasInstanced||instanced;const attrs=Array(descAttrs.length);let maxOffset=0,minOffset=descAttrs.length>0?Infinity:0;for(let j=0;j<descAttrs.length;++j){const{offset=maxOffset,shaderLoc=nextShaderLoc}=descAttrs[j];attrs[j]={...descAttrs[j],offset,shaderLoc};hasAttr[nextShaderLoc=shaderLoc]=true;while(hasAttr[++nextShaderLoc]);maxOffset=Math.max(maxOffset,offset+vertexByteSize(attrs[j].format));minOffset=Math.min(minOffset,offset)}return{attrs,stride:stride||maxOffset-minOffset,instanced}});const uniforms=(props.uniforms||[]).map(uniform=>({name:uniform.name,type:uniform.type||UniformType.Value,texType:uniform.texType||TexType.Tex2D,valueFormat:uniform.valueFormat||UniformFormat.Float}));this.instanced=hasInstanced;this.props={vert:props.vert,frag:props.frag,indexFormat:props.indexFormat||IndexFormat.UInt16,mode:(_props$mode=props.mode)!==null&&_props$mode!==void 0?_props$mode:PrimitiveType.Tri,buffers,uniforms,raster:{...DEFAULT_RASTER_STATE,...props.raster},depth:props.depth?{...DEFAULT_DEPTH_STATE,...props.depth}:null,stencil:props.stencil?{...DEFAULT_STENCIL_STATE,...props.stencil}:null,blend:props.blend?{...DEFAULT_BLEND_STATE,...props.blend}:null};const glp=this.glp=createProgram(gl,props.vert,props.frag,buffers);const cache=this.cache={};let bufCount=0;let texCount=0;for(let i=0;i<uniforms.length;++i){const uniform=uniforms[i];let loc=null;let index=GLenum.INVALID_INDEX;if(uniform.type===UniformType.Buffer){index=gl.getUniformBlockIndex(glp,uniform.name);gl.uniformBlockBinding(glp,index,bufCount++)}else{loc=gl.getUniformLocation(glp,uniform.name)}if(loc!==null||index!==GLenum.INVALID_INDEX){cache[uniform.name]={...uniform,loc,index,binding:uniform.type===UniformType.Tex?texCount++:uniform.type===UniformType.Buffer?bufCount:-1}}}}destroy(){this.gl.deleteProgram(this.glp);this.glp=null}}
//# sourceMappingURL=pipeline.js.map