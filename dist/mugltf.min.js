var e,n;e=self,n=function(){return(()=>{var e={d:(n,t)=>{for(var o in t)e.o(t,o)&&!e.o(n,o)&&Object.defineProperty(n,o,{enumerable:!0,get:t[o]})},o:(e,n)=>Object.prototype.hasOwnProperty.call(e,n),r:e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},n={};function t(e,n,t=0,o=0,r=e.length-t){for(let i=0;i<r;++i)n[o+i]=e[t+i];return n}function o(e,n,t){for(let o=0;o<e.length;++o)t[o]=e[o]*n;return t}e.r(n),e.d(n,{glTFResourceFetch:()=>Q,renderGlTF:()=>B,resolveGlTF:()=>K,updateGlTF:()=>I,updateGlTFAnimation:()=>R});const r=[1,0,0,0,1,0,0,0,1],i=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1];function a(e){for(let n=0;n<16;++n)e[n]=n%5?0:1;return e}function l(e,n=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]){return t(e,n)}function s(e,n,o=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]){return t(function(e,n,t,o){const r=n.length/4,i=t.length/4;let a=0;for(let e=0;e<i;++e)for(let i=0;i<r;++i){a=0;for(let o=0;o<4;++o)a+=n[o*r+i]*t[4*e+o];o[e*r+i]=a}return o}(0,e,n,i),o)}function f(e,n=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]){const t=e[0]*e[5]-e[4]*e[1],r=e[0]*e[9]-e[8]*e[1],a=e[0]*e[13]-e[12]*e[1],l=e[4]*e[9]-e[8]*e[5],s=e[4]*e[13]-e[12]*e[5],f=e[8]*e[13]-e[12]*e[9],c=e[2]*e[7]-e[6]*e[3],u=e[2]*e[11]-e[10]*e[3],v=e[2]*e[15]-e[14]*e[3],d=e[6]*e[11]-e[10]*e[7],m=e[6]*e[15]-e[14]*e[7],g=e[10]*e[15]-e[14]*e[11],p=t*g-r*m+a*d+l*v-s*u+f*c;return p?(i[0]=+e[5]*g-e[9]*m+e[13]*d,i[1]=-e[1]*g+e[9]*v-e[13]*u,i[2]=+e[1]*m-e[5]*v+e[13]*c,i[3]=-e[1]*d+e[5]*u-e[9]*c,i[4]=-e[4]*g+e[8]*m-e[12]*d,i[5]=+e[0]*g-e[8]*v+e[12]*u,i[6]=-e[0]*m+e[4]*v-e[12]*c,i[7]=+e[0]*d-e[4]*u+e[8]*c,i[8]=+e[7]*f-e[11]*s+e[15]*l,i[9]=-e[3]*f+e[11]*a-e[15]*r,i[10]=+e[3]*s-e[7]*a+e[15]*t,i[11]=-e[3]*l+e[7]*r-e[11]*t,i[12]=-e[6]*f+e[10]*s-e[14]*l,i[13]=+e[2]*f-e[10]*a+e[14]*r,i[14]=-e[2]*s+e[6]*a-e[14]*t,i[15]=+e[2]*l-e[6]*r+e[10]*t,function(e,n,t=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]){return o(e,n,t)}(i,1/p,n)):null}function c(e=0,n=0,t=0,o=0){return[e,n,t,o]}function u(e=0,n=0,t=0){return[e,n,t]}c(),u(),c(),c();const v=5121,d=5123,m=5126,g=3553,p=m,h=35676;function T(e,n,t,o=[0,0,0,1]){let r=function(e,n){let t=0;for(let o=0;o<e.length;++o)t+=e[o]*n[o];return t}(e,n),i=1;r<0&&(r*=-1,i=-1);let a=1-t,l=t;if(1-r>1e-6){const e=Math.acos(r),n=Math.sin(e);a=Math.sin((1-t)*e)/n,l=Math.sin(t*e)/n}return l*=i,o[0]=e[0]*a+n[0]*l,o[1]=e[1]*a+n[1]*l,o[2]=e[2]*a+n[2]*l,o[3]=e[3]*a+n[3]*l,o}function b(e){return e.extras||(e.extras={}),e.extras}function x(e,n){let t=b(n).input||null;if(!t){var o;const r=null===(o=e.accessors)||void 0===o?void 0:o[n.input];if(r){const{buffer:o,byteOffset:i=0}=C(e,r);b(n).input=t=new Float32Array(o.buffer,i+o.byteOffset,(o.byteLength-i)/4)}}return t}function y(e,n){let t=b(n).output||null;if(!t){var o;const r=null===(o=e.accessors)||void 0===o?void 0:o[n.output];if(r){const{buffer:o,byteOffset:i=0}=C(e,r);let a=Float32Array;switch(r.componentType){case 5120:a=Int8Array;break;case v:a=Uint8Array;break;case 5122:case d:a=Uint16Array}b(n).output=t=new a(o.buffer,i+o.byteOffset,(o.byteLength-i)/a.BYTES_PER_ELEMENT)}}return t}function O(e){switch(e.type){case"VEC2":if(e.componentType===m)return 512;if(e.componentType===d)return e.normalized?66052:516;if(e.componentType===v)return e.normalized?66050:514;break;case"VEC3":if(e.componentType===m)return 768;break;case"VEC4":if(e.componentType===m)return 1024;if(e.componentType===v)return e.normalized?66562:1026;if(e.componentType===d)return e.normalized?66564:1028}return null}function C(e,n){var t;let o=b(n).buffer,r=b(n).byteOffset||0;if(o)return{buffer:o,byteOffset:r};const i=function(e){let n=0;switch(e.type){case"SCALAR":n=1;break;case"VEC2":n=2;break;case"VEC3":n=3;break;case"VEC4":case"MAT2":n=4;break;case"MAT3":n=9;break;case"MAT4":n=16}let t=0;switch(e.componentType){case 5120:case v:t=1;break;case 5122:case d:t=2;break;case 5125:case m:t=4}return n*t}(n);let a=n.count*i;const l=null===(t=e.bufferViews)||void 0===t?void 0:t[n.bufferView];if(l){const t=_(e,l),s=l.byteStride||1;r=(n.byteOffset||0)%s,a=n.count*(l.byteStride||i);const f=(n.byteOffset||0)-r;o=new Uint8Array(t.buffer,t.byteOffset+f,a)}if(n.sparse){var s,f;const{count:t,indices:{bufferView:l,byteOffset:c=0,componentType:u},values:{bufferView:m,byteOffset:g=0}}=n.sparse,p=null===(s=e.bufferViews)||void 0===s?void 0:s[l],h=null===(f=e.bufferViews)||void 0===f?void 0:f[m];if(p&&h){const n=new Uint8Array(a);o&&n.set(o,r);const l=_(e,p),s=_(e,h),f=new(u===v?Uint8Array:u===d?Uint16Array:Uint32Array)(l.buffer,l.byteOffset+c,t),m=new Uint8Array(s.buffer,s.byteOffset+g,t*i);for(let e=0;e<t;++e){const t=f[e]*i;for(let o=0;o<i;++o)n[t+o]=m[e*i+o]}r=0,o=n}}return o?(b(n).buffer=o,b(n).byteOffset=r):o=new Uint8Array,{buffer:o,byteOffset:r}}function _(e,n){let t=b(n).buffer;if(!t){var o;const r=null===(o=e.buffers)||void 0===o?void 0:o[n.buffer];if(r){const e=r.extras.buffer;t=new Uint8Array(e.buffer,e.byteOffset+(n.byteOffset||0),n.byteLength)}else t=new Uint8Array;b(n).buffer=t}return t}function S(e,n){let t="";for(let o=0;o<8;++o)t+=`\n#ifdef USE_${n}_${o}\n  ${e} += targetWeights[${o}] * ${n}_${o};\n#endif\n`;return t}u(),u(),u();const F=`\nprecision highp float;\n\nuniform mat4 model;\nuniform mat4 viewProj;\nuniform mat3 normalMatrix;\n\n#ifdef USE_COLOR_0\n#if defined(COLOR_0_VEC3)\nattribute vec3 COLOR_0;\n#else\nattribute vec4 COLOR_0;\n#endif\nvarying vec4 vColor0;\n#endif\n\n#ifdef USE_TEXCOORD_0\nattribute vec2 TEXCOORD_0;\n#endif\n#ifdef USE_TEXCOORD_1\nattribute vec2 TEXCOORD_1;\n#endif\n\nvarying vec2 vTexCoord0;\nvarying vec2 vTexCoord1;\n\n\n#ifdef USE_JOINTS_0\nattribute vec4 JOINTS_0;\n#endif\n\n#ifdef USE_WEIGHTS_0\nattribute vec4 WEIGHTS_0;\n#endif\n\n#if defined(USE_WEIGHTS_0) && defined(USE_JOINTS_0)\n#define USE_SKIN\n\n#ifndef NUM_JOINTS\n#define NUM_JOINTS 24\n#endif\n\nuniform mat4 jointMatrix[NUM_JOINTS];\n\nmat4 getSkinMatrix() {\n  mat4 skin =\n    WEIGHTS_0.x * jointMatrix[int(JOINTS_0.x)] +\n    WEIGHTS_0.y * jointMatrix[int(JOINTS_0.y)] +\n    WEIGHTS_0.z * jointMatrix[int(JOINTS_0.z)] +\n    WEIGHTS_0.w * jointMatrix[int(JOINTS_0.w)];\n\n  return skin;\n}\n#endif\n\n${["POSITION","NORMAL","TANGENT"].map((e=>{let n="";for(let t=0;t<8;++t)n+=`\n#ifdef USE_${e}_${t}\n  attribute vec3 ${e}_${t};\n#endif\n`;return n})).join("\n")}\n\n#if defined(USE_POSITION_0) || defined(USE_NORMAL_0) || defined(USE_TANGENT_0)\n#define USE_MORPH\n#ifndef NUM_MORPHS\n#define NUM_MORPHS 8\n#endif\n\nuniform float targetWeights[NUM_MORPHS];\n\nvec4 getTargetPosition() {\n  vec4 pos = vec4(0);\n  ${S("pos.xyz","POSITION")}\n  return pos;\n}\n\nvec3 getTargetNormal() {\n  vec3 normal = vec3(0);\n  ${S("normal","NORMAL")}\n  return normal;\n}\n\nvec3 getTargetTangent() {\n  vec3 tangent = vec3(0);\n  ${S("tangent","TANGENT")}\n  return tangent;\n}\n\n#endif\n\n\n\nattribute vec3 POSITION;\nvarying vec3 vPosition;\n\nvec4 getPosition() {\n  vec4 pos = vec4(POSITION, 1.0);\n\n#ifdef USE_MORPH\n  pos += getTargetPosition();\n#endif\n#ifdef USE_SKIN\n  pos = getSkinMatrix() * pos;\n#endif\n\n  return pos;\n}\n\n#ifdef USE_NORMAL\nattribute vec3 NORMAL;\n\n#ifdef USE_TANGENT\nattribute vec4 TANGENT;\nvarying mat3 vTBN;\n\nvec3 getTangent() {\n  vec3 tan = TANGENT.xyz;\n\n#ifdef USE_MORPH\n  tan += getTargetTangent();\n#endif\n#ifdef USE_SKIN\n  tan = mat3(getSkinMatrix()) * tan;\n#endif\n\n  return normalize(tan);\n}\n#else\nvarying vec3 vNormal;\n#endif\n\nvec3 getNormal() {\n  vec3 norm = NORMAL;\n\n#ifdef USE_MORPH\n  norm += getTargetNormal();\n#endif\n#ifdef USE_SKIN\n  norm = mat3(getSkinMatrix()) * norm;\n#endif\n\n  return normalize(norm);\n}\n\n#endif\n\nvoid main(void) {\n  vec4 pos = model * getPosition();\n  vPosition = pos.xyz / pos.w;\n\n#ifdef USE_NORMAL\n#ifdef USE_TANGENT\n  vec3 tan = getTangent();\n  vec3 normW = normalize(normalMatrix * getNormal());\n  vec3 tanW = normalize(normalMatrix * tan);\n  vec3 bitanW = cross(normW, tanW) * TANGENT.w;\n  vTBN = mat3(tanW, bitanW, normW);\n#else\n  vNormal = normalize(normalMatrix * NORMAL);\n#endif\n#endif\n\n#ifdef USE_COLOR_0\n#if defined(COLOR_0_VEC3)\n  vColor0 = vec4(COLOR_0, 1.0);\n#else\n  vColor0 = COLOR_0;\n#endif\n#endif\n\n  vTexCoord0 = vec2(0.0, 0.0);\n  vTexCoord1 = vec2(0.0, 0.0);\n#ifdef USE_TEXCOORD_0\n  vTexCoord0 = TEXCOORD_0;\n#endif\n#ifdef USE_TEXCOORD_1\n  vTexCoord1 = TEXCOORD_1;\n#endif\n\n  gl_Position = viewProj * pos;\n  gl_PointSize = 1.0;\n}\n`,w=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],E=[0,0,0,1],N=u(1,1,1),L=u();function I(e,n={}){var t,o,r;let i=[];const a=null===(t=e.scenes)||void 0===t||null===(o=t[(null!==(r=n.scene)&&void 0!==r?r:e.scene)||0])||void 0===o?void 0:o.nodes;if(a)for(let n=0;n<a.length;++n)M(e,a[n],w,i);i=i.sort().filter(((e,n,t)=>!n||e!==t[n-1]));for(const n of i){const t=e.nodes[n];"camera"in t&&A(e,t),"skin"in t&&U(e,t)}return i}function R(e,n,o=0,r=!1){var i,a,l,s;const f=function(e,n){let t=b(n).duration||0;for(const l of n.channels){var o,r,i;const s=null===(o=e.nodes)||void 0===o?void 0:o[l.target.node],f=null===(r=e.accessors)||void 0===r?void 0:r[null===(i=n.samplers[l.sampler])||void 0===i?void 0:i.input];var a;s&&f&&(t=Math.max(t,(null===(a=f.max)||void 0===a?void 0:a[0])||0))}return b(n).duration=t}(e,n),c=r?o-Math.floor(o/f)*f:Math.min(o,f);for(const o of n.channels){var u;const r=null===(u=e.nodes)||void 0===u?void 0:u[o.target.node],f=n.samplers[o.sampler];if(!r||!f)continue;const v=x(e,f),d=y(e,f);if(null==v||!v.length||!d)continue;const m=v.length,g=v[0],p=v[m-1];let h,O;if(c<=g)h=O=0;else if(c>=p)h=O=m-1;else{let e=b(o).lastKeyframe||0;for(v[e]>c&&(e=0),h=e,O=h+1;O<m&&!(v[h]<=c&&v[O]>c);++h,++O);}b(o).lastKeyframe=h;const C=o.target.path;let _=3;switch(C){case"rotation":_=4;break;case"weights":_=(null===(i=r.weights)||void 0===i?void 0:i.length)||(null===(a=e.meshes)||void 0===a||null===(l=a[r.mesh])||void 0===l||null===(s=l.weights)||void 0===s?void 0:s.length)||0}if(!_)continue;let S=f.interpolation;h===O&&(S="STEP");const F=v[h],w=v[O],E=(c-F)/(w-F),N=b(r)[C]=b(r)[C]||new Array(_),L=new Array(_);switch(S){case"STEP":t(d,N,h*_,0,_);break;case"CUBICSPLINE":{const e=w-F,n=E*E,t=E*n;for(let o=0;o<_;++o)N[o]=(2*t-3*n+1)*d[(3*h+1)*_+o]+(t-2*n+E)*e*d[(3*h+2)*_+o]+(-2*t+3*n)*d[(3*O+1)*_+o]+(t-n)*e*d[3*O*_+o];break}default:if("rotation"===C)t(d,N,h*_,0,_),t(d,L,O*_,0,_),T(N,L,E,N);else for(let e=0;e<_;++e)N[e]=(1-E)*d[h*_+e]+E*d[O*_+e]}}return o<f}function M(e,n,o,r=null){var i;const a=null===(i=e.nodes)||void 0===i?void 0:i[n];if(!a)return;null==r||r.push(n);const f=b(a),c=f.matrix=f.matrix||[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1];a.matrix?l(a.matrix,c):(a.rotation||a.scale||a.translation||f.rotation||f.scale||f.translation)&&function(e,n,o,r=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]){!function(e,n=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]){!function(e,n=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]){const t=e[0]*e[0],o=e[0]*e[1],r=e[0]*e[2],i=e[1]*e[1],a=e[1]*e[2],l=e[2]*e[2],s=e[3]*e[0],f=e[3]*e[1],c=e[3]*e[2];n[0]=1-2*(i+l),n[1]=2*(o+c),n[2]=2*(r-f),n[4]=2*(o-c),n[5]=1-2*(t+l),n[6]=2*(a+s),n[8]=2*(r+f),n[9]=2*(a-s),n[10]=1-2*(t+i),n[3]=n[7]=n[11]=n[12]=n[13]=n[14]=0,n[15]=1}(e,n)}(n,r);for(let e=0;e<3;++e)for(let n=0;n<3;++n)r[4*e+n]*=o[e];t(e,r,0,12,3)}(f.translation||a.translation||L,f.rotation||a.rotation||E,f.scale||a.scale||N,c);const u=f.model=s(o,c,f.model||[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]);if(a.children)for(const n of a.children)M(e,n,u,r)}function A(e,n){var t;const o=null===(t=e.cameras)||void 0===t?void 0:t[n.camera];if(o){const e=b(n).model=b(n).model||w;b(o).view=f(e,b(o).view||[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]),b(o).translation=[e[12],e[13],e[14]]}}function U(e,n){var t;const o=null===(t=e.skins)||void 0===t?void 0:t[n.skin];if(o){const t=o.joints.length,r=b(n).jointMatrix=b(n).jointMatrix||new Float32Array(16*t),i=function(e,n){let t=b(n).inverseBindMatrices;if(!t){var o;const r=null===(o=e.accessors)||void 0===o?void 0:o[n.inverseBindMatrices];if(r){const{buffer:o,byteOffset:i}=C(e,r);t=new Float32Array(o.buffer,o.byteOffset+i,16*n.joints.length)}else t=new Float32Array(16*n.joints.length);b(n).inverseBindMatrices=t}return t}(e,o);for(let a=0;a<t;++a){const t=e.nodes[o.joints[a]],l=new Float32Array(r.buffer,r.byteOffset+64*a,16),c=new Float32Array(i.buffer,i.byteOffset+64*a,16);f(b(n).model||w,l),s(l,t&&b(t).model||w,l),s(l,c,l)}}}const D=["POSITION","NORMAL","TANGENT"],P=/(POSITION|NORMAL|TANGENT)_(\d+)/,G=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],V=u(),H=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1];function B(e,n,t={}){var o,r,i;const l=(null!==(o=t.scene)&&void 0!==o?o:n.scene)||0,c=n.nodes,v=null===(r=n.scenes)||void 0===r||null===(i=r[l])||void 0===i?void 0:i.nodes;if(!c||!v)return;const d=I(n,{scene:l});let m=G,g=G,p=V;if(t.camera){var h;const o=null===(h=n.cameras)||void 0===h?void 0:h[t.camera.index||0];var T,b;o&&(m=(null===(T=o.extras)||void 0===T?void 0:T.view)||G,x=H,y=o,O=e.width/e.height,null!=y&&y.orthographic?function(e,n,t,o,r,i,l=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]){const s=1/(n-e),f=1/(o-t),c=1/(r-i);a(l),l[0]=2*s,l[5]=2*f,l[10]=2*c,l[12]=-(n+e)*s,l[13]=-(o+t)*f,l[14]=(r+i)*c}(-y.orthographic.xmag,y.orthographic.xmag,-y.orthographic.xmag/(O||1),y.orthographic.xmag/(O||1),y.orthographic.znear,y.orthographic.zfar,x):null!=y&&y.perspective?function(e,n,t,o=1/0,r=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]){const i=1/Math.tan(n/2);if(a(r),r[0]=i/e,r[5]=i,r[11]=-1,r[15]=0,isFinite(o)){const e=1/(t-o);r[10]=(t+o)*e,r[14]=2*t*o*e}else r[10]=-1,r[14]=-2*t}(O||y.perspective.aspectRatio||1,y.perspective.yfov,y.perspective.znear,y.perspective.zfar||1/0,x):a(x),g=x,p=(null===(b=o.extras)||void 0===b?void 0:b.translation)||V),t.camera.model&&(p=u(t.camera.model[12],t.camera.model[13],t.camera.model[14]),f(t.camera.model,m)),g=t.camera.proj||g}var x,y,O;const C={cameraPosition:p,viewProj:s(g,m,H)},_=e.pass(),S=e.render(_),F=[];for(let t=0;t<d.length;++t){var w;const o=c[d[t]],r=null===(w=n.meshes)||void 0===w?void 0:w[o.mesh];if(r)for(let t=0;t<r.primitives.length;++t){var E,N;const i=r.primitives[t];"BLEND"===(null===(E=n.materials)||void 0===E||null===(N=E[i.material])||void 0===N?void 0:N.alphaMode)?F.push({node:o,mesh:r,primitive:i}):z(e,S,n,o,r,i,C)}}for(const t of F)z(e,S,n,t.node,t.mesh,t.primitive,C);S.end(),_.destroy()}function z(e,n,t,i,a,s,f){var c,u,v,d;f.model=l(b(i).model||G,f.model||[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]),function(e,n=[1,0,0,0,1,0,0,0,1]){return function(e,n=[1,0,0,0,1,0,0,0,1]){return function(e,n=[1,0,0,0,1,0,0,0,1]){const t=function(e){return e[0]*+(e[4]*e[8]-e[7]*e[5])+e[3]*-(e[1]*e[8]-e[7]*e[2])+e[6]*+(e[1]*e[5]-e[4]*e[2])}(e);return t?(r[0]=+(e[4]*e[8]-e[7]*e[5]),r[1]=-(e[1]*e[8]-e[7]*e[2]),r[2]=+(e[1]*e[5]-e[4]*e[2]),r[3]=-(e[3]*e[8]-e[6]*e[5]),r[4]=+(e[0]*e[8]-e[6]*e[2]),r[5]=-(e[0]*e[5]-e[3]*e[2]),r[6]=+(e[3]*e[7]-e[6]*e[4]),r[7]=-(e[0]*e[7]-e[6]*e[1]),r[8]=+(e[0]*e[4]-e[3]*e[1]),function(e,n,t=[1,0,0,0,1,0,0,0,1]){return o(e,n,t)}(r,1/t,n)):null}(e,n)?function(e,n=[1,0,0,0,1,0,0,0,1]){return function(e,n,t){let o=0;for(let e=0;e<3;++e)for(let r=e;r<3;++r)o=n[3*r+e],t[3*r+e]=n[3*e+r],t[3*e+r]=o;return t}(0,e,n)}(n,n):null}(function(e,n=[1,0,0,0,1,0,0,0,1]){for(let t=0;t<3;++t)for(let o=0;o<3;++o)n[3*t+o]=e[4*t+o];return n}(e,n),n)}(f.model,f.normalMatrix=f.normalMatrix||[1,0,0,0,1,0,0,0,1])||function(e){for(let n=0;n<9;++n)e[n]=n%4?0:1}(f.normalMatrix);let m=!1,T=0,x=(null===(c=t.accessors)||void 0===c||null===(u=c[s.attributes.POSITION])||void 0===u?void 0:u.count)||0;if(!x)return;const y={...f,...j(e,t,s.material)};s.targets&&(y.targetWeights=b(i).weights||i.weights||a.weights||[0,0,0,0,0,0,0,0]);let _=0;const S=null===(v=t.skins)||void 0===v?void 0:v[i.skin];if(s.attributes.JOINTS_0&&s.attributes.WEIGHTS_0&&S){_=S.joints.length;const e=b(i).jointMatrix=b(i).jointMatrix||new Float32Array(16*_);y.jointMatrix=e}const w=[];for(const e in y)"number"==typeof y[e]?w.push({name:e,value:y[e]}):y[e].length?w.push({name:e,values:y[e]}):w.push({name:e,tex:y[e]});const E=function(e,n,t,o=0){var r,i,a;let l=b(t).pipeline;if(l)return l;const s=t.mode||4,f=null===(r=n.materials)||void 0===r?void 0:r[t.material];let c="OPAQUE",u=!1,v=!1;var d;f&&(u=f.doubleSided||!1,c=f.alphaMode||c,v=!(null===(d=f.extensions)||void 0===d||!d.KHR_materials_unlit));const m=function(e,n){const t={},o=[];let r=0;function i(n){var r,i;if(!n.sparse){const r=C(e,n).buffer,i=`${n.bufferView},${r.byteOffset},${r.byteLength}`;if(i in t)return o[t[i]];t[i]=o.length}const a={attrs:[],stride:null===(r=e.bufferViews)||void 0===r||null===(i=r[n.bufferView])||void 0===i?void 0:i.byteStride};return o.push(a),a}for(const t of["POSITION","NORMAL","TANGENT","TEXCOORD_0","TEXCOORD_1","COLOR_0","JOINTS_0","WEIGHTS_0"]){var a;const o=null===(a=e.accessors)||void 0===a?void 0:a[n.attributes[t]];if(o){const e=O(o);if(!e)continue;i(o).attrs.push({name:t,format:e,shaderLoc:r,offset:b(o).byteOffset||0}),r++}}if(n.targets){const t=new Array(3);for(let o=0;o<n.targets.length;++o){let a=0;for(let r=0;r<D.length;++r){var l;(t[r]=null===(l=e.accessors)||void 0===l?void 0:l[n.targets[o][D[r]]])&&++a}if(r+a>16)break;for(let e=0;e<D.length;++e){const n=t[e];n&&(i(n).attrs.push({name:`${D[e]}_${o}`,format:768,shaderLoc:r,offset:b(n).byteOffset||0}),r++)}}}return o}(n,t),T=5125===(null===(i=n.accessors)||void 0===i||null===(a=i[t.indices])||void 0===a?void 0:a.componentType)?5125:5123,x=t.attributes.JOINTS_0&&t.attributes.WEIGHTS_0?12*Math.ceil(o/12):0,y=JSON.stringify([m,u,c,x,T,s,v]),_=b(n).pipelines=b(n).pipelines||{};if(l=_[y],l)return l;const S=[`ALPHAMODE_${c}`];for(const e of m)for(const n of e.attrs)S.push(`USE_${n.name}`),"COLOR_0"===n.name&&3==(n.format>>8&255)&&S.push("COLOR_0_VEC3");x>0&&S.push(`NUM_JOINTS ${x}`),v&&S.push("MATERIAL_UNLIT");const w=S.map((e=>`#define ${e}`)).join("\n"),E=[];x>0&&E.push({name:"jointMatrix",type:1,valueFormat:h}),t.targets&&E.push({name:"targetWeights",type:1,valueFormat:p});const N=e.shader({type:35633,source:w+F}),L=e.shader({type:35632,source:w+"\n#ifdef GL_OES_standard_derivatives\n  #extension GL_OES_standard_derivatives : enable\n#endif\n\nprecision highp float;\n\nuniform float alphaCutoff;\nuniform vec3 cameraPosition;\n\nvarying vec3 vPosition;\n\n\nconst float GAMMA = 2.2;\n\nvec3 linearTosRGB(vec3 color) {\n  return pow(color, vec3(1./GAMMA));\n}\n\nvec3 sRGBToLinear(vec3 srgbIn) {\n  return vec3(pow(srgbIn.xyz, vec3(GAMMA)));\n}\n\nvec4 sRGBToLinear(vec4 srgbIn) {\n  return vec4(sRGBToLinear(srgbIn.xyz), srgbIn.w);\n}\n\n\nconst float PI = 3.141592653589793;\n\nvec3 specularF(vec3 r0, vec3 r90, float vDotH) {\n  return r0 + (r90 - r0) * pow(clamp(1. - vDotH, 0., 1.), 5.);\n}\n\nfloat specularD(float aSqr, float nDotH) {\n  float f = (nDotH * nDotH) * (aSqr - 1.) + 1.;\n  return aSqr / (PI * f * f);\n}\n\nfloat specularV(float aSqr, float nDotL, float nDotV) {\n  float gl = 1. / (nDotL + sqrt(aSqr + (1. - aSqr) * (nDotL * nDotL)));\n  float gv = 1. / (nDotV + sqrt(aSqr + (1. - aSqr) * (nDotV * nDotV)));\n  return gl * gv;\n}\n\nfloat specularBRDF(float aSqr, float nDotL, float nDotV, float nDotH) {\n  return specularV(aSqr, nDotL, nDotV) * specularD(aSqr, nDotH);\n}\n\nvec3 diffuseBRDF(vec3 color) {\n  return color / PI;\n}\n\n\nvarying vec2 vTexCoord0;\nvarying vec2 vTexCoord1;\n\nstruct TextureInfo {\n  sampler2D tex;\n  float texCoord;\n  float scale;\n};\n\nvec2 getTexCoord(TextureInfo tex) {\n  return mix(vTexCoord0, vTexCoord1, step(1., tex.texCoord));\n}\n\nvec4 texture(TextureInfo tex) {\n  return texture2D(tex.tex, getTexCoord(tex));\n}\n\nvec4 texture(TextureInfo tex, vec4 defaultValue) {\n  return mix(defaultValue, texture2D(tex.tex, getTexCoord(tex)), step(0., tex.texCoord));\n}\n\n\nuniform TextureInfo normalTexture;\n\n#ifdef USE_NORMAL\n#ifdef USE_TANGENT\nvarying mat3 vTBN;\n#else\nvarying vec3 vNormal;\n#endif\n#endif\n\nstruct NormalInfo {\n  vec3 ng;\n  vec3 n;\n  vec3 t;\n  vec3 b;\n};\n\nNormalInfo getNormalInfo(vec3 v) {\n  vec3 n, t, b, ng;\n\n#ifdef USE_TANGENT\n  t = normalize(vTBN[0]);\n  b = normalize(vTBN[1]);\n  ng = normalize(vTBN[2]);\n#else\n#ifdef USE_NORMAL\n  ng = normalize(vNormal);\n#else\n  ng = normalize(cross(dFdx(v), dFdy(v)));\n#endif\n  vec2 UV = getTexCoord(normalTexture);\n  vec3 uvDx = dFdx(vec3(UV, 0.));\n  vec3 uvDy = dFdy(vec3(UV, 0.));\n  vec3 t_ = (uvDy.t * dFdx(v) - uvDx.t * dFdy(v)) / (uvDx.s * uvDy.t - uvDy.s * uvDx.t);\n\n  t = normalize(t_ - ng * dot(ng, t_));\n  b = cross(ng, t);\n#endif\n\n  if (gl_FrontFacing == false) {\n    t *= -1.;\n    b *= -1.;\n    ng *= -1.;\n  }\n\n  n = ng;\n  if (normalTexture.texCoord >= 0.) {\n    n = texture(normalTexture).rgb * 2. - vec3(1.);\n    n *= vec3(normalTexture.scale, normalTexture.scale, 1.);\n    n = mat3(t, b, ng) * normalize(n);\n  }\n\n  NormalInfo ni;\n  ni.ng = ng;\n  ni.t = t;\n  ni.b = b;\n  ni.n = n;\n  return ni;\n}\n\n\nconst float MIN_ROUGHNESS = .04;\n\n#ifdef USE_COLOR_0\nvarying vec4 vColor0;\n#endif\n\nuniform vec4 baseColorFactor;\nuniform TextureInfo baseColorTexture;\n\nuniform float metallicFactor;\nuniform float roughnessFactor;\nuniform TextureInfo metallicRoughnessTexture;\n\nuniform TextureInfo occlusionTexture;\n\nuniform vec3 emissiveFactor;\nuniform TextureInfo emissiveTexture;\n\nvec4 getVertexColor() {\n  vec4 color = vec4(1.);\n#ifdef USE_COLOR_0\n  color = vColor0;\n#endif\n  return color;\n}\n\nvec4 getBaseColor() {\n  vec4 baseColor = vec4(1.);\n\n  baseColor *= baseColorFactor;\n  baseColor *= sRGBToLinear(texture(baseColorTexture, vec4(1.)));\n\n  return baseColor * getVertexColor();\n}\n\nvec2 getMetallicRoughness() {\n  vec4 mrTex = texture(metallicRoughnessTexture, vec4(1.));\n  return vec2(\n    clamp(metallicFactor * mrTex.b, 0., 1.),\n    clamp(roughnessFactor * mrTex.g, MIN_ROUGHNESS, 1.)\n  );\n}\n\nfloat getOcculsion() {\n  return texture(occlusionTexture, vec4(1.)).r;\n}\n\nvec3 getEmissiveFactor() {\n  return emissiveFactor * sRGBToLinear(texture(emissiveTexture, vec4(0)).rgb);\n}\n\n\n\n#define LIGHT_DIRECTIONAL 0\n#define LIGHT_POINT 1\n#define LIGHT_SPOT 2\n\nint getLightType(mat4 light) {\n  return int(light[0].x);\n}\n\nvec2 getLightConeCos(mat4 light) {\n  return light[0].yz;\n}\n\nvec4 getLightColor(mat4 light) {\n  return light[1];\n}\n\nfloat getLightRange(mat4 light) {\n  return light[2].w;\n}\n\nvec3 getLightDirection(mat4 light) {\n  return light[2].xyz;\n}\n\nvec3 getLightPosition(mat4 light) {\n  return light[3].xyz;\n}\n\nfloat getRangeAttenuation(float range, float distance) {\n  if (range <= 0.) {\n    return 1. / pow(distance, 2.);\n  }\n  return max(min(1.0 - pow(distance / range, 4.), 1.), 0.) / pow(distance, 2.);\n}\n\nfloat getSpotAttenuation(vec3 pointToLight, vec3 direction, vec2 coneCos) {\n  float actualCos = dot(normalize(direction), normalize(-pointToLight));\n  float scale = 1. / max(.001, coneCos[0] - coneCos[1]);\n  float offset = -coneCos[1] * scale;\n  float att = clamp(actualCos * scale + offset, 0., 1.);\n  return att * att;\n}\n\nvec3 getPointToLight(mat4 light, vec3 position) {\n  return getLightType(light) != LIGHT_DIRECTIONAL ? getLightPosition(light) - position : -getLightDirection(light);\n}\n\nvec3 getLighIntensity(mat4 light, vec3 pointToLight) {\n  vec4 color = getLightColor(light);\n  vec3 intensity = color.rgb * color.a;\n\n  if (getLightType(light) != LIGHT_DIRECTIONAL) {\n    intensity *= getRangeAttenuation(getLightRange(light), length(pointToLight));\n  }\n  if (getLightType(light) == LIGHT_SPOT) {\n    intensity *= getSpotAttenuation(pointToLight, getLightDirection(light), getLightConeCos(light));\n  }\n\n  return intensity;\n}\n\n\nvoid main () {\n  vec4 baseColor = getBaseColor();\n#ifdef ALPHAMODE_OPAQUE\n  baseColor.a = 1.0;\n#endif\n\n#ifdef MATERIAL_UNLIT\n  gl_FragColor = (vec4(linearTosRGB(baseColor.rgb), baseColor.a));\n  return;\n#endif\n\n  vec3 v = normalize(cameraPosition - vPosition);\n  NormalInfo normalInfo = getNormalInfo(vPosition);\n  vec3 n = normalInfo.n;\n\n  vec3 reflection = -normalize(reflect(v, n));\n  float nDotV = clamp(abs(dot(n, v)), 0.001, 1.0);\n\n  vec2 metallicRoughness = getMetallicRoughness();\n  float metallic = metallicRoughness[0];\n  float roughness = metallicRoughness[1];\n  float alphaRoughness = roughness * roughness;\n  float aSqr = alphaRoughness * alphaRoughness;\n\n  vec3 f0 = vec3(0.04);\n  vec3 diffuseColor = baseColor.rgb * (vec3(1.0) - f0) * (1.0 - metallic);\n  vec3 specularColor = mix(f0, baseColor.rgb, metallic);\n\n  float r0 = max(max(specularColor.r, specularColor.g), specularColor.b);\n  float r90 = clamp(r0 * 25.0, 0.0, 1.0);\n  vec3 specularEnvR0 = specularColor.rgb;\n  vec3 specularEnvR90 = vec3(1.0, 1.0, 1.0) * r90;\n\n  vec3 diffuseFinal = vec3(0.0);\n  vec3 specularFinal = vec3(0.0);\n\n  #define NUM_LIGHTS 4\n\n  mat4 lights[4];\n  lights[0] = mat4(\n    0., 0., 0., 0.,\n    1., 1., 1., 1.,\n    .5, -.707, -.5, 0.,\n    0., 0., 0., 0.\n  );\n  lights[1] = mat4(\n    0., 0., 0., 0.,\n    1., 1., 1., .5,\n    -.5, .707, .5, 0.,\n    0., 0., 0., 0.\n  );\n  lights[2] = mat4(\n    0., 0., 0., 0.,\n    1., 1., 1., .25,\n    .5, .707, -.5, 0.,\n    0., 0., 0., 0.\n  );\n  lights[3] = mat4(\n    0., 0., 0., 0.,\n    1., 1., 1., .25,\n    -.5, -.707, .5, 0.,\n    0., 0., 0., 0.\n  );\n\n#ifdef NUM_LIGHTS\n  for (int i = 0; i < NUM_LIGHTS; ++i) {\n    vec3 pointToLight = getPointToLight(lights[i], vPosition);\n    vec3 intensity = getLighIntensity(lights[i], pointToLight);\n    vec3 l = normalize(pointToLight);\n    vec3 h = normalize(l + v);\n    float nDotL = clamp(dot(n, l), 0.001, 1.0);\n    float nDotH = clamp(dot(n, h), 0.0, 1.0);\n    float vDotH = clamp(dot(v, h), 0.0, 1.0);\n  \n    vec3 F = specularF(specularEnvR0, specularEnvR90, vDotH);\n    vec3 diffuse = (1.0 - F) * diffuseBRDF(diffuseColor);\n    vec3 specular = max(vec3(0.0), F * specularBRDF(aSqr, nDotL, nDotV, nDotH));\n\n    diffuseFinal += intensity * nDotL * diffuse;\n    specularFinal += intensity * nDotL * specular;\n  }\n#endif\n\n  vec4 ambient = vec4(0.1);\n\n  vec3 ambientDiffuse = ambient.rgb * diffuseBRDF(diffuseColor);\n  diffuseFinal += ambientDiffuse;\n\n  vec3 colorFinal = diffuseFinal + specularFinal;\n\n  float ao = getOcculsion();\n  colorFinal = mix(colorFinal, colorFinal * ao, occlusionTexture.scale);\n\n  vec3 emissive = getEmissiveFactor();\n  colorFinal += emissive;\n\n#ifdef ALPHAMODE_MASK\n  if (baseColor.a < alphaCutoff) {\n    discard;\n  }\n  baseColor.a = 1.0;\n#else\n  alphaCutoff;\n#endif\n\n  gl_FragColor = vec4(linearTosRGB(colorFinal), baseColor.a);\n}\n"});return l=b(t).pipeline=_[y]=e.pipeline({vert:N,frag:L,buffers:m,indexFormat:T,mode:s,depth:{compare:515,write:!("BLEND"===c)},blend:"BLEND"===c?{srcFactorRGB:770,dstFactorRGB:771,srcFactorAlpha:1,dstFactorAlpha:771}:void 0,raster:{cullMode:u?0:1029},uniforms:[{name:"model",type:1,valueFormat:h},{name:"viewProj",type:1,valueFormat:h},{name:"normalMatrix",type:1,valueFormat:35675},{name:"cameraPosition",type:1,valueFormat:35665},{name:"alphaCutoff",type:1,valueFormat:p},{name:"baseColorFactor",type:1,valueFormat:35666},{name:"baseColorTexture.tex",type:2,texType:g},{name:"baseColorTexture.texCoord",type:1,valueFormat:p},{name:"metallicFactor",type:1,valueFormat:p},{name:"roughnessFactor",type:1,valueFormat:p},{name:"metallicRoughnessTexture.tex",type:2,texType:g},{name:"metallicRoughnessTexture.texCoord",type:1,valueFormat:p},{name:"normalTexture.tex",type:2,texType:g},{name:"normalTexture.texCoord",type:1,valueFormat:p},{name:"normalTexture.scale",type:1,valueFormat:p},{name:"emissiveFactor",type:1,valueFormat:35665},{name:"emissiveTexture.tex",type:2,texType:g},{name:"emissiveTexture.texCoord",type:1,valueFormat:p},{name:"occlusionTexture.tex",type:2,texType:g},{name:"occlusionTexture.texCoord",type:1,valueFormat:p},{name:"occlusionTexture.scale",type:1,valueFormat:p},...E]}),N.destroy(),L.destroy(),l}(e,t,s,_);n.pipeline(E).uniforms(w);for(let o=0;o<E.props.buffers.length;++o){const r=E.props.buffers[o].attrs[0].name,i=P.exec(r),a=k(e,t,i?s.targets[i[2]][i[1]]:s.attributes[r],34962);a&&n.vertex(o,a)}const N=null===(d=t.accessors)||void 0===d?void 0:d[s.indices];if(N){const o=k(e,t,s.indices,34963);o&&(n.index(o),x=N.count,T=b(N).byteOffset||0,m=!0)}m?n.drawIndexed(x,1,T):n.draw(x)}function j(e,n,t){var o;const r={alphaCutoff:.5,baseColorFactor:[1,1,1,1],"baseColorTexture.tex":$(e,n),"baseColorTexture.texCoord":-1,metallicFactor:1,roughnessFactor:1,"metallicRoughnessTexture.tex":$(e,n),"metallicRoughnessTexture.texCoord":-1,"normalTexture.tex":$(e,n),"normalTexture.texCoord":-1,"normalTexture.scale":1,emissiveFactor:[0,0,0],"emissiveTexture.tex":$(e,n),"emissiveTexture.texCoord":-1,"occlusionTexture.tex":$(e,n),"occlusionTexture.texCoord":-1,"occlusionTexture.scale":0};function i(t,o,i=null){var a;t[o]&&(r[`${o}.tex`]=function(e,n,t){var o,r,i,a,l;const s=null===(o=n.textures)||void 0===o?void 0:o[t];if(!s)return $(e,n);let f=b(s).texture;if(f)return f;let c=null;const u={wrapU:10497,wrapV:10497,magFilter:9729,minFilter:9729},v=null===(r=n.images)||void 0===r?void 0:r[s.source];v&&(c=v.extras.image);const d=null===(i=n.samplers)||void 0===i?void 0:i[s.sampler];if(d)switch(u.wrapU=d.wrapS||u.wrapU,u.wrapV=d.wrapT||u.wrapV,u.magFilter=d.magFilter||u.magFilter,d.minFilter){case 9728:case 9984:case 9986:u.minFilter=9728}return f=b(s).texture=e.texture({width:(null===(a=c)||void 0===a?void 0:a.naturalWidth)||1,height:(null===(l=c)||void 0===l?void 0:l.naturalHeight)||1},u),f.data(c?{image:c}:{buffer:new Uint8Array([255,255,255,255])}),f}(e,n,t[o].index),r[`${o}.texCoord`]=t[o].texCoord||0,i&&(r[`${o}.scale`]=null!==(a=t[o][i])&&void 0!==a?a:r[`${o}.scale`]))}const a=null===(o=n.materials)||void 0===o?void 0:o[t];if(a){var l;if(a.pbrMetallicRoughness){const e=a.pbrMetallicRoughness;r.baseColorFactor=e.baseColorFactor||r.baseColorFactor,(e.metallicFactor||0===e.metallicFactor)&&(r.metallicFactor=e.metallicFactor),(e.roughnessFactor||0===e.roughnessFactor)&&(r.roughnessFactor=e.roughnessFactor),i(e,"baseColorTexture"),i(e,"metallicRoughnessTexture")}r.alphaCutoff=null!==(l=a.alphaCutoff)&&void 0!==l?l:r.alphaCutoff,r.emissiveFactor=a.emissiveFactor||r.emissiveFactor,i(a,"emissiveTexture"),i(a,"occlusionTexture","strength"),i(a,"normalTexture","scale")}return r}function k(e,n,t,o){var r,i;const a=null===(r=n.accessors)||void 0===r?void 0:r[t];if(!a)return null;const l=34963===o&&a.componentType===v;if(a.sparse||l){let t=b(a).gpuBuffer;if(!t){const r=C(n,a);let i=r.buffer;if(l){const e=new Uint16Array(i.byteLength);for(let n=0;n<i.byteLength;++n)e[n]=i[r.byteOffset+n];i=b(a).buffer=new Uint8Array(e.buffer,0,e.byteLength),b(a).byteOffset=0}t=b(a).gpuBuffer=e.buffer({type:o,size:i.byteLength}).data(i)}return t}const s=null===(i=n.bufferViews)||void 0===i?void 0:i[a.bufferView];if(!s)return null;const f=b(s).gpuBuffers=b(s).gpuBuffers||{},c=C(n,a).buffer,u=`${c.byteOffset},${c.byteLength}`;return f[u]?f[u]:f[u]=e.buffer({type:s.target||o,size:c.byteLength}).data(c)}function $(e,n){let t=b(n).blankTexture;return t||(t=b(n).blankTexture=e.texture({}).data({buffer:new Uint8Array([255,255,255,255])}),t)}function W(e){return(new TextDecoder).decode(e)}function J(e){return/^data:.*,.*$/i.test(e)||/^blob:.*$/i.test(e)}function q(e,n){return""===e?"":/^(https?:)?\/\//i.test(e)||J(e)?e:n+e}const X=1179937895;async function K(e,n=Q){const t=e.uri?function(e){if(J(e))return"";const n=e.split(/[?#]/)[0].split("/");return n.pop(),n.length?n.join("/")+"/":""}(e.uri):"";let o=e.glTF,r=e.binaryChunk;if(!o&&e.uri){const t=await n(e.uri,"bin");if(i=t,new DataView(i.buffer||i,i.byteOffset||0,4).getUint32(0,!0)===X){const e=function(e){let n,t;const o=e.buffer||e,r=e.byteOffset||0,i=new DataView(o,r,12);if(i.getUint32(0,!0)!==X)throw new Error("Invalid GLB format");const a=i.getUint32(4,!0);if(2!==a)throw new Error("Unsupported GLB version: "+a);const l=new DataView(o,r+12);let s=0;for(;s<l.byteLength;){const e=l.getUint32(s,!0),i=l.getUint32(s+4,!0);if(s+=8,1313821514===i){const t=new Uint8Array(o,r+12+s,e);n=JSON.parse(W(t))}else 5130562===i&&(t=new Uint8Array(o,r+12+s,e));s+=e}if(!n)throw new Error("Invalid GLB format: missing JSON content");if(!n.asset||"2.0"!==n.asset.minVersion&&"2.0"!==n.asset.version)throw new Error("Unsupported glTF version: 2.0 required");return{glTF:n,binaryChunk:t}}(t);o=e.glTF,r=e.binaryChunk}else o=JSON.parse(W(t))}var i;if(!o)throw new Error("Failed to load glTF JSON");const a=await async function(e,n,t,o){if(e.buffers)for(let r=0;r<e.buffers.length;++r){const i=e.buffers[r];if(b(i).buffer)continue;let a;const l=i.uri;if(l)a=await t(q(l,o),"bin");else{if(0!==r||!n)throw new Error("Invalid glTF: missing uri for buffer "+r);a=n}b(i).buffer=a}return e}(o,r,n,t);return await async function(e,n,t){if(e.images)for(let r=0;r<e.images.length;++r){const i=e.images[r];if(b(i).image)continue;const a=i.bufferView;let l,s=!1,f=i.uri;if(a){var o;const n=null===(o=e.bufferViews)||void 0===o?void 0:o[a];if(!n)throw new Error("Invalid glTF: invalid bufferView for image "+r);const t=new Blob([_(e,n)],{type:i.mimeType});f=URL.createObjectURL(t),s=!0}if(!f)throw new Error("Invalid glTF: missing uri or bufferView for image "+r);try{l=await n(q(f,t),"img")}finally{s&&URL.revokeObjectURL(f)}b(i).image=l}return e}(a,n,t)}function Q(e,n){return"img"===n?new Promise(((n,t)=>{const o=new Image;o.crossOrigin="anonymous",o.onerror=()=>t(new Error("Failed to load: "+e)),o.onload=()=>n(o),o.src=e})):fetch(e).then((e=>e.arrayBuffer())).then((e=>new Uint8Array(e)))}return n})()},"object"==typeof exports&&"object"==typeof module?module.exports=n():"function"==typeof define&&define.amd?define("mugltf",[],n):"object"==typeof exports?exports.mugltf=n():e.mugltf=n();