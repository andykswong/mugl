import{MUGL_DEBUG}from"../config.js";import*as GLenum from"./gl-const.js";import{BindingType,BufferUsage,ColorWrite,ShaderStage,TextureUsage}from"./type.js";import{WebGL2FeatureNames}from"./gl2-type.js";import{glClearType,glTexelFormat,glTexelSize,glTexelType,hasStencil,indexByteSize,is3DTexture,isDepthStencil,vertexSize,vertexType,vertexNormalized}from"./gl-util.js";const BYTE_MASK=255;const STENCIL_MASK=4294967295;const MAX_VERTEX_ATTRIBS=16;export function requestWebGL2Device(canvas,options={},features=0){const gl=canvas.getContext("webgl2",options);if(gl){let enabledFeatures=0;for(const feature in WebGL2FeatureNames){if(features&+feature&&gl.getExtension(WebGL2FeatureNames[+feature])){enabledFeatures=enabledFeatures|+feature}}return{canvas,gl,features:enabledFeatures,pass:null,state:initWebGL2State(gl),destroy(){this.gl.deleteFramebuffer(this.state.copyFrameBuffer)}}}return null}export function resetDevice(device){device.destroy();device.state=initWebGL2State(device.gl)}export function isDeviceLost(device){return device.gl.isContextLost()}export function getDeviceFeatures(device){return device.features}export function createBuffer(device,desc){const type=desc.usage&BufferUsage.Uniform?GLenum.UNIFORM_BUFFER:desc.usage&BufferUsage.Index?GLenum.ELEMENT_ARRAY_BUFFER:GLenum.ARRAY_BUFFER;const usage=desc.usage&BufferUsage.Stream?GLenum.STREAM_DRAW:desc.usage&BufferUsage.Dynamic?GLenum.DYNAMIC_DRAW:GLenum.STATIC_DRAW;const glb=device.gl.createBuffer();device.gl.bindBuffer(type,glb);device.gl.bufferData(type,desc.size,usage);return{gl:device.gl,glb,type,size:desc.size,destroy(){this.gl.deleteBuffer(this.glb)}}}export function createTexture(device,desc){const samples=desc.sampleCount||1;const type=desc.dimension||GLenum.TEXTURE_2D;const format=desc.format||GLenum.RGBA8;const needTexture=!isDepthStencil(format)||(desc.usage||0)&TextureUsage.TextureBinding;const[width,height,_depth]=desc.size||[1,1,1];const depth=type===GLenum.TEXTURE_CUBE_MAP?6:type===GLenum.TEXTURE_2D?1:_depth;let glt=null;let glrb=null;if(samples>1||!needTexture){glrb=device.gl.createRenderbuffer();device.gl.bindRenderbuffer(GLenum.RENDERBUFFER,glrb);if(samples>1){device.gl.renderbufferStorageMultisample(GLenum.RENDERBUFFER,samples,format,width,height)}else{device.gl.renderbufferStorage(GLenum.RENDERBUFFER,format,width,height)}}if(needTexture){glt=device.gl.createTexture();device.gl.activeTexture(GLenum.TEXTURE0);device.gl.bindTexture(type,glt);if(is3DTexture(type)){device.gl.texStorage3D(type,desc.mipLevelCount||1,format,width,height,depth)}else{device.gl.texStorage2D(type,desc.mipLevelCount||1,format,width,height)}}return{gl:device.gl,glt,glrb,type,format,width,height,depth,samples,destroy(){this.gl.deleteTexture(this.glt);this.gl.deleteRenderbuffer(this.glrb)}}}export function createSampler(device,desc={}){const gls=device.gl.createSampler();let minFilter=desc.minFilter||GLenum.NEAREST;if(desc.mipmapFilter){if(desc.mipmapFilter===GLenum.NEAREST){minFilter=minFilter===GLenum.NEAREST?GLenum.NEAREST_MIPMAP_NEAREST:GLenum.LINEAR_MIPMAP_NEAREST}else{minFilter=minFilter===GLenum.NEAREST?GLenum.NEAREST_MIPMAP_LINEAR:GLenum.LINEAR_MIPMAP_LINEAR}}device.gl.samplerParameteri(gls,GLenum.TEXTURE_MIN_FILTER,minFilter);device.gl.samplerParameteri(gls,GLenum.TEXTURE_MAG_FILTER,desc.magFilter||GLenum.NEAREST);device.gl.samplerParameteri(gls,GLenum.TEXTURE_WRAP_S,desc.addressModeU||GLenum.CLAMP_TO_EDGE);device.gl.samplerParameteri(gls,GLenum.TEXTURE_WRAP_T,desc.addressModeV||GLenum.CLAMP_TO_EDGE);device.gl.samplerParameteri(gls,GLenum.TEXTURE_WRAP_R,desc.addressModeW||GLenum.CLAMP_TO_EDGE);device.gl.samplerParameterf(gls,GLenum.TEXTURE_MAX_LOD,desc.lodMaxClamp||32);device.gl.samplerParameterf(gls,GLenum.TEXTURE_MIN_LOD,desc.lodMinClamp||0);if(desc.compare){device.gl.samplerParameterf(gls,GLenum.TEXTURE_COMPARE_MODE,GLenum.COMPARE_REF_TO_TEXTURE);device.gl.samplerParameterf(gls,GLenum.TEXTURE_COMPARE_FUNC,desc.compare)}if((desc.maxAnisotropy||1)>1){device.gl.samplerParameterf(gls,GLenum.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(desc.maxAnisotropy||1,device.gl.getParameter(GLenum.MAX_TEXTURE_MAX_ANISOTROPY_EXT)))}return{gls,gl:device.gl,destroy(){this.gl.deleteSampler(this.gls)}}}export function createShader(device,desc){const type=desc.usage===ShaderStage.Vertex?GLenum.VERTEX_SHADER:GLenum.FRAGMENT_SHADER;const gls=device.gl.createShader(type);device.gl.shaderSource(gls,desc.code);device.gl.compileShader(gls);if(MUGL_DEBUG){console.assert(device.gl.getShaderParameter(gls,GLenum.COMPILE_STATUS)||isDeviceLost(device),`Failed to compile shader: ${device.gl.getShaderInfoLog(gls)}`)}return{gl:device.gl,gls,destroy(){this.gl.deleteShader(this.gls)}}}export function createRenderPass(device,desc={}){let glfb=null;const glrfb=[];const depth=desc.depthStencil?desc.depthStencil.texture:null;const withStencil=depth&&hasStencil(depth.format)||false;if(desc.colors&&desc.colors.length){glfb=device.gl.createFramebuffer();device.gl.bindFramebuffer(GLenum.FRAMEBUFFER,glfb);for(let i=0;i<desc.colors.length;++i){if(desc.colors[i].view.texture.samples>1){device.gl.framebufferRenderbuffer(GLenum.FRAMEBUFFER,GLenum.COLOR_ATTACHMENT0+i,GLenum.RENDERBUFFER,desc.colors[i].view.texture.glrb)}else{framebufferTexture(device.gl,GLenum.COLOR_ATTACHMENT0+i,desc.colors[i].view)}}if(desc.colors.length>1){device.gl.drawBuffers(desc.colors.map((_,i)=>GLenum.COLOR_ATTACHMENT0+i))}if(depth){if(depth.glrb){device.gl.framebufferRenderbuffer(GLenum.FRAMEBUFFER,withStencil?GLenum.DEPTH_STENCIL_ATTACHMENT:GLenum.DEPTH_ATTACHMENT,GLenum.RENDERBUFFER,depth.glrb)}else{if(MUGL_DEBUG&&!isDepthStencil(depth.format)){console.error("Invalid depth texture format",depth)}framebufferTexture(device.gl,withStencil?GLenum.DEPTH_STENCIL_ATTACHMENT:GLenum.DEPTH_ATTACHMENT,desc.depthStencil)}}if(MUGL_DEBUG){console.assert(device.gl.checkFramebufferStatus(GLenum.FRAMEBUFFER)===GLenum.FRAMEBUFFER_COMPLETE||isDeviceLost(device),"Framebuffer completeness check failed")}for(let i=0;i<desc.colors.length;++i){glrfb.push(desc.colors[i].view.texture.samples>1?createResolveFrameBuffer(device.gl,GLenum.COLOR_ATTACHMENT0,desc.colors[i].view):null)}glrfb.push(depth&&depth.samples>1&&depth.glt?createResolveFrameBuffer(device.gl,withStencil?GLenum.DEPTH_STENCIL_ATTACHMENT:GLenum.DEPTH_ATTACHMENT,desc.depthStencil):null)}return{gl:device.gl,glfb,glrfb,depth,color:desc.colors?desc.colors.map(c=>c.view.texture):[],clearColors:desc.colors?desc.colors.map(c=>c.clear):[],clearColor:desc.clearColor,clearDepth:desc.clearDepth,clearStencil:desc.clearStencil,destroy(){this.gl.deleteFramebuffer(this.glfb);for(const glrfb of this.glrfb){this.gl.deleteFramebuffer(glrfb)}}}}export function createBindGroupLayout(device,desc){return{entries:desc.entries.map((entry,binding)=>({binding,...entry})),destroy(){}}}export function createBindGroup(device,desc){return{entries:desc.entries.map((entry,binding)=>({binding,...entry})),destroy(){}}}export function createRenderPipeline(device,desc){const glp=compileShaderProgram(device,desc.vertex.gls,desc.fragment.gls);const cache=[];const textureSlots={};let bufCount=0;let texCount=0;if(desc.bindGroups){for(let i=0;i<desc.bindGroups.length;++i){const entries=desc.bindGroups[i].entries;cache.push([]);for(let j=0;j<entries.length;++j){const entry=entries[j];let loc=null;let index=GLenum.INVALID_INDEX;if(entry.type===BindingType.Buffer){index=device.gl.getUniformBlockIndex(glp,entry.label);device.gl.uniformBlockBinding(glp,index,bufCount++)}else if(entry.type===BindingType.Texture){loc=device.gl.getUniformLocation(glp,entry.label);textureSlots[entry.label]=texCount++}cache[i][entry.binding]={...entry,loc,index,slot:entry.type===BindingType.Buffer?bufCount-1:entry.type===BindingType.Texture?texCount-1:0}}}for(let i=0;i<desc.bindGroups.length;++i){const entries=desc.bindGroups[i].entries;for(let j=0;j<entries.length;++j){if(entries[j].type===BindingType.Sampler){if(textureSlots[entries[j].label]){cache[i][entries[j].binding].slot=textureSlots[entries[j].label]}}}}}return{gl:device.gl,glp,buffers:desc.buffers,cache,state:createPipelineState(desc),destroy(){this.gl.deleteProgram(this.glp)}}}export function readBuffer(device,buffer,out,offset=0){const future={done:false};getBufferSubData(device.gl,buffer.type,buffer.glb,offset,out.byteLength).then(data=>out.set(data)).finally(()=>future.done=true);return future}export function writeBuffer(device,buffer,data,offset=0){device.gl.bindBuffer(buffer.type,buffer.glb);device.gl.bufferSubData(buffer.type,offset,data)}export function copyBuffer(device,src,dst,size=src.size,srcOffset=0,dstOffset=0){device.gl.bindBuffer(GLenum.COPY_READ_BUFFER,src.glb);device.gl.bindBuffer(GLenum.COPY_WRITE_BUFFER,dst.glb);device.gl.copyBufferSubData(GLenum.COPY_READ_BUFFER,GLenum.COPY_WRITE_BUFFER,srcOffset,dstOffset,size)}export function generateMipmap(device,texture,hint=GLenum.DONT_CARE){device.gl.activeTexture(GLenum.TEXTURE0);device.gl.bindTexture(texture.type,texture.glt);device.gl.hint(GLenum.GENERATE_MIPMAP_HINT,hint);device.gl.generateMipmap(texture.type)}export function writeTexture(device,{texture,mipLevel=0,origin:[x,y,z]=[0,0,0]},data,{offset=0,bytesPerRow,rowsPerImage=0},[width,height,depth]=[texture.width-x,texture.height-y,texture.depth-z]){const glFormat=glTexelFormat(texture.format);const glType=glTexelType(texture.format);const isCube=texture.type===GLenum.TEXTURE_CUBE_MAP;const target=isCube?GLenum.TEXTURE_CUBE_MAP_POSITIVE_X+z:texture.type;device.gl.activeTexture(GLenum.TEXTURE0);device.gl.bindTexture(texture.type,texture.glt);const pixelSize=glTexelSize(texture.format);const imageHeight=rowsPerImage||height;const pixelsPerRow=Math.floor(bytesPerRow/pixelSize);const offsetAligned=offset-offset%bytesPerRow;device.gl.pixelStorei(GLenum.UNPACK_IMAGE_HEIGHT,imageHeight);device.gl.pixelStorei(GLenum.UNPACK_ROW_LENGTH,pixelsPerRow);device.gl.pixelStorei(GLenum.UNPACK_SKIP_PIXELS,Math.floor(offset%bytesPerRow/pixelSize));device.gl.pixelStorei(GLenum.UNPACK_SKIP_ROWS,0);device.gl.pixelStorei(GLenum.UNPACK_SKIP_IMAGES,0);if(is3DTexture(texture.type)){device.gl.texSubImage3D(target,mipLevel,x,y,z,width,height,depth,texture.format,glType,data,offsetAligned)}else if(isCube){for(let slice=z;slice<z+depth;++slice){device.gl.pixelStorei(GLenum.UNPACK_SKIP_ROWS,slice*pixelsPerRow*imageHeight);device.gl.texSubImage2D(target+slice,mipLevel,x,y,width,height,glFormat,glType,data,offsetAligned)}}else{device.gl.texSubImage2D(target,mipLevel,x,y,width,height,glFormat,glType,data,offsetAligned)}}export function copyExternalImageToTexture(device,{src,origin:[srcX,srcY]=[0,0]},{texture,mipLevel=0,origin:[x,y,z]=[0,0,0]},[width,height]=[src.width-srcX,src.height-srcY]){const glType=glTexelType(texture.format);const isCube=texture.type===GLenum.TEXTURE_CUBE_MAP;const target=isCube?GLenum.TEXTURE_CUBE_MAP_POSITIVE_X+z:texture.type;device.gl.activeTexture(GLenum.TEXTURE0);device.gl.bindTexture(texture.type,texture.glt);device.gl.pixelStorei(GLenum.UNPACK_SKIP_PIXELS,srcX);device.gl.pixelStorei(GLenum.UNPACK_SKIP_ROWS,srcY);device.gl.pixelStorei(GLenum.UNPACK_SKIP_IMAGES,0);device.gl.pixelStorei(GLenum.UNPACK_IMAGE_HEIGHT,0);if(is3DTexture(texture.type)){device.gl.texSubImage3D(target,mipLevel,x,y,z,width,height,1,texture.format,glType,src)}else{device.gl.texSubImage2D(target,mipLevel,x,y,width,height,glTexelFormat(texture.format),glType,src)}}export function copyTexture(device,{texture,mipLevel=0,origin:[x,y,z]=[0,0,0]},{texture:dstTexture,mipLevel:dstMipLevel=0,origin:[dstX,dstY,dstZ]=[0,0,0]},[width,height,depth]=[texture.width-x,texture.height-y,texture.depth-z]){const isCube=dstTexture.type===GLenum.TEXTURE_CUBE_MAP;const target=isCube?GLenum.TEXTURE_CUBE_MAP_POSITIVE_X+dstZ:dstTexture.type;device.gl.activeTexture(GLenum.TEXTURE0);device.gl.bindTexture(dstTexture.type,dstTexture.glt);device.gl.readBuffer(GLenum.COLOR_ATTACHMENT0);device.gl.bindFramebuffer(GLenum.FRAMEBUFFER,device.state.copyFrameBuffer);if(is3DTexture(texture.type)||texture.type===GLenum.TEXTURE_CUBE_MAP){for(let slice=z;slice<z+depth;++slice){framebufferTexture(device.gl,GLenum.COLOR_ATTACHMENT0,{texture,mipLevel,slice});if(MUGL_DEBUG){console.assert(device.gl.checkFramebufferStatus(GLenum.FRAMEBUFFER)===GLenum.FRAMEBUFFER_COMPLETE||device.gl.isContextLost(),"Framebuffer completeness check failed for copyTexture")}if(is3DTexture(dstTexture.type)){device.gl.copyTexSubImage3D(target+(isCube?slice:0),dstMipLevel,dstX,dstY,dstZ,x,y,width,height)}else{device.gl.copyTexSubImage2D(target+(isCube?slice:0),dstMipLevel,dstX,dstY,x,y,width,height)}}}else{const slice=0;framebufferTexture(device.gl,GLenum.COLOR_ATTACHMENT0,{texture,mipLevel,slice});if(MUGL_DEBUG){console.assert(device.gl.checkFramebufferStatus(GLenum.FRAMEBUFFER)===GLenum.FRAMEBUFFER_COMPLETE||device.gl.isContextLost(),"Framebuffer completeness check failed for copyTexture")}if(is3DTexture(dstTexture.type)){device.gl.copyTexSubImage3D(target+(isCube?slice:0),dstMipLevel,dstX,dstY,dstZ,x,y,width,height)}else{device.gl.copyTexSubImage2D(target+(isCube?slice:0),dstMipLevel,dstX,dstY,x,y,width,height)}}device.gl.bindFramebuffer(GLenum.FRAMEBUFFER,device.pass?device.pass.glfb:null)}export function copyTextureToBuffer(device,{texture,mipLevel=0,origin:[x,y,z]=[0,0,0]},dst,{offset=0,bytesPerRow,rowsPerImage=0},[width,height,depth]=[texture.width-x,texture.height-y,texture.depth-z]){device.gl.bindBuffer(GLenum.PIXEL_PACK_BUFFER,dst);device.gl.readBuffer(GLenum.COLOR_ATTACHMENT0);device.gl.bindFramebuffer(GLenum.FRAMEBUFFER,device.state.copyFrameBuffer);const type=glTexelType(texture.format);const format=glTexelFormat(texture.format);const pixelSize=glTexelSize(texture.format);const imageHeight=rowsPerImage||height;const pixelsPerRow=Math.floor(bytesPerRow/pixelSize);const offsetAligned=offset-offset%bytesPerRow;device.gl.pixelStorei(GLenum.PACK_ROW_LENGTH,pixelsPerRow);device.gl.pixelStorei(GLenum.PACK_SKIP_PIXELS,Math.floor(offset%bytesPerRow/pixelSize));device.gl.pixelStorei(GLenum.PACK_SKIP_ROWS,0);if(is3DTexture(texture.type)||texture.type===GLenum.TEXTURE_CUBE_MAP){for(let slice=z;slice<z+depth;++slice){framebufferTexture(device.gl,GLenum.COLOR_ATTACHMENT0,{texture,mipLevel,slice});if(MUGL_DEBUG){console.assert(device.gl.checkFramebufferStatus(GLenum.FRAMEBUFFER)===GLenum.FRAMEBUFFER_COMPLETE||device.gl.isContextLost(),"Framebuffer completeness check failed for copyTexture")}device.gl.readPixels(x,y,width,height,format,type,offsetAligned+(slice-z)*bytesPerRow*imageHeight)}}else{const slice=0;framebufferTexture(device.gl,GLenum.COLOR_ATTACHMENT0,{texture,mipLevel,slice});if(MUGL_DEBUG){console.assert(device.gl.checkFramebufferStatus(GLenum.FRAMEBUFFER)===GLenum.FRAMEBUFFER_COMPLETE||device.gl.isContextLost(),"Framebuffer completeness check failed for copyTexture")}device.gl.readPixels(x,y,width,height,format,type,offsetAligned)}device.gl.bindFramebuffer(GLenum.FRAMEBUFFER,device.pass?device.pass.glfb:null)}export function beginRenderPass(device,pass){let width=device.gl.drawingBufferWidth;let height=device.gl.drawingBufferHeight;if(pass.color.length){width=pass.color[0].width;height=pass.color[0].height}device.gl.bindFramebuffer(GLenum.FRAMEBUFFER,pass.glfb);device.gl.viewport(0,0,width,height);device.gl.depthRange(0,1);if(device.state.scissor){device.state.scissor=false;glToggle(device.gl,GLenum.SCISSOR_TEST,false)}let clearMask=0;if(!isNaN(pass.clearDepth)){clearMask|=GLenum.DEPTH_BUFFER_BIT;device.gl.clearDepth(pass.clearDepth);applyDepthMask(device.gl,device.state.state.depthWrite,true);device.state.state.depthWrite=true}if(!isNaN(pass.clearStencil)){clearMask|=GLenum.STENCIL_BUFFER_BIT;device.gl.clearStencil(pass.clearStencil);applyStencilMask(device.gl,device.state.state.stencilWriteMask,BYTE_MASK);device.state.state.stencilWriteMask=BYTE_MASK}applyColorMask(device.gl,device.state.state.blendWriteMask,ColorWrite.All);device.state.state.blendWriteMask=ColorWrite.All;if(pass.color.length){for(let i=0;i<pass.color.length;++i){if(pass.clearColors[i]){const type=glClearType(pass.color[i].format);if(type===GLenum.INT){device.gl.clearBufferiv(GLenum.COLOR,i,pass.clearColors[i])}else if(type===GLenum.UNSIGNED_INT){device.gl.clearBufferuiv(GLenum.COLOR,i,pass.clearColors[i])}else{device.gl.clearBufferfv(GLenum.COLOR,i,pass.clearColors[i])}}}}else if(pass.clearColor){clearMask|=GLenum.COLOR_BUFFER_BIT;device.gl.clearColor(...pass.clearColor)}if(clearMask){device.gl.clear(clearMask)}device.pass=pass}export function beginDefaultPass(device,desc={}){device.gl.bindFramebuffer(GLenum.FRAMEBUFFER,null);device.gl.viewport(0,0,device.gl.drawingBufferWidth,device.gl.drawingBufferHeight);device.gl.depthRange(0,1);if(device.state.scissor){device.state.scissor=false;glToggle(device.gl,GLenum.SCISSOR_TEST,false)}let clearMask=0;if(!isNaN(desc.clearDepth)){clearMask|=GLenum.DEPTH_BUFFER_BIT;device.gl.clearDepth(desc.clearDepth);applyDepthMask(device.gl,device.state.state.depthWrite,true);device.state.state.depthWrite=true}if(!isNaN(desc.clearStencil)){clearMask|=GLenum.STENCIL_BUFFER_BIT;device.gl.clearStencil(desc.clearStencil);applyStencilMask(device.gl,device.state.state.stencilWriteMask,BYTE_MASK);device.state.state.stencilWriteMask=BYTE_MASK}if(desc.clearColor){clearMask|=GLenum.COLOR_BUFFER_BIT;device.gl.clearColor(...desc.clearColor);applyColorMask(device.gl,device.state.state.blendWriteMask,ColorWrite.All);device.state.state.blendWriteMask=ColorWrite.All}if(clearMask){device.gl.clear(clearMask)}device.pass=null}export function submitRenderPass(device){if(device.pass){for(let i=0;i<device.pass.color.length;++i){if(device.pass.glrfb[i]){blitFramebuffer(device.gl,device.pass.glfb,device.pass.glrfb[i],device.pass.color[i],GLenum.COLOR_BUFFER_BIT,GLenum.COLOR_ATTACHMENT0+i)}}const depthFb=device.pass.glrfb[device.pass.glrfb.length-1];if(device.pass.depth&&depthFb){blitFramebuffer(device.gl,device.pass.glfb,depthFb,device.pass.depth,GLenum.DEPTH_BUFFER_BIT|GLenum.STENCIL_BUFFER_BIT)}}device.pass=null}export function setRenderPipeline(device,pipeline){if(device.state.pipeline===pipeline){return}if(!device.state.pipeline||device.state.pipeline.glp!==pipeline.glp){device.gl.useProgram(pipeline.glp)}applyPipelineState(device.gl,device.state.state,pipeline.state,device.state.stencilRef);Object.assign(device.state.state,pipeline.state);const attribEnabled=[];for(const{attributes}of device.state.buffers){for(const{ptr}of attributes){attribEnabled[ptr[0]]=1}}device.state.buffers=Array(pipeline.buffers.length);for(let slot=0;slot<pipeline.buffers.length;++slot){const{attributes,stride,stepMode=0}=pipeline.buffers[slot];const bufAttrs=[];device.state.buffers[slot]={glb:null,attributes:bufAttrs,stride,step:stepMode,offset:0,instanceOffset:0};for(const{format,offset,shaderLocation}of attributes){attribEnabled[shaderLocation]=(attribEnabled[shaderLocation]||0)+2;bufAttrs.push({buffer:slot,ptr:[shaderLocation,vertexSize(format),vertexType(format),vertexNormalized(format),stride,offset],step:stepMode})}}for(let i=0;i<attribEnabled.length;++i){if(attribEnabled[i]===2){device.gl.enableVertexAttribArray(i)}else if(attribEnabled[i]===1){device.gl.disableVertexAttribArray(i)}}device.state.pipeline=pipeline}export function setIndex(device,buffer){if(buffer.glb!==device.state.index){device.gl.bindBuffer(GLenum.ELEMENT_ARRAY_BUFFER,device.state.index=buffer.glb)}}export function setVertex(device,slot,buffer,offset=0){const buf=device.state.buffers[slot];if(buf&&(buf.glb!==buffer.glb||buf.offset!==offset)){buf.glb=buffer.glb;buf.offset=offset;buf.instanceOffset=0;vertexAttribs(device.gl,buf,offset)}}export function setBindGroup(device,slot,bindGroup,offsets=[]){if(!device.state.pipeline){return}for(let i=0,offsetIdx=0;i<bindGroup.entries.length;++i){const uniform=bindGroup.entries[i];const uniformInfo=device.state.pipeline.cache[slot]&&device.state.pipeline.cache[slot][uniform.binding];if(!uniformInfo){if(MUGL_DEBUG){console.warn(`Undefined uniform binding: ${uniform.binding}, slot: ${slot}`)}continue}if(MUGL_DEBUG){if(uniform.buffer){console.assert(uniformInfo.type===BindingType.Buffer,`Cannot bind buffer to uniform: ${uniformInfo.label}, binding: ${uniformInfo.binding}, slot: ${slot}`);console.assert(uniform.buffer.type===GLenum.UNIFORM_BUFFER,`Invalid buffer type bound to uniform buffer: ${uniformInfo.label}, binding: ${uniformInfo.binding}, slot: ${slot}`);const dataSize=device.gl.getActiveUniformBlockParameter(device.state.pipeline.glp,uniformInfo.index,GLenum.UNIFORM_BLOCK_DATA_SIZE);const alignment=device.gl.getParameter(GLenum.UNIFORM_BUFFER_OFFSET_ALIGNMENT);console.assert(uniform.buffer.size>=dataSize,`Uniform buffer not large enough: ${uniformInfo.label}, binding: ${uniformInfo.binding}, slot: ${slot}, UNIFORM_BLOCK_DATA_SIZE: ${dataSize}, UNIFORM_BUFFER_OFFSET_ALIGNMENT: ${alignment}, size: ${uniform.buffer.size}`)}else if(uniform.texture){console.assert(uniformInfo.type===BindingType.Texture,`Cannot bind texture to uniform: ${uniformInfo.label}, binding: ${uniformInfo.binding}, slot: ${slot}`)}else if(uniform.sampler){console.assert(uniformInfo.type===BindingType.Sampler,`Cannot bind sampler to uniform: ${uniformInfo.label}, binding: ${uniformInfo.binding}, slot: ${slot}`)}else{console.assert(false,`Either a buffer, texture, or sampler must be specified: ${uniformInfo.label}, binding: ${uniformInfo.binding}, slot: ${slot}`)}}if(uniform.buffer){let offset=uniform.bufferOffset||0;if(uniformInfo.bufferDynamicOffset){offset+=offsets[offsetIdx]||0;++offsetIdx}device.gl.bindBufferRange(GLenum.UNIFORM_BUFFER,uniformInfo.slot,uniform.buffer.glb,offset,uniform.bufferSize||uniform.buffer.size-offset)}else if(uniform.texture){device.gl.activeTexture(GLenum.TEXTURE0+uniformInfo.slot);device.gl.bindTexture(uniform.texture.type,uniform.texture.glt);device.gl.uniform1i(uniformInfo.loc,uniformInfo.slot)}else if(uniform.sampler){device.gl.bindSampler(uniformInfo.slot,uniform.sampler.gls)}}}export function draw(device,vertexCount,instanceCount=1,firstVertex=0,firstInstance=0){for(const buf of device.state.buffers){if(buf.step&&buf.instanceOffset!==firstInstance){buf.instanceOffset=firstInstance;vertexAttribs(device.gl,buf,firstInstance*buf.stride)}}device.gl.drawArraysInstanced(device.state.state.topology,firstVertex,vertexCount,instanceCount)}export function drawIndexed(device,indexCount,instanceCount=1,firstIndex=0,firstInstance=0){for(const buf of device.state.buffers){if(buf.step&&buf.instanceOffset!==firstInstance){buf.instanceOffset=firstInstance;vertexAttribs(device.gl,buf,firstInstance*buf.stride)}}device.gl.drawElementsInstanced(device.state.state.topology,indexCount,device.state.state.indexFormat,firstIndex*indexByteSize(device.state.state.indexFormat),instanceCount)}export function setViewport(device,x,y,width,height,minDepth=0,maxDepth=1){device.gl.viewport(x,y,width,height);device.gl.depthRange(minDepth,maxDepth)}export function setScissorRect(device,x,y,width,height){if(!device.state.scissor){glToggle(device.gl,GLenum.SCISSOR_TEST,true);device.state.scissor=true}device.gl.scissor(x,y,width,height)}export function setBlendConst(device,color){device.gl.blendColor(...color)}export function setStencilRef(device,ref){if(device.state.stencilRef!==ref){const{stencilFrontCompare,stencilBackCompare,stencilReadMask}=device.state.state;device.gl.stencilFuncSeparate(GLenum.FRONT,stencilFrontCompare,ref,stencilReadMask);device.gl.stencilFuncSeparate(GLenum.BACK,stencilBackCompare,ref,stencilReadMask);device.state.stencilRef=ref}}function initWebGL2State(gl){const state=createPipelineState();gl.blendColor(1,1,1,1);applyPipelineState(gl,state,state,0,true);for(let i=0;i<MAX_VERTEX_ATTRIBS;++i){gl.disableVertexAttribArray(i)}gl.pixelStorei(GLenum.PACK_ALIGNMENT,1);gl.pixelStorei(GLenum.UNPACK_ALIGNMENT,1);return{copyFrameBuffer:gl.createFramebuffer(),buffers:[],state,pipeline:null,index:null,stencilRef:0,scissor:false}}function compileShaderProgram(device,vertex,fragment){const glp=device.gl.createProgram();device.gl.attachShader(glp,vertex);device.gl.attachShader(glp,fragment);device.gl.linkProgram(glp);if(MUGL_DEBUG){console.assert(device.gl.getProgramParameter(glp,GLenum.LINK_STATUS)||isDeviceLost(device),`Failed to link program: ${device.gl.getProgramInfoLog(glp)}`)}return glp}function framebufferTexture(gl,attachment,{texture,slice=0,mipLevel=0}){if(is3DTexture(texture.type)){gl.framebufferTextureLayer(GLenum.FRAMEBUFFER,attachment,texture.glt,mipLevel,slice)}else{const texTarget=texture.type===GLenum.TEXTURE_CUBE_MAP?GLenum.TEXTURE_CUBE_MAP_POSITIVE_X+slice:texture.type;gl.framebufferTexture2D(GLenum.FRAMEBUFFER,attachment,texTarget,texture.glt,mipLevel)}}function createResolveFrameBuffer(gl,attachment,view){const fb=gl.createFramebuffer();gl.bindFramebuffer(GLenum.FRAMEBUFFER,fb);framebufferTexture(gl,attachment,view);if(MUGL_DEBUG){console.assert(gl.checkFramebufferStatus(GLenum.FRAMEBUFFER)===GLenum.FRAMEBUFFER_COMPLETE||gl.isContextLost(),"Framebuffer completeness check failed for MSAA resolve buffer")}return fb}function blitFramebuffer(gl,from,to,tex,mask,attachment=GLenum.COLOR_ATTACHMENT0){gl.bindFramebuffer(GLenum.READ_FRAMEBUFFER,from);gl.bindFramebuffer(GLenum.DRAW_FRAMEBUFFER,to);gl.readBuffer(attachment);gl.blitFramebuffer(0,0,tex.width,tex.height,0,0,tex.width,tex.height,mask,GLenum.NEAREST)}function createPipelineState(desc={}){const primitive=desc.primitive||{};const depthStencil=desc.depthStencil||{};const{stencilFront={},stencilBack={}}=depthStencil;const{sampleCount=1,alphaToCoverage=false}=desc.multisample||{};const targets=desc.targets||{};let blendWriteMask=targets.writeMask||ColorWrite.All;let blendColor=targets.blendColor||{};let blendAlpha=targets.blendColor||{};if(targets.targets&&targets.targets[0]){blendWriteMask=targets.targets[0].writeMask||blendWriteMask;blendColor=targets.targets[0].blendColor||blendColor;blendAlpha=targets.targets[0].blendAlpha||blendAlpha}return{sampleCount,alphaToCoverage,topology:primitive.topology||GLenum.TRIANGLES,indexFormat:primitive.indexFormat||GLenum.UNSIGNED_SHORT,frontFace:primitive.frontFace||GLenum.CCW,cullMode:primitive.cullMode||GLenum.NONE,depth:!!desc.depthStencil,depthWrite:depthStencil.depthWrite||false,depthFormat:depthStencil.format||GLenum.DEPTH_COMPONENT16,depthCompare:depthStencil.depthCompare||GLenum.ALWAYS,depthBias:depthStencil.depthBias||0,depthBiasSlopeScale:depthStencil.depthBiasSlopeScale||0,stencil:!!(depthStencil.stencilFront||depthStencil.stencilBack),stencilFrontCompare:stencilFront.compare||GLenum.ALWAYS,stencilFrontFailOp:stencilFront.failOp||GLenum.KEEP,stencilFrontDepthFailOp:stencilFront.depthFailOp||GLenum.KEEP,stencilFrontPassOp:stencilFront.passOp||GLenum.KEEP,stencilBackCompare:stencilBack.compare||GLenum.ALWAYS,stencilBackFailOp:stencilBack.failOp||GLenum.KEEP,stencilBackDepthFailOp:stencilBack.depthFailOp||GLenum.KEEP,stencilBackPassOp:stencilBack.passOp||GLenum.KEEP,stencilReadMask:depthStencil.stencilReadMask||STENCIL_MASK,stencilWriteMask:depthStencil.stencilWriteMask||STENCIL_MASK,blend:!!desc.targets,blendWriteMask,blendColorOp:blendColor.operation||GLenum.FUNC_ADD,blendColorSrcFactor:blendColor.srcFactor||GLenum.ONE,blendColorDstFactor:blendColor.dstFactor||GLenum.ZERO,blendAlphaOp:blendAlpha.operation||GLenum.FUNC_ADD,blendAlphaSrcFactor:blendAlpha.srcFactor||GLenum.ONE,blendAlphaDstFactor:blendAlpha.dstFactor||GLenum.ZERO}}function applyPipelineState(gl,prevState,state,stencilRef=0,force=false){let b=false,n=0,n2=0,n3=0,n4=0;n=state.frontFace;if(force||prevState.frontFace!==n){gl.frontFace(n)}n=state.cullMode;if(force||prevState.cullMode!==n){if(b=n!==GLenum.NONE){gl.cullFace(n)}glToggle(gl,GLenum.CULL_FACE,b)}b=state.alphaToCoverage;if(force||prevState.alphaToCoverage!==b){glToggle(gl,GLenum.SAMPLE_ALPHA_TO_COVERAGE,b)}b=!!state.depth;if(force||prevState.depth!==b){glToggle(gl,GLenum.DEPTH_TEST,b)}if(force||b){applyDepthMask(gl,prevState.depthWrite,state.depthWrite,force);n=state.depthCompare;if(force||prevState.depthCompare!==n){gl.depthFunc(n)}}n=state.depthBiasSlopeScale;n2=state.depthBias;if(force||prevState.depthBiasSlopeScale!==n||prevState.depthBias!==n2){glToggle(gl,GLenum.POLYGON_OFFSET_FILL,!(!n&&!n2));gl.polygonOffset(n,n2)}b=!!state.stencil;if(force||prevState.stencil!==b){glToggle(gl,GLenum.STENCIL_TEST,b)}if(force||b){n=state.stencilReadMask;b=force||prevState.stencilReadMask!==n;n2=state.stencilFrontCompare;if(b||prevState.stencilFrontCompare!==n2){gl.stencilFuncSeparate(GLenum.FRONT,n2,stencilRef,n)}n2=state.stencilBackCompare;if(b||prevState.stencilBackCompare!==n2){gl.stencilFuncSeparate(GLenum.BACK,n2,stencilRef,n)}n=state.stencilFrontFailOp;n2=state.stencilFrontDepthFailOp;n3=state.stencilFrontPassOp;if(force||prevState.stencilFrontFailOp!==n||prevState.stencilFrontDepthFailOp!==n2||prevState.stencilFrontPassOp!==n3){gl.stencilOpSeparate(GLenum.FRONT,n,n2,n3)}n=state.stencilBackFailOp;n2=state.stencilBackDepthFailOp;n3=state.stencilBackPassOp;if(force||prevState.stencilBackFailOp!==n||prevState.stencilBackDepthFailOp!==n2||prevState.stencilBackPassOp!==n3){gl.stencilOpSeparate(GLenum.BACK,n,n2,n3)}applyStencilMask(gl,prevState.stencilWriteMask,state.stencilWriteMask,force)}b=state.blend;if(force||prevState.blend!==b){glToggle(gl,GLenum.BLEND,b)}if(force||b){n=state.blendColorSrcFactor;n2=state.blendColorDstFactor;n3=state.blendAlphaSrcFactor;n4=state.blendAlphaDstFactor;if(force||prevState.blendColorSrcFactor!==n||prevState.blendColorDstFactor!==n2||prevState.blendAlphaSrcFactor!==n3||prevState.blendAlphaDstFactor!==n4){gl.blendFuncSeparate(n,n2,n3,n4)}n=state.blendColorOp;n2=state.blendAlphaOp;if(force||prevState.blendColorOp!==n||prevState.blendAlphaOp!==n2){gl.blendEquationSeparate(n,n2)}applyColorMask(gl,prevState.blendWriteMask,state.blendWriteMask,force)}}function applyColorMask(gl,prevMask,mask,force=false){if(force||prevMask!==mask){gl.colorMask(!!(mask&ColorWrite.Red),!!(mask&ColorWrite.Green),!!(mask&ColorWrite.Blue),!!(mask&ColorWrite.Alpha))}}function applyDepthMask(gl,prevMask,mask,force=false){if(force||prevMask!==mask){gl.depthMask(mask)}}function applyStencilMask(gl,prevMask,mask,force=false){if(force||prevMask!==mask){gl.stencilMask(mask)}}function glToggle(gl,flag,enable){enable?gl.enable(flag):gl.disable(flag)}function vertexAttribs(gl,buffer,offset){gl.bindBuffer(GLenum.ARRAY_BUFFER,buffer.glb);for(let i=0;i<buffer.attributes.length;++i){const{ptr,step}=buffer.attributes[i];const params=[...ptr];params[5]+=offset;gl.vertexAttribPointer(...params);gl.vertexAttribDivisor(ptr[0],step)}}function clientWaitAsync(gl,sync,flags,interval){return new Promise((resolve,reject)=>{function test(){const res=gl.clientWaitSync(sync,flags,0);if(res==GLenum.WAIT_FAILED){reject()}else if(res==GLenum.TIMEOUT_EXPIRED){setTimeout(test,interval)}else{resolve()}}test()})}function getBufferSubData(gl,target,buffer,srcOffset,length){const sync=gl.fenceSync(gl.SYNC_GPU_COMMANDS_COMPLETE,0);gl.flush();return clientWaitAsync(gl,sync,0,10).finally(()=>gl.deleteSync(sync)).then(()=>{const data=new Uint8Array(length);gl.bindBuffer(target,buffer);gl.getBufferSubData(target,srcOffset,data,0,length);return data})}
//# sourceMappingURL=gl2.js.map