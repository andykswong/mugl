import{GenerationalArena}from"@muds/store";import{BindingType,FutureStatus,SamplerBindingType,TextureDimension,TextureSampleType}from"../gpu/index.js";import{WebGL}from"../gpu/index.js";import{dataView,decodeStr,toWebGLContextAttributes}from"./deserialize.js";const contexts={};const futures=new GenerationalArena;const images=new GenerationalArena;const imageMap={};const canvases=new GenerationalArena;const canvasMap={};const canvasContextMap={};const resources=new GenerationalArena;const deviceContextMap={};function getMemory(context){return contexts[context].memory}function getDeviceMemory(resource){return getMemory(deviceContextMap[resource])}function deleteResource(id){const resource=resources.get(id);if(resource){resource.destroy();resources.delete(id)}}export function set_context_memory(context,memory){(contexts[context]=contexts[context]||{memory:null}).memory=memory}export function free_context(context){delete contexts[context]}export function get_future_status(future){const f=futures.get(future);if(f){if(f.status!==FutureStatus.Pending){futures.delete(future)}return f.status}return FutureStatus.Done}export function create_image(context,ptr,len){const img=new Image;img.crossOrigin="anonymous";img.src=decodeStr(getMemory(context),ptr,len);return images.add(img)}export function get_image_by_id(context,ptr,len){const id=decodeStr(getMemory(context),ptr,len);if(imageMap[id]){return imageMap[id]}const image=document.getElementById(id);if(!image){return 0}return imageMap[id]=images.add(image)}export function delete_image(img){images.delete(img)}export function get_image_width(img){return images.get(img)?.width||0}export function get_image_height(img){return images.get(img)?.height||0}export function get_canvas_by_id(context,ptr,len){const id=decodeStr(getMemory(context),ptr,len);if(canvasMap[id]){return canvasMap[id]}const canvas=document.getElementById(id);if(!canvas){return 0}const canvasId=canvasMap[id]=canvases.add(canvas);canvasContextMap[canvasId]=context;return canvasId}export function get_canvas_width(canvas){return canvases.get(canvas)?.width||0}export function get_canvas_height(canvas){return canvases.get(canvas)?.height||0}export function webgl_request_device(canvasId,attrs,features){const canvas=canvases.get(canvasId);if(canvas){const device=WebGL.requestWebGL2Device(canvas,toWebGLContextAttributes(attrs),features);if(device){const deviceId=resources.add(device);deviceContextMap[deviceId]=canvasContextMap[canvasId];return deviceId}}return 0}export function webgl_generate_mipmap(device,tex,hint){WebGL.generateMipmap(resources.get(device),resources.get(tex),hint)}export function reset_device(device){WebGL.resetDevice(resources.get(device))}export function delete_device(device){deleteResource(device);delete deviceContextMap[device]}export function is_device_lost(device){return WebGL.isDeviceLost(resources.get(device))}export function get_device_features(device){return WebGL.getDeviceFeatures(resources.get(device))}export function create_buffer(device,size,usage){const ret=WebGL.createBuffer(resources.get(device),{size:size>>>0,usage:usage>>>0});return resources.add(ret)}export{deleteResource as delete_buffer};export function create_texture(device,width,height,depth,mipLevelCount,sampleCount,dimension,format,usage){const ret=WebGL.createTexture(resources.get(device),{size:[width>>>0,height>>>0,depth>>>0],mipLevelCount:mipLevelCount>>>0,sampleCount:sampleCount>>>0,dimension:dimension>>>0,format:format>>>0,usage:usage>>>0});return resources.add(ret)}export{deleteResource as delete_texture};export function create_sampler(device,addressModeU,addressModeV,addressModeW,magFilter,minFilter,mipmapFilter,lodMinClamp,lodMaxClamp,compare,maxAnisotropy){const ret=WebGL.createSampler(resources.get(device),{addressModeU:addressModeU>>>0,addressModeV:addressModeV>>>0,addressModeW:addressModeW>>>0,magFilter:magFilter>>>0,minFilter:minFilter>>>0,mipmapFilter:mipmapFilter>>>0,lodMinClamp,lodMaxClamp,compare:compare>>>0,maxAnisotropy:maxAnisotropy>>>0});return resources.add(ret)}export{deleteResource as delete_sampler};export function create_shader(device,codePtr,codeLen,usage){const ret=WebGL.createShader(resources.get(device),{code:decodeStr(getDeviceMemory(device),codePtr,codeLen),usage:usage>>>0});return resources.add(ret)}export{deleteResource as delete_shader};export function create_bind_group_layout(device,entriesPtr,entriesLen){const memory=getDeviceMemory(device);const entries=[];for(let i=0;i<entriesLen;i++){const base=entriesPtr+i*32;const ptr0=dataView(memory).getUint32(base+0,true);const len0=dataView(memory).getUint32(base+4,true);const type=dataView(memory).getUint8(base+16);let bufferDynamicOffset=false;let samplerType=SamplerBindingType.Filtering;let textureSampleType=TextureSampleType.Float;let textureDimension=TextureDimension.D2;let textureMultisampled=false;switch(type){case BindingType.Buffer:bufferDynamicOffset=!!dataView(memory).getUint8(base+20);break;case BindingType.Sampler:samplerType=dataView(memory).getUint32(base+20,true)>>>0;break;case BindingType.Texture:textureSampleType=dataView(memory).getUint32(base+20,true)>>>0;textureDimension=dataView(memory).getUint32(base+24,true)>>>0;textureMultisampled=!!dataView(memory).getUint8(base+28);break;default:throw new RangeError("invalid variant discriminant for BindingType");}entries.push({label:decodeStr(memory,ptr0,len0),binding:dataView(memory).getUint32(base+8,true)>>>0,visibility:dataView(memory).getUint32(base+12,true)>>>0,type,bufferDynamicOffset,samplerType,textureSampleType,textureDimension,textureMultisampled})}const ret=WebGL.createBindGroupLayout(resources.get(device),{entries});return resources.add(ret)}export{deleteResource as delete_bind_group_layout};export function create_bind_group(device,layout,entriesPtr,entriesLen){const memory=getDeviceMemory(device);const entries=[];for(let i=0;i<entriesLen;i++){const base=entriesPtr+i*24;const type=dataView(memory).getUint8(base+4);let buffer=null;let bufferOffset=0;let bufferSize=0;let sampler=null;let texture=null;switch(type){case BindingType.Buffer:buffer=resources.get(dataView(memory).getFloat64(base+8,true));bufferOffset=dataView(memory).getUint32(base+16,true);bufferSize=dataView(memory).getUint32(base+20,true);break;case BindingType.Sampler:sampler=resources.get(dataView(memory).getFloat64(base+8,true));break;case BindingType.Texture:texture=resources.get(dataView(memory).getFloat64(base+8,true));break;default:throw new RangeError("invalid variant discriminant for BindingResource");}entries.push({binding:dataView(memory).getUint32(base+0,true),buffer,bufferOffset,bufferSize,sampler,texture})}const ret=WebGL.createBindGroup(resources.get(device),{layout:resources.get(layout),entries});return resources.add(ret)}export{deleteResource as delete_bind_group};export function create_render_pipeline(device,vertex,fragment,attributesPtr,attributesLen,buffersPtr,buffersLen,bindGroupsPtr,bindGroupsLen,topology,indexFormat,frontFace,cullMode,sampleCount,alphaToCoverage,hasDepthStencil,depthStencilFormat,depthWrite,depthCompare,stencilFrontCompare,stencilFrontFailOp,stencilFrontDepthFailOp,stencilFrontPassOp,stencilBackCompare,stencilBackFailOp,stencilBackDepthFailOp,stencilBackPassOp,stencilReadMask,stencilWriteMask,depthBias,depthBiasSlopeScale,depthBiasClamp,colorsPtr,colorsLen,colorWriteMask,blendColorOperation,blendColorSrcFactor,blendColorDstFactor,blendAlphaOperation,blendAlphaSrcFactor,blendAlphaDstFactor){const memory=getDeviceMemory(device);const attributes=[];for(let i=0;i<attributesLen;i++){const base=attributesPtr+i*12;attributes.push({format:dataView(memory).getUint32(base+0,true),offset:dataView(memory).getUint32(base+4,true),shaderLocation:dataView(memory).getUint32(base+8,true)})}const buffers=[];for(let i=0;i<buffersLen;i++){const base=buffersPtr+i*16;const start=dataView(memory).getUint32(base+0,true);const len=dataView(memory).getUint32(base+4,true);buffers.push({attributes:attributes.slice(start,start+len),stride:dataView(memory).getUint32(base+8,true),stepMode:dataView(memory).getUint32(base+12,true)})}const bindGroups=[];for(let i=0;i<bindGroupsLen;i++){const base=bindGroupsPtr+i*8;bindGroups.push(resources.get(dataView(memory).getFloat64(base+0,true)))}const targets=[];for(let i=0;i<colorsLen;i++){const base=colorsPtr+i*32;targets.push({format:dataView(memory).getUint32(base+0,true)>>>0,writeMask:dataView(memory).getUint32(base+4,true)>>>0,blendColor:{operation:dataView(memory).getUint32(base+8,true)>>>0,srcFactor:dataView(memory).getUint32(base+12,true)>>>0,dstFactor:dataView(memory).getUint32(base+16,true)>>>0},blendAlpha:{operation:dataView(memory).getUint32(base+20,true)>>>0,srcFactor:dataView(memory).getUint32(base+24,true)>>>0,dstFactor:dataView(memory).getUint32(base+28,true)>>>0}})}const ret=WebGL.createRenderPipeline(resources.get(device),{vertex:resources.get(vertex),fragment:resources.get(fragment),buffers,bindGroups,primitive:{topology:topology>>>0,indexFormat:indexFormat>>>0,frontFace:frontFace>>>0,cullMode:cullMode>>>0},multisample:{sampleCount:sampleCount>>>0,alphaToCoverage:!!alphaToCoverage},depthStencil:hasDepthStencil?{format:depthStencilFormat>>>0,depthWrite:!!depthWrite,depthCompare:depthCompare>>>0,stencilFront:{compare:stencilFrontCompare>>>0,failOp:stencilFrontFailOp>>>0,depthFailOp:stencilFrontDepthFailOp>>>0,passOp:stencilFrontPassOp>>>0},stencilBack:{compare:stencilBackCompare>>>0,failOp:stencilBackFailOp>>>0,depthFailOp:stencilBackDepthFailOp>>>0,passOp:stencilBackPassOp>>>0},stencilReadMask:stencilReadMask>>>0,stencilWriteMask:stencilWriteMask>>>0,depthBias,depthBiasSlopeScale,depthBiasClamp}:null,targets:{writeMask:colorWriteMask>>>0,blendColor:{operation:blendColorOperation>>>0,srcFactor:blendColorSrcFactor>>>0,dstFactor:blendColorDstFactor>>>0},blendAlpha:{operation:blendAlphaOperation>>>0,srcFactor:blendAlphaSrcFactor>>>0,dstFactor:blendAlphaDstFactor>>>0},targets}});return resources.add(ret)}export{deleteResource as delete_render_pipeline};export function create_render_pass(device,clearDepth,clearStencil,clearColorRed,clearColorGreen,clearColorBlue,clearColorAlpha,isOffscreen,depthStencilTexture,depthStecilMipLevel,depthStecilSlice,colorsPtr,colorsLen){const memory=getDeviceMemory(device);let desc;switch(isOffscreen){case 0:desc={clearDepth,clearStencil,clearColor:isNaN(clearColorRed)?null:[clearColorRed,clearColorGreen,clearColorBlue,clearColorAlpha]};break;case 1:{const colors=[];for(let i=0;i<colorsLen;i++){const base=colorsPtr+i*32;const clear=[dataView(memory).getFloat32(base+16,true),dataView(memory).getFloat32(base+20,true),dataView(memory).getFloat32(base+24,true),dataView(memory).getFloat32(base+28,true)];colors.push({view:{texture:resources.get(dataView(memory).getFloat64(base+0,true)),mipLevel:dataView(memory).getUint32(base+8,true),slice:dataView(memory).getUint32(base+12,true)},clear:isNaN(clear[0])?null:clear})}desc={clearDepth,clearStencil,colors,depthStencil:{texture:resources.get(depthStencilTexture),mipLevel:depthStecilMipLevel>>>0,slice:depthStecilSlice>>>0}};break}default:throw new RangeError("invalid variant discriminant for RenderPassDescriptor");}const ret=WebGL.createRenderPass(resources.get(device),desc);return resources.add(ret)}export{deleteResource as delete_render_pass};export function read_buffer(device,buffer,offset,outPtr,size){const ret=WebGL.readBuffer(resources.get(device),resources.get(buffer),new Uint8Array(getDeviceMemory(device).buffer.slice(outPtr,outPtr+size*1),offset>>>0));return futures.add(ret)}export function write_buffer(device,buffer,dataPtr,size,offset){WebGL.writeBuffer(resources.get(device),resources.get(buffer),new Uint8Array(getDeviceMemory(device).buffer.slice(dataPtr,dataPtr+size*1)),offset>>>0)}export function copy_buffer(device,src,dst,size,srcOffset,dstOffset){WebGL.copyBuffer(resources.get(device),resources.get(src),resources.get(dst),size>>>0,srcOffset>>>0,dstOffset>>>0)}export function write_texture(device,texture,mipLevel,x,y,z,dataPtr,dataLen,offset,bytesPerRow,rowsPerImage,width,height,depth){WebGL.writeTexture(resources.get(device),{texture:resources.get(texture),mipLevel:mipLevel>>>0,origin:[x>>>0,y>>>0,z>>>0]},new Uint8Array(getDeviceMemory(device).buffer.slice(dataPtr,dataPtr+dataLen*1)),{offset:offset>>>0,bytesPerRow:bytesPerRow>>>0,rowsPerImage:rowsPerImage>>>0},[width>>>0,height>>>0,depth>>>0])}export function copy_external_image_to_texture(device,src,srcX,srcY,dst,mipLevel,dstX,dstY,dstZ,width,height){WebGL.copyExternalImageToTexture(resources.get(device),{src:images.get(src),origin:[srcX>>>0,srcY>>>0]},{texture:resources.get(dst),mipLevel:mipLevel>>>0,origin:[dstX>>>0,dstY>>>0,dstZ>>>0]},[width>>>0,height>>>0])}export function copy_texture(device,src,srcMipLevel,srcX,srcY,srcZ,dst,dstMipLevel,dstX,dstY,dstZ,width,height,depth){WebGL.copyTexture(resources.get(device),{texture:resources.get(src),mipLevel:srcMipLevel>>>0,origin:[srcX>>>0,srcY>>>0,srcZ>>>0]},{texture:resources.get(dst),mipLevel:dstMipLevel>>>0,origin:[dstX>>>0,dstY>>>0,dstZ>>>0]},[width>>>0,height>>>0,depth>>>0])}export function copy_texture_to_buffer(device,src,srcMipLevel,srcX,srcY,srcZ,dst,offset,bytesPerRow,rowsPerImage,width,height,depth){WebGL.copyTextureToBuffer(resources.get(device),{texture:resources.get(src),mipLevel:srcMipLevel>>>0,origin:[srcX>>>0,srcY>>>0,srcZ>>>0]},resources.get(dst),{offset:offset>>>0,bytesPerRow:bytesPerRow>>>0,rowsPerImage:rowsPerImage>>>0},[width>>>0,height>>>0,depth>>>0])}export function begin_render_pass(device,pass){WebGL.beginRenderPass(resources.get(device),resources.get(pass))}export function begin_default_pass(device,clearDepth,clearStencil,clearColorRed,clearColorGreen,clearColorBlue,clearColorAlpha){WebGL.beginDefaultPass(resources.get(device),{clearColor:isNaN(clearColorRed)?null:[clearColorRed,clearColorGreen,clearColorBlue,clearColorAlpha],clearDepth,clearStencil})}export function submit_render_pass(device){WebGL.submitRenderPass(resources.get(device))}export function set_render_pipeline(device,pipeline){WebGL.setRenderPipeline(resources.get(device),resources.get(pipeline))}export function set_index(device,index){WebGL.setIndex(resources.get(device),resources.get(index))}export function set_vertex(device,slot,vertex,offset){WebGL.setVertex(resources.get(device),slot>>>0,resources.get(vertex),offset>>>0)}export function set_bind_group(device,slot,bindGroup,offsetsPtr,offsetsLen){WebGL.setBindGroup(resources.get(device),slot>>>0,resources.get(bindGroup),new Uint32Array(getDeviceMemory(device).buffer.slice(offsetsPtr,offsetsPtr+offsetsLen*4)))}export function draw(device,vertexCount,instanceCount,firstVertex,firstInstance){WebGL.draw(resources.get(device),vertexCount>>>0,instanceCount>>>0,firstVertex>>>0,firstInstance>>>0)}export function draw_indexed(device,indexCount,instanceCount,firstIndex,firstInstance){WebGL.drawIndexed(resources.get(device),indexCount>>>0,instanceCount>>>0,firstIndex>>>0,firstInstance>>>0)}export function set_viewport(device,x,y,width,height,minDepth,maxDepth){WebGL.setViewport(resources.get(device),x>>>0,y>>>0,width>>>0,height>>>0,minDepth>>>0,maxDepth>>>0)}export function set_scissor_rect(device,x,y,width,height){WebGL.setScissorRect(resources.get(device),x>>>0,y>>>0,width>>>0,height>>>0)}export function set_blend_const(device,red,green,blue,alpha){WebGL.setBlendConst(resources.get(device),[red,green,blue,alpha])}export function set_stencil_ref(device,ref){WebGL.setStencilRef(resources.get(device),ref>>>0)}
//# sourceMappingURL=wasm.js.map